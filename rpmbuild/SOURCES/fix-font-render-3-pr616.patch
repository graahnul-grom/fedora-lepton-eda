diff --git a/liblepton/include/i_vars_priv.h b/liblepton/include/i_vars_priv.h
index 8d564857e..e0bc7f2cb 100644
--- a/liblepton/include/i_vars_priv.h
+++ b/liblepton/include/i_vars_priv.h
@@ -4,3 +4,4 @@ extern int default_keep_invisible;
 
 extern int default_make_backup_files;
 extern int default_net_consolidate;
+extern int default_force_boundingbox;
diff --git a/liblepton/include/liblepton/geda_toplevel.h b/liblepton/include/liblepton/geda_toplevel.h
index 918f39a72..0199f6440 100644
--- a/liblepton/include/liblepton/geda_toplevel.h
+++ b/liblepton/include/liblepton/geda_toplevel.h
@@ -51,9 +51,6 @@ struct st_toplevel
   int auto_save_interval;
   gint auto_save_timeout;
 
-  /* controls if the whole bounding box is used in the auto whichend code */
-  int force_boundingbox;
-
   /* Renderer for calculating text bounds */
   void *rendered_text_bounds_data;
 
diff --git a/liblepton/src/a_basic.c b/liblepton/src/a_basic.c
index c212d6962..55608729d 100644
--- a/liblepton/src/a_basic.c
+++ b/liblepton/src/a_basic.c
@@ -105,6 +105,7 @@ GList *o_read_buffer (TOPLEVEL *toplevel, GList *object_list,
   int itemsread = 0;
 
   int embedded_level = 0;
+  gboolean force_boundingbox;
 
   g_return_val_if_fail ((buffer != NULL), NULL);
 
@@ -346,10 +347,13 @@ GList *o_read_buffer (TOPLEVEL *toplevel, GList *object_list,
         last_component = NULL;  /* no longer need to check */
   }
 
-  if (found_pin) {
-    if (release_ver <= VERSION_20020825) {
-      geda_pin_object_update_whichend (toplevel, new_object_list, found_pin);
-    }
+  if (release_ver <= VERSION_20020825) {
+    cfg_read_bool ("schematic.gui", "force-boundingbox",
+                   default_force_boundingbox, &force_boundingbox);
+
+    geda_pin_object_update_whichend (toplevel,
+                                     new_object_list,
+                                     (found_pin == 1 || force_boundingbox));
   }
 
   s_textbuffer_free(tb);
diff --git a/liblepton/src/geda_pin_object.c b/liblepton/src/geda_pin_object.c
index 3a1f47668..d0b57a5fc 100644
--- a/liblepton/src/geda_pin_object.c
+++ b/liblepton/src/geda_pin_object.c
@@ -570,64 +570,61 @@ geda_pin_object_modify(TOPLEVEL *toplevel, OBJECT *object, int x, int y, int whi
  *
  *  \param toplevel    The TOPLEVEL object
  *  \param object_list list of OBJECTs
- *  \param num_pins    pin count in the object list
- *
+ *  \param force_boundingbox Use the whole symbol bounding box to
+ *                           find pin connection points.
  */
 void
 geda_pin_object_update_whichend (TOPLEVEL *toplevel,
-                                 GList *object_list, int num_pins)
+                                 GList *object_list,
+                                 gboolean force_boundingbox)
 {
   OBJECT *o_current;
   GList *iter;
+  GList *pin_list = NULL;
   int top = 0, left = 0;
   int right = 0, bottom = 0;
   int d1, d2, d3, d4;
   int min0, min1;
   int min0_whichend, min1_whichend;
-  int rleft, rtop, rright, rbottom;
-  int found;
-
-  if (object_list && num_pins) {
-    if (num_pins == 1 || toplevel->force_boundingbox) {
-      world_get_object_glist_bounds (toplevel, object_list,
-                                     &left, &top, &right, &bottom);
-    } else {
-      found = 0;
-
-      /* only look at the pins to calculate bounds of the symbol */
-      iter = object_list;
-      while (iter != NULL) {
-        o_current = (OBJECT *)iter->data;
-        if (o_current->type == OBJ_PIN) {
-          (void) geda_object_calculate_visible_bounds(
-            toplevel, o_current, &rleft, &rtop, &rright, &rbottom);
-
-          if ( found ) {
-            left = MIN( left, rleft );
-            top = MIN( top, rtop );
-            right = MAX( right, rright );
-            bottom = MAX( bottom, rbottom );
-          } else {
-            left = rleft;
-            top = rtop;
-            right = rright;
-            bottom = rbottom;
-            found = 1;
-          }
-        }
-        iter = g_list_next (iter);
-      }
 
+  /* No objects, nothing to update. */
+  if (object_list == NULL) return;
+
+  for (iter = object_list;
+       iter != NULL;
+       iter = g_list_next (iter)) {
+    o_current = (OBJECT *)iter->data;
+    if (o_current->type == OBJ_PIN) {
+      pin_list = g_list_prepend (pin_list, o_current);
     }
+  }
+
+  /* No pins, nothing to update. */
+  if (pin_list == NULL) return;
+
+  if (force_boundingbox) {
+    /* Include text objects since we need full bounds. */
+    world_get_object_glist_bounds (toplevel,
+                                   object_list,
+                                   &left,
+                                   &top,
+                                   &right,
+                                   &bottom);
   } else {
-    return;
+    /* Only look at the pins to calculate symbol bounds. */
+    world_get_object_glist_bounds (toplevel,
+                                   pin_list,
+                                   &left,
+                                   &top,
+                                   &right,
+                                   &bottom);
   }
 
-  iter = object_list;
+  iter = pin_list;
   while (iter != NULL) {
     o_current = (OBJECT *)iter->data;
     /* Determine which end of the pin is on or nearest the boundary */
-    if (o_current->type == OBJ_PIN && o_current->whichend == -1) {
+    if (o_current->whichend == -1) {
       if (o_current->line->y[0] == o_current->line->y[1]) {
         /* horizontal */
 
@@ -691,6 +688,8 @@ geda_pin_object_update_whichend (TOPLEVEL *toplevel,
     }
     iter = g_list_next (iter);
   }
+
+  g_list_free (pin_list);
 }
 
 
diff --git a/liblepton/src/geda_toplevel.c b/liblepton/src/geda_toplevel.c
index 5025baaf0..927c20ecc 100644
--- a/liblepton/src/geda_toplevel.c
+++ b/liblepton/src/geda_toplevel.c
@@ -68,8 +68,6 @@ TOPLEVEL *s_toplevel_new (void)
 
   /* The following is an attempt at getting (deterministic) defaults */
   /* for the following variables */
-  toplevel->force_boundingbox = FALSE;
-
   toplevel->rendered_text_bounds_data = NULL;
 
   toplevel->change_notify_funcs = NULL;
diff --git a/liblepton/src/i_vars.c b/liblepton/src/i_vars.c
index b5e2a5d83..b8e67dfba 100644
--- a/liblepton/src/i_vars.c
+++ b/liblepton/src/i_vars.c
@@ -31,7 +31,7 @@ int   default_keep_invisible = TRUE;
 
 int   default_make_backup_files = TRUE;
 int   default_net_consolidate = TRUE;
-
+int   default_force_boundingbox = FALSE;
 
 
 /*! \brief Read configuration, initialize variables in TOPLEVEL object.
diff --git a/schematic/include/i_vars.h b/schematic/include/i_vars.h
index 1c2151134..7077cd56a 100644
--- a/schematic/include/i_vars.h
+++ b/schematic/include/i_vars.h
@@ -41,7 +41,6 @@ extern int default_setpagedevice_pagesize;
 extern int default_bus_ripper_size;
 extern int default_bus_ripper_type;
 extern int default_bus_ripper_rotation;
-extern int default_force_boundingbox;
 extern int default_grid_mode;
 extern int default_dots_grid_dot_size;
 extern int default_dots_grid_mode;
diff --git a/schematic/src/i_vars.c b/schematic/src/i_vars.c
index c24e0ea77..283ec7fe8 100644
--- a/schematic/src/i_vars.c
+++ b/schematic/src/i_vars.c
@@ -60,7 +60,6 @@ int   default_setpagedevice_pagesize = FALSE;
 int   default_bus_ripper_size = 200;
 int   default_bus_ripper_type = COMP_BUS_RIPPER;
 int   default_bus_ripper_rotation = NON_SYMMETRIC;
-int   default_force_boundingbox = FALSE;
 int   default_grid_mode = DEFAULT_GRID_MODE;
 int   default_dots_grid_dot_size = 1;
 int   default_dots_grid_mode = DOTS_GRID_VARIABLE_MODE;
@@ -373,10 +372,6 @@ i_vars_set (GschemToplevel* w_current)
                        sizeof( vals_brr ) / sizeof( vals_brr[0] ),
                        &w_current->bus_ripper_rotation);
 
-
-  cfg_read_bool ("schematic.gui", "force-boundingbox",
-                 default_force_boundingbox, &toplevel->force_boundingbox);
-
   cfg_read_int_with_check ("schematic.gui", "dots-grid-dot-size",
                            default_dots_grid_dot_size, &w_current->dots_grid_dot_size,
                            &cfg_check_int_greater_0);
