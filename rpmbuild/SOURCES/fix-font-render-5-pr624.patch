diff --git a/attrib/src/s_object.c b/attrib/src/s_object.c
index 33f9e493d..a474d6d28 100644
--- a/attrib/src/s_object.c
+++ b/attrib/src/s_object.c
@@ -193,11 +193,11 @@ void s_object_replace_attrib_in_object(TOPLEVEL *toplevel,
       old_attrib_name = u_basic_breakup_string(old_attrib_text, '=', 0);
 
       if (strcmp(old_attrib_name, new_attrib_name) == 0) {
-	/* create attrib=value text string & stuff it back into toplevel */
+	/* create attrib=value text string */
 	new_attrib_text = g_strconcat(new_attrib_name, "=", new_attrib_value, NULL);
-  o_text_set_string (toplevel, a_current, new_attrib_text);
+        o_text_set_string (a_current, new_attrib_text);
 	if (visibility != LEAVE_VISIBILITY_ALONE)
-	  o_set_visibility (toplevel, a_current, visibility);
+	  o_set_visibility (a_current, visibility);
 	if (show_name_value != LEAVE_NAME_VALUE_ALONE)
 	  a_current->show_name_value = show_name_value;
 	g_free(new_attrib_text);
@@ -343,8 +343,7 @@ s_object_attrib_add_attrib_in_object (TOPLEVEL *toplevel,
   printf ("     show_name_value = %d\n", show_name_value);
 #endif
 
-  new_obj = geda_text_object_new (toplevel,
-                                  color,
+  new_obj = geda_text_object_new (color,
                                   world_x,
                                   world_y,
                                   LOWER_LEFT,
@@ -353,16 +352,15 @@ s_object_attrib_add_attrib_in_object (TOPLEVEL *toplevel,
                                   DEFAULT_TEXT_SIZE,
                                   visibility,
                                   show_name_value);
-  s_page_append (toplevel, toplevel->page_current, new_obj);
+  s_page_append (toplevel->page_current, new_obj);
 
   /* now toplevel->page_current->object_tail contains new text item */
 
   /* now attach the attribute to the object */
   /* remember that o_current contains the object to get the attribute */
-  o_attrib_attach (toplevel, new_obj, o_current, FALSE);
+  o_attrib_attach (new_obj, o_current, FALSE);
 
-  o_selection_add (toplevel,
-                   toplevel->page_current->selection_list, new_obj);
+  o_selection_add (toplevel->page_current->selection_list, new_obj);
 
 
   toplevel->page_current->CHANGED = 1;
@@ -386,8 +384,8 @@ void
 s_object_delete_text_object_in_object (TOPLEVEL *toplevel,
                                        OBJECT * text_object)
 {
-  s_page_remove (toplevel, toplevel->page_current, text_object);
-  s_delete_object (toplevel, text_object);
+  s_page_remove (toplevel->page_current, text_object);
+  s_delete_object (text_object);
   toplevel->page_current->CHANGED = 1;
 }
 
diff --git a/attrib/src/s_table.c b/attrib/src/s_table.c
index 6e168b1b2..0ad0cfe6c 100644
--- a/attrib/src/s_table.c
+++ b/attrib/src/s_table.c
@@ -328,7 +328,7 @@ void s_table_add_toplevel_comp_items_to_comp_table (const GList *obj_list) {
             attrib_text = g_strdup(geda_text_object_get_string (a_current));
             attrib_name = u_basic_breakup_string(attrib_text, '=', 0);
             attrib_value = s_misc_remaining_string(attrib_text, '=', 1);
-            old_visibility = o_is_visible (pr_current, a_current)
+            old_visibility = o_is_visible (a_current)
               ? VISIBLE : INVISIBLE;
 	    old_show_name_value = a_current->show_name_value;
 
diff --git a/attrib/src/x_fileselect.c b/attrib/src/x_fileselect.c
index b64611ba2..a0495cce6 100644
--- a/attrib/src/x_fileselect.c
+++ b/attrib/src/x_fileselect.c
@@ -300,7 +300,7 @@ x_fileselect_save (void)
 
     /* try saving current page of toplevel to file filename */
     if (filename != NULL &&
-        f_save (pr_current, pr_current->page_current, filename, NULL)) {
+        f_save (pr_current->page_current, filename, NULL)) {
       s_log_message (_("Saved As [%1$s]"), filename);
 
       /* replace page filename with new one */
diff --git a/liblepton/include/liblepton/geda_arc_object.h b/liblepton/include/liblepton/geda_arc_object.h
index 6311ce74d..8d2a04b56 100644
--- a/liblepton/include/liblepton/geda_arc_object.h
+++ b/liblepton/include/liblepton/geda_arc_object.h
@@ -32,8 +32,7 @@ G_BEGIN_DECLS
 /* construction, destruction */
 
 GedaObject*
-geda_arc_object_new (TOPLEVEL *toplevel,
-                     gint color,
+geda_arc_object_new (gint color,
                      gint center_x,
                      gint center_y,
                      gint radius,
@@ -41,13 +40,12 @@ geda_arc_object_new (TOPLEVEL *toplevel,
                      gint sweep_angle);
 
 GedaObject*
-geda_arc_object_copy (TOPLEVEL *toplevel, const GedaObject *object);
+geda_arc_object_copy (const GedaObject *object);
 
 /* methods */
 
 void
-geda_arc_object_calculate_bounds (TOPLEVEL *toplevel,
-                                  const OBJECT *object,
+geda_arc_object_calculate_bounds (const OBJECT *object,
                                   gint *left,
                                   gint *top,
                                   gint *right,
@@ -72,21 +70,18 @@ gint
 geda_arc_object_get_sweep_angle (const GedaObject *object);
 
 void
-geda_arc_object_mirror (TOPLEVEL *toplevel,
-                        int world_centerx,
+geda_arc_object_mirror (int world_centerx,
                         int world_centery,
                         OBJECT *object);
 
 void
-geda_arc_object_modify (TOPLEVEL *toplevel,
-                        OBJECT *object,
+geda_arc_object_modify (OBJECT *object,
                         int x,
                         int y,
                         int whichone);
 
 void
-geda_arc_object_rotate (TOPLEVEL *toplevel,
-                        int world_centerx,
+geda_arc_object_rotate (int world_centerx,
                         int world_centery,
                         int angle,
                         OBJECT *object);
@@ -120,8 +115,7 @@ void
 geda_arc_object_translate (GedaObject *object, int dx, int dy);
 
 OBJECT*
-o_arc_read (TOPLEVEL *toplevel,
-            const char buf[],
+o_arc_read (const char buf[],
             unsigned int release_ver,
             unsigned int fileformat_ver,
             GError **err);
diff --git a/liblepton/include/liblepton/geda_box_object.h b/liblepton/include/liblepton/geda_box_object.h
index f9c8dc0b9..9b786fc0c 100644
--- a/liblepton/include/liblepton/geda_box_object.h
+++ b/liblepton/include/liblepton/geda_box_object.h
@@ -32,8 +32,7 @@ G_BEGIN_DECLS
 /* construction, destruction */
 
 OBJECT*
-geda_box_object_new (TOPLEVEL *toplevel,
-                     char type,
+geda_box_object_new (char type,
                      int color,
                      int x1,
                      int y1,
@@ -41,42 +40,37 @@ geda_box_object_new (TOPLEVEL *toplevel,
                      int y2);
 
 OBJECT*
-geda_box_object_copy (TOPLEVEL *toplevel, OBJECT *o_current);
+geda_box_object_copy (OBJECT *o_current);
 
 /* methods */
 
 void
-geda_box_object_calculate_bounds (TOPLEVEL *toplevel,
-                                  const OBJECT *object,
+geda_box_object_calculate_bounds (const OBJECT *object,
                                   GedaBounds *bounds);
 
 gboolean
 geda_box_object_get_position (const GedaObject *object, gint *x, gint *y);
 
 void
-geda_box_object_mirror (TOPLEVEL *toplevel,
-                        int world_centerx,
+geda_box_object_mirror (int world_centerx,
                         int world_centery,
                         OBJECT *object);
 
 void
-geda_box_object_modify (TOPLEVEL *toplevel,
-                        OBJECT *object,
+geda_box_object_modify (OBJECT *object,
                         int x,
                         int y,
                         int whichone);
 
 void
-geda_box_object_modify_all (TOPLEVEL *toplevel,
-                            OBJECT *object,
+geda_box_object_modify_all (OBJECT *object,
                             int x1,
                             int y1,
                             int x2,
                             int y2);
 
 void
-geda_box_object_rotate (TOPLEVEL *toplevel,
-                        int world_centerx,
+geda_box_object_rotate (int world_centerx,
                         int world_centery,
                         int angle,
                         OBJECT *object);
@@ -95,8 +89,7 @@ void
 geda_box_object_translate (GedaObject *object, int dx, int dy);
 
 OBJECT*
-o_box_read (TOPLEVEL *toplevel,
-            const char buf[],
+o_box_read (const char buf[],
             unsigned int release_ver,
             unsigned int fileformat_ver,
             GError **err);
diff --git a/liblepton/include/liblepton/geda_bus_object.h b/liblepton/include/liblepton/geda_bus_object.h
index f0d6f8ba0..054db773f 100644
--- a/liblepton/include/liblepton/geda_bus_object.h
+++ b/liblepton/include/liblepton/geda_bus_object.h
@@ -27,8 +27,7 @@ G_BEGIN_DECLS
 /* construction, destruction */
 
 GedaObject*
-geda_bus_object_new (TOPLEVEL *toplevel,
-                     gint color,
+geda_bus_object_new (gint color,
                      gint x1,
                      gint y1,
                      gint x2,
@@ -36,13 +35,12 @@ geda_bus_object_new (TOPLEVEL *toplevel,
                      gint bus_ripper_direction);
 
 GedaObject*
-geda_bus_object_copy (TOPLEVEL *toplevel, const GedaObject *o_current);
+geda_bus_object_copy (const GedaObject *o_current);
 
 /* methods */
 
 void
-geda_bus_object_calculate_bounds (TOPLEVEL *toplevel,
-                                  const GedaObject *object,
+geda_bus_object_calculate_bounds (const GedaObject *object,
                                   GedaBounds *bounds);
 
 gboolean
@@ -64,14 +62,12 @@ gint
 geda_bus_object_get_y1 (const GedaObject *object);
 
 void
-geda_bus_object_mirror (TOPLEVEL *toplevel,
-                        gint world_centerx,
+geda_bus_object_mirror (gint world_centerx,
                         gint world_centery,
                         OBJECT *object);
 
 void
-geda_bus_object_modify (TOPLEVEL *toplevel,
-                        GedaObject *object,
+geda_bus_object_modify (GedaObject *object,
                         gint x,
                         gint y,
                         gint whichone);
@@ -80,8 +76,7 @@ gint
 geda_bus_object_orientation (const GedaObject *object);
 
 void
-geda_bus_object_rotate (TOPLEVEL *toplevel,
-                        gint world_centerx,
+geda_bus_object_rotate (gint world_centerx,
                         gint world_centery,
                         gint angle,
                         GedaObject *object);
@@ -108,8 +103,7 @@ void
 geda_bus_object_translate (GedaObject *object, gint dx, gint dy);
 
 GedaObject*
-o_bus_read (TOPLEVEL *toplevel,
-            const char buf[],
+o_bus_read (const char buf[],
             unsigned int release_ver,
             unsigned int fileformat_ver,
             GError **err);
diff --git a/liblepton/include/liblepton/geda_circle_object.h b/liblepton/include/liblepton/geda_circle_object.h
index ebd9890d9..84f018fc4 100644
--- a/liblepton/include/liblepton/geda_circle_object.h
+++ b/liblepton/include/liblepton/geda_circle_object.h
@@ -30,20 +30,18 @@ G_BEGIN_DECLS
 /* construction, destruction */
 
 GedaObject*
-geda_circle_object_new (TOPLEVEL *toplevel,
-                        gint color,
+geda_circle_object_new (gint color,
                         gint x,
                         gint y,
                         gint radius);
 
 GedaObject*
-geda_circle_object_copy (TOPLEVEL *toplevel, const GedaObject *o_current);
+geda_circle_object_copy (const GedaObject *o_current);
 
 /* methods */
 
 void
-geda_circle_object_calculate_bounds (TOPLEVEL *toplevel,
-                                     const GedaObject *object,
+geda_circle_object_calculate_bounds (const GedaObject *object,
                                      GedaBounds *bounds);
 
 gint
@@ -59,21 +57,18 @@ gint
 geda_circle_object_get_radius (const GedaObject *object);
 
 void
-geda_circle_object_mirror (TOPLEVEL *toplevel,
-                           gint world_centerx,
+geda_circle_object_mirror (gint world_centerx,
                            gint world_centery,
                            OBJECT *object);
 
 void
-geda_circle_object_modify (TOPLEVEL *toplevel,
-                           GedaObject *object,
+geda_circle_object_modify (GedaObject *object,
                            gint x,
                            gint y,
                            gint whichone);
 
 void
-geda_circle_object_rotate (TOPLEVEL *toplevel,
-                           gint world_centerx,
+geda_circle_object_rotate (gint world_centerx,
                            gint world_centery,
                            gint angle,
                            GedaObject *object);
@@ -101,8 +96,7 @@ void
 geda_circle_object_translate (GedaObject *object, gint dx, gint dy);
 
 GedaObject*
-o_circle_read (TOPLEVEL *toplevel,
-               const char buf[],
+o_circle_read (const char buf[],
                unsigned int release_ver,
                unsigned int fileformat_ver,
                GError **err);
diff --git a/liblepton/include/liblepton/geda_component_object.h b/liblepton/include/liblepton/geda_component_object.h
index cafb27fc8..828fbed52 100644
--- a/liblepton/include/liblepton/geda_component_object.h
+++ b/liblepton/include/liblepton/geda_component_object.h
@@ -31,7 +31,7 @@ int world_get_object_glist_bounds(TOPLEVEL *toplevel, const GList *o_list,
 int o_component_is_embedded (OBJECT *o_current);
 
 GList*
-o_component_promote_attribs (TOPLEVEL *toplevel, OBJECT *object);
+o_component_promote_attribs (OBJECT *object);
 
 OBJECT*
 o_component_new (TOPLEVEL *toplevel, char type, int color, int x, int y, int angle, int mirror, const CLibSymbol *clib_sym, const gchar *basename, int selectable);
@@ -48,13 +48,18 @@ void
 geda_component_object_translate (GedaObject *object, int dx, int dy);
 
 OBJECT *
-o_component_copy (TOPLEVEL *toplevel, OBJECT *o_current);
+o_component_copy (OBJECT *o_current);
 
 void
-geda_component_object_rotate (TOPLEVEL *toplevel, int world_centerx, int world_centery, int angle, OBJECT *object);
+geda_component_object_rotate (int world_centerx,
+                              int world_centery,
+                              int angle,
+                              OBJECT *object);
 
 void
-geda_component_object_mirror (TOPLEVEL *toplevel, int world_centerx, int world_centery, OBJECT *object);
+geda_component_object_mirror (int world_centerx,
+                              int world_centery,
+                              OBJECT *object);
 
 OBJECT *
 o_component_find_pin_by_attribute (OBJECT *object, const char *name, char *wanted_value);
@@ -75,7 +80,8 @@ gboolean
 geda_component_object_get_position (const GedaObject *object, gint *x, gint *y);
 
 GList*
-o_component_get_promotable (TOPLEVEL *toplevel, OBJECT *object, int detach);
+o_component_get_promotable (OBJECT *object,
+                            int detach);
 
 void
 set_render_placeholders();
diff --git a/liblepton/include/liblepton/geda_line_object.h b/liblepton/include/liblepton/geda_line_object.h
index be815da8b..cc2c338a8 100644
--- a/liblepton/include/liblepton/geda_line_object.h
+++ b/liblepton/include/liblepton/geda_line_object.h
@@ -30,21 +30,19 @@ G_BEGIN_DECLS
 /* construction, destruction */
 
 GedaObject*
-geda_line_object_new (TOPLEVEL *toplevel,
-                      gint color,
+geda_line_object_new (gint color,
                       gint x1,
                       gint y1,
                       gint x2,
                       gint y2);
 
 OBJECT*
-geda_line_object_copy (TOPLEVEL *toplevel, OBJECT *o_current);
+geda_line_object_copy (OBJECT *o_current);
 
 /* methods */
 
 void
-geda_line_object_calculate_bounds (TOPLEVEL *toplevel,
-                                   const OBJECT *object,
+geda_line_object_calculate_bounds (const OBJECT *object,
                                    GedaBounds *bounds);
 
 gboolean
@@ -66,21 +64,18 @@ double
 geda_line_object_length (OBJECT *object);
 
 void
-geda_line_object_mirror (TOPLEVEL *toplevel,
-                         int world_centerx,
+geda_line_object_mirror (int world_centerx,
                          int world_centery,
                          OBJECT *object);
 
 void
-geda_line_object_modify (TOPLEVEL *toplevel,
-                         OBJECT *object,
+geda_line_object_modify (OBJECT *object,
                          int x,
                          int y,
                          int whichone);
 
 void
-geda_line_object_rotate (TOPLEVEL *toplevel,
-                         int world_centerx,
+geda_line_object_rotate (int world_centerx,
                          int world_centery,
                          int angle,
                          OBJECT *object);
@@ -111,8 +106,7 @@ void
 geda_line_object_translate (GedaObject *object, int dx, int dy);
 
 OBJECT*
-o_line_read (TOPLEVEL *toplevel,
-             const char buf[],
+o_line_read (const char buf[],
              unsigned int release_ver,
              unsigned int fileformat_ver,
              GError **err);
diff --git a/liblepton/include/liblepton/geda_net_object.h b/liblepton/include/liblepton/geda_net_object.h
index 9ba3adffb..f47ffd39a 100644
--- a/liblepton/include/liblepton/geda_net_object.h
+++ b/liblepton/include/liblepton/geda_net_object.h
@@ -32,8 +32,7 @@ G_BEGIN_DECLS
 /* construction, destruction */
 
 OBJECT*
-geda_net_object_new (TOPLEVEL *toplevel,
-                     char type,
+geda_net_object_new (char type,
                      int color,
                      int x1,
                      int y1,
@@ -41,17 +40,16 @@ geda_net_object_new (TOPLEVEL *toplevel,
                      int y2);
 
 OBJECT*
-geda_net_object_copy (TOPLEVEL *toplevel, OBJECT *o_current);
+geda_net_object_copy (OBJECT *o_current);
 
 /* methods */
 
 void
-geda_net_object_calculate_bounds (TOPLEVEL *toplevel,
-                                  const OBJECT *object,
+geda_net_object_calculate_bounds (const OBJECT *object,
                                   GedaBounds *bounds);
 
 void
-geda_net_object_consolidate (TOPLEVEL *toplevel, PAGE *page);
+geda_net_object_consolidate (PAGE *page);
 
 gboolean
 geda_net_object_get_position (const GedaObject *object, gint *x, gint *y);
@@ -69,14 +67,12 @@ gint
 geda_net_object_get_y1 (const GedaObject *object);
 
 void
-geda_net_object_mirror (TOPLEVEL *toplevel,
-                        int world_centerx,
+geda_net_object_mirror (int world_centerx,
                         int world_centery,
                         OBJECT *object);
 
 void
-geda_net_object_modify (TOPLEVEL *toplevel,
-                        OBJECT *object,
+geda_net_object_modify (OBJECT *object,
                         int x,
                         int y,
                         int whichone);
@@ -85,8 +81,7 @@ int
 geda_net_object_orientation (OBJECT *object);
 
 void
-geda_net_object_rotate (TOPLEVEL *toplevel,
-                        int world_centerx,
+geda_net_object_rotate (int world_centerx,
                         int world_centery,
                         int angle,
                         OBJECT *object);
@@ -110,8 +105,7 @@ void
 geda_net_object_translate (GedaObject *object, int dx, int dy);
 
 OBJECT*
-o_net_read (TOPLEVEL *toplevel,
-            const char buf[],
+o_net_read (const char buf[],
             unsigned int release_ver,
             unsigned int fileformat_ver,
             GError **err);
diff --git a/liblepton/include/liblepton/geda_object.h b/liblepton/include/liblepton/geda_object.h
index 40cb81448..5889663c1 100644
--- a/liblepton/include/liblepton/geda_object.h
+++ b/liblepton/include/liblepton/geda_object.h
@@ -95,10 +95,10 @@ OBJECT*
 s_basic_new_object (int type, char const *prefix);
 
 OBJECT*
-o_object_copy (TOPLEVEL *toplevel, OBJECT *selected);
+o_object_copy (OBJECT *selected);
 
 void
-s_delete_object (TOPLEVEL *toplevel, OBJECT *o_current);
+s_delete_object (OBJECT *o_current);
 
 /* methods */
 
@@ -126,15 +126,13 @@ gint
 geda_object_get_visible (const GedaObject *object);
 
 void
-geda_object_rotate (TOPLEVEL *toplevel,
-                    int world_centerx,
+geda_object_rotate (int world_centerx,
                     int world_centery,
                     int angle,
                     OBJECT *object);
 
 void
-geda_object_mirror (TOPLEVEL *toplevel,
-                    int world_centerx,
+geda_object_mirror (int world_centerx,
                     int world_centery,
                     OBJECT *object);
 
@@ -178,27 +176,26 @@ PAGE*
 o_get_page (OBJECT *object);
 
 OBJECT*
-o_get_parent (TOPLEVEL *toplevel, OBJECT *object);
+o_get_parent (OBJECT *object);
 
 gboolean
-o_is_visible (const TOPLEVEL *toplevel, const OBJECT *object);
+o_is_visible (const OBJECT *object);
 
 void
-o_set_color(TOPLEVEL *toplevel, OBJECT *object, int color);
+o_set_color (OBJECT *object,
+             int color);
 
 void
-o_set_fill_options(TOPLEVEL *toplevel,
-                   OBJECT *o_current,
-                   OBJECT_FILLING type,
-                   int width,
-                   int pitch1,
-                   int angle1,
-                   int pitch2,
-                   int angle2);
+o_set_fill_options (OBJECT *o_current,
+                    OBJECT_FILLING type,
+                    int width,
+                    int pitch1,
+                    int angle1,
+                    int pitch2,
+                    int angle2);
 
 void
-o_set_line_options (TOPLEVEL *toplevel,
-                    OBJECT *o_current,
+o_set_line_options (OBJECT *o_current,
                     OBJECT_END end,
                     OBJECT_TYPE type,
                     int width,
@@ -206,7 +203,8 @@ o_set_line_options (TOPLEVEL *toplevel,
                     int space);
 
 void
-o_set_visibility (TOPLEVEL *toplevel, OBJECT *object, int visibility);
+o_set_visibility (OBJECT *object,
+                  int visibility);
 
 void
 o_add_change_notify (TOPLEVEL *toplevel,
diff --git a/liblepton/include/liblepton/geda_object_list.h b/liblepton/include/liblepton/geda_object_list.h
index e36fe56d4..cf8384f8d 100644
--- a/liblepton/include/liblepton/geda_object_list.h
+++ b/liblepton/include/liblepton/geda_object_list.h
@@ -23,19 +23,25 @@
 G_BEGIN_DECLS
 
 void
-geda_object_list_delete (TOPLEVEL *toplevel, GList *list);
+geda_object_list_delete (GList *list);
 
 void
-geda_object_list_mirror (const GList *objects, int x, int y, TOPLEVEL *toplevel);
+geda_object_list_mirror (const GList *objects,
+                         int x,
+                         int y);
 
 void
 geda_object_list_print (GList *objects);
 
 void
-geda_object_list_rotate (const GList *objects, int x, int y, int angle, TOPLEVEL *toplevel);
+geda_object_list_rotate (const GList *objects,
+                         int x,
+                         int y,
+                         int angle);
 
 void
-geda_object_list_set_color (const GList *objects, int color, TOPLEVEL *toplevel);
+geda_object_list_set_color (const GList *objects,
+                            int color);
 
 void
 geda_object_list_set_selectable (const GList *objects, gboolean selectable);
@@ -47,6 +53,7 @@ void
 geda_object_list_translate (const GList *objects, int dx, int dy);
 
 GList*
-o_glist_copy_all (TOPLEVEL *toplevel, const GList *src_list, GList *dest_list);
+o_glist_copy_all (const GList *src_list,
+                  GList *dest_list);
 
 G_END_DECLS
diff --git a/liblepton/include/liblepton/geda_page.h b/liblepton/include/liblepton/geda_page.h
index 5a8aad3b6..23e26b80c 100644
--- a/liblepton/include/liblepton/geda_page.h
+++ b/liblepton/include/liblepton/geda_page.h
@@ -115,19 +115,23 @@ gint
 s_page_autosave (TOPLEVEL *toplevel);
 
 void
-s_page_append (TOPLEVEL *toplevel, PAGE *page, OBJECT *object);
+s_page_append (PAGE *page,
+               OBJECT *object);
 
 void
-s_page_append_list (TOPLEVEL *toplevel, PAGE *page, GList *obj_list);
+s_page_append_list (PAGE *page,
+                    GList *obj_list);
 
 void
-s_page_remove (TOPLEVEL *toplevel, PAGE *page, OBJECT *object);
+s_page_remove (PAGE *page, OBJECT *object);
 
 void
-s_page_replace (TOPLEVEL *toplevel, PAGE *page, OBJECT *object1, OBJECT *object2);
+s_page_replace (PAGE *page,
+                OBJECT *object1,
+                OBJECT *object2);
 
 void
-s_page_delete_objects (TOPLEVEL *toplevel, PAGE *page);
+s_page_delete_objects (PAGE *page);
 
 const GList*
 s_page_objects (PAGE *page);
diff --git a/liblepton/include/liblepton/geda_path_object.h b/liblepton/include/liblepton/geda_path_object.h
index 7bc2e0ede..d22c1dad0 100644
--- a/liblepton/include/liblepton/geda_path_object.h
+++ b/liblepton/include/liblepton/geda_path_object.h
@@ -25,33 +25,48 @@
 G_BEGIN_DECLS
 
 OBJECT*
-geda_path_object_new (TOPLEVEL *toplevel, char type, int color, const char *path_string);
+geda_path_object_new (char type,
+                      int color,
+                      const char *path_string);
 
 OBJECT*
-geda_path_object_new_take_path (TOPLEVEL *toplevel, char type, int color, PATH *path_data);
+geda_path_object_new_take_path (char type,
+                                int color,
+                                PATH *path_data);
 
 OBJECT*
-geda_path_object_copy (TOPLEVEL *toplevel, OBJECT *o_current);
+geda_path_object_copy (OBJECT *o_current);
 
 void
-geda_path_object_calculate_bounds (TOPLEVEL *toplevel,
-                                   const OBJECT *object,
+geda_path_object_calculate_bounds (const OBJECT *object,
                                    GedaBounds *bounds);
 
 void
-geda_path_object_modify (TOPLEVEL *toplevel, OBJECT *object, int x, int y, int whichone);
+geda_path_object_modify (OBJECT *object,
+                         int x,
+                         int y,
+                         int whichone);
 
 void
 geda_path_object_translate (GedaObject *object, int dx, int dy);
 
 void
-geda_path_object_rotate (TOPLEVEL *toplevel, int world_centerx, int world_centery, int angle, OBJECT *object);
+geda_path_object_rotate (int world_centerx,
+                         int world_centery,
+                         int angle,
+                         OBJECT *object);
 
 void
-geda_path_object_mirror (TOPLEVEL *toplevel, int world_centerx, int world_centery, OBJECT *object);
+geda_path_object_mirror (int world_centerx,
+                         int world_centery,
+                         OBJECT *object);
 
 OBJECT*
-o_path_read(TOPLEVEL *toplevel, const char *first_line, TextBuffer *tb, unsigned int release_ver, unsigned int fileformat_ver, GError **err);
+o_path_read (const char *first_line,
+             TextBuffer *tb,
+             unsigned int release_ver,
+             unsigned int fileformat_ver,
+             GError **err);
 
 gchar*
 geda_path_object_to_buffer (const GedaObject *object);
diff --git a/liblepton/include/liblepton/geda_picture_object.h b/liblepton/include/liblepton/geda_picture_object.h
index 620f2eec9..0bda18605 100644
--- a/liblepton/include/liblepton/geda_picture_object.h
+++ b/liblepton/include/liblepton/geda_picture_object.h
@@ -29,11 +29,17 @@ G_BEGIN_DECLS
 #define PICTURE_UPPER_RIGHT 2
 #define PICTURE_LOWER_LEFT  3
 
-OBJECT *o_picture_new(TOPLEVEL *toplevel,
-                      const gchar *file_content, gsize file_length,
-                      const gchar *filename, char type,
-                      int x1, int y1, int x2, int y2, int angle, int mirrored,
-                      int embedded) G_GNUC_WARN_UNUSED_RESULT;
+OBJECT *o_picture_new (const gchar *file_content,
+                       gsize file_length,
+                       const gchar *filename,
+                       char type,
+                       int x1,
+                       int y1,
+                       int x2,
+                       int y2,
+                       int angle,
+                       int mirrored,
+                       int embedded) G_GNUC_WARN_UNUSED_RESULT;
 
 void
 geda_picture_object_calculate_bounds (const OBJECT *object,
@@ -43,47 +49,64 @@ double
 o_picture_get_ratio (OBJECT *object);
 
 void
-o_picture_modify(TOPLEVEL *toplevel, OBJECT *object, int x, int y, int whichone);
+o_picture_modify (OBJECT *object,
+                  int x,
+                  int y,
+                  int whichone);
 
 void
-o_picture_modify_all (TOPLEVEL *toplevel, OBJECT *object, int x1, int y1, int x2, int y2);
+o_picture_modify_all (OBJECT *object,
+                      int x1,
+                      int y1,
+                      int x2,
+                      int y2);
 
 void
-geda_picture_object_rotate (TOPLEVEL *toplevel, int world_centerx, int world_centery, int angle,OBJECT *object);
+geda_picture_object_rotate (int world_centerx,
+                            int world_centery,
+                            int angle,
+                            OBJECT *object);
 
 void
-geda_picture_object_mirror (TOPLEVEL *toplevel, int world_centerx, int world_centery, OBJECT *object);
+geda_picture_object_mirror (int world_centerx,
+                            int world_centery,
+                            OBJECT *object);
 
 void
 geda_picture_object_translate (GedaObject *object, int dx, int dy);
 
 OBJECT*
-o_picture_copy(TOPLEVEL *toplevel, OBJECT *o_current) G_GNUC_WARN_UNUSED_RESULT;
+o_picture_copy (OBJECT *o_current) G_GNUC_WARN_UNUSED_RESULT;
 
 gboolean
 o_picture_is_embedded (const OBJECT *object);
 
-GdkPixbuf *o_picture_get_pixbuf (TOPLEVEL *toplevel, OBJECT *object) G_GNUC_WARN_UNUSED_RESULT;
-
-const char*
-o_picture_get_data (TOPLEVEL *toplevel, OBJECT *object, size_t *len);
+GdkPixbuf*
+o_picture_get_pixbuf (OBJECT *object) G_GNUC_WARN_UNUSED_RESULT;
 
 gboolean
-o_picture_set_from_buffer (TOPLEVEL *toplevel, OBJECT *object,
-                                    const gchar *filename, const gchar *data,
-                                    size_t len, GError **error);
+o_picture_set_from_buffer (OBJECT *object,
+                           const gchar *filename,
+                           const gchar *data,
+                           size_t len,
+                           GError **error);
 
 gboolean
-o_picture_set_from_file (TOPLEVEL *toplevel, OBJECT *object,
-                                  const gchar *filename, GError **error);
+o_picture_set_from_file (OBJECT *object,
+                         const gchar *filename,
+                         GError **error);
 const gchar*
 o_picture_get_filename (const GedaObject *object);
 
 GdkPixbuf*
-o_picture_get_fallback_pixbuf (TOPLEVEL *toplevel) G_GNUC_WARN_UNUSED_RESULT;
+o_picture_get_fallback_pixbuf () G_GNUC_WARN_UNUSED_RESULT;
 
 OBJECT*
-o_picture_read(TOPLEVEL *toplevel, const char *first_line, TextBuffer *tb, unsigned int release_ver, unsigned int fileformat_ver, GError **err);
+o_picture_read (const char *first_line,
+                TextBuffer *tb,
+                unsigned int release_ver,
+                unsigned int fileformat_ver,
+                GError **err);
 
 gchar*
 geda_picture_object_to_buffer (const GedaObject *object);
@@ -95,9 +118,9 @@ gboolean
 geda_picture_object_get_position (const GedaObject *object, gint *x, gint *y);
 
 void
-o_picture_embed(TOPLEVEL *toplevel, OBJECT *object);
+o_picture_embed (OBJECT *object);
 
 void
-o_picture_unembed(TOPLEVEL *toplevel, OBJECT *object);
+o_picture_unembed (OBJECT *object);
 
 G_END_DECLS
diff --git a/liblepton/include/liblepton/geda_pin_object.h b/liblepton/include/liblepton/geda_pin_object.h
index 25079ebca..f2e2b03db 100644
--- a/liblepton/include/liblepton/geda_pin_object.h
+++ b/liblepton/include/liblepton/geda_pin_object.h
@@ -27,8 +27,7 @@ G_BEGIN_DECLS
 /* construction, destruction */
 
 OBJECT*
-geda_pin_object_new (TOPLEVEL *toplevel,
-                     int color,
+geda_pin_object_new (int color,
                      int x1,
                      int y1,
                      int x2,
@@ -37,13 +36,12 @@ geda_pin_object_new (TOPLEVEL *toplevel,
                      int whichend);
 
 OBJECT*
-geda_pin_object_copy (TOPLEVEL *toplevel, OBJECT *o_current);
+geda_pin_object_copy (OBJECT *o_current);
 
 /* methods */
 
 void
-geda_pin_object_calculate_bounds (TOPLEVEL *toplevel,
-                                  const OBJECT *object,
+geda_pin_object_calculate_bounds (const OBJECT *object,
                                   GedaBounds *bounds);
 
 gboolean
@@ -65,27 +63,25 @@ gint
 geda_pin_object_get_y1 (const GedaObject *object);
 
 void
-geda_pin_object_mirror (TOPLEVEL *toplevel,
-                        int world_centerx,
+geda_pin_object_mirror (int world_centerx,
                         int world_centery,
                         OBJECT *object);
 
 void
-geda_pin_object_modify (TOPLEVEL *toplevel,
-                        OBJECT *object,
+geda_pin_object_modify (OBJECT *object,
                         int x,
                         int y,
                         int whichone);
 
 void
-geda_pin_object_rotate (TOPLEVEL *toplevel,
-                        int world_centerx,
+geda_pin_object_rotate (int world_centerx,
                         int world_centery,
                         int angle,
                         OBJECT *object);
 
 void
-geda_pin_object_set_type (TOPLEVEL *toplevel, OBJECT *o_current, int pin_type);
+geda_pin_object_set_type (OBJECT *o_current,
+                          int pin_type);
 
 void
 geda_pin_object_set_x0 (GedaObject *object, gint x);
@@ -111,8 +107,7 @@ geda_pin_object_update_whichend (TOPLEVEL *toplevel,
                                  int num_pins);
 
 OBJECT*
-o_pin_read (TOPLEVEL *toplevel,
-            const char buf[],
+o_pin_read (const char buf[],
             unsigned int release_ver,
             unsigned int fileformat_ver,
             GError **err);
diff --git a/liblepton/include/liblepton/geda_text_object.h b/liblepton/include/liblepton/geda_text_object.h
index 5e8b3af3e..907967ec1 100644
--- a/liblepton/include/liblepton/geda_text_object.h
+++ b/liblepton/include/liblepton/geda_text_object.h
@@ -30,8 +30,7 @@ G_BEGIN_DECLS
 /* construction, destruction */
 
 GedaObject*
-geda_text_object_new (TOPLEVEL *toplevel,
-                      gint color,
+geda_text_object_new (gint color,
                       gint x,
                       gint y,
                       gint alignment,
@@ -42,7 +41,7 @@ geda_text_object_new (TOPLEVEL *toplevel,
                       gint show_name_value);
 
 GedaObject*
-geda_text_object_copy (TOPLEVEL *toplevel, const GedaObject *object);
+geda_text_object_copy (const GedaObject *object);
 
 /* methods */
 
@@ -76,14 +75,12 @@ gint
 geda_text_object_get_y (const GedaObject *object);
 
 void
-geda_text_object_mirror (TOPLEVEL *toplevel,
-                         int world_centerx,
+geda_text_object_mirror (int world_centerx,
                          int world_centery,
                          OBJECT *object);
 
 void
-geda_text_object_rotate (TOPLEVEL *toplevel,
-                         int world_centerx,
+geda_text_object_rotate (int world_centerx,
                          int world_centery,
                          int angle,
                          OBJECT *object);
@@ -119,18 +116,18 @@ geda_text_object_translate (GedaObject *object, int dx, int dy);
 /* older methods, need renaming */
 
 void
-o_text_recreate (TOPLEVEL *toplevel, OBJECT *o_current);
+o_text_recreate (OBJECT *o_current);
 
 void
-o_text_set_string (TOPLEVEL *toplevel, OBJECT *obj, const gchar *new_string);
+o_text_set_string (OBJECT *obj,
+                   const gchar *new_string);
 
 void
 o_text_set_rendered_bounds_func (TOPLEVEL *toplevel,
                                  void *user_data);
 
 OBJECT*
-o_text_read (TOPLEVEL *toplevel,
-             const char *first_line,
+o_text_read (const char *first_line,
              TextBuffer *tb,
              unsigned int release_ver,
              unsigned int fileformat_ver,
diff --git a/liblepton/include/liblepton/geda_undo.h b/liblepton/include/liblepton/geda_undo.h
index 6019a87dd..1f7c246e9 100644
--- a/liblepton/include/liblepton/geda_undo.h
+++ b/liblepton/include/liblepton/geda_undo.h
@@ -64,13 +64,10 @@ void
 s_undo_print_all (UNDO *head);
 
 void
-s_undo_destroy_all (TOPLEVEL *toplevel, UNDO *head);
+s_undo_destroy_all (UNDO *head);
 
 void
-s_undo_remove (TOPLEVEL *toplevel, UNDO *head, UNDO *u_tos);
-
-void
-s_undo_remove_rest (TOPLEVEL *toplevel, UNDO *head);
+s_undo_remove_rest (UNDO *head);
 
 int
 s_undo_levels (UNDO *head);
@@ -79,6 +76,6 @@ void
 s_undo_init (PAGE *p_current);
 
 void
-s_undo_free_all (TOPLEVEL *toplevel, PAGE *p_current);
+s_undo_free_all (PAGE *p_current);
 
 G_END_DECLS
diff --git a/liblepton/include/liblepton/prototype.h b/liblepton/include/liblepton/prototype.h
index 02c18f5b7..9d58e031e 100644
--- a/liblepton/include/liblepton/prototype.h
+++ b/liblepton/include/liblepton/prototype.h
@@ -1,7 +1,11 @@
 G_BEGIN_DECLS
 
 /* a_basic.c */
-int o_save (TOPLEVEL *toplevel, const GList *object_list, const char *filename, GError **err);
+int
+o_save (const GList *object_list,
+        const char *filename,
+        GError **err);
+
 GList *o_read_buffer(TOPLEVEL *toplevel, GList *object_list, char *buffer, const int size, const char *name, GError **err);
 GList *o_read(TOPLEVEL *toplevel, GList *object_list, char *filename, GError **err);
 
@@ -12,7 +16,12 @@ int f_open(TOPLEVEL *toplevel, PAGE *page, const gchar *filename, GError **err);
 int f_open_flags(TOPLEVEL *toplevel, PAGE *page, const gchar *filename,
                  const gint flags, GError **err);
 void f_close(TOPLEVEL *toplevel);
-int f_save(TOPLEVEL *toplevel, PAGE *page, const char *filename, GError **error);
+
+int
+f_save (PAGE *page,
+        const char *filename,
+        GError **error);
+
 gchar *f_normalize_filename (const gchar *filename, GError **error) G_GNUC_WARN_UNUSED_RESULT;
 char *follow_symlinks (const gchar *filename, GError **error);
 
@@ -51,13 +60,29 @@ void m_polygon_append_bezier(GArray *points, GedaBezier *bezier, int segments);
 void m_polygon_append_point(GArray *points, int x, int y);
 
 /* o_attrib.c */
-void o_attrib_add(TOPLEVEL *toplevel, OBJECT *object, OBJECT *item);
-gboolean o_attrib_is_attached (TOPLEVEL *toplevel, OBJECT *attrib, OBJECT *object);
-void o_attrib_attach(TOPLEVEL *toplevel, OBJECT *attrib, OBJECT *object, int set_color);
-void o_attrib_attach_list(TOPLEVEL *toplevel, GList *attr_list, OBJECT *object, int set_color);
-void o_attrib_detach_all(TOPLEVEL *toplevel, OBJECT *object);
+void
+o_attrib_add (OBJECT *object,
+              OBJECT *item);
+
+void
+o_attrib_attach (OBJECT *attrib,
+                 OBJECT *object,
+                 int set_color);
+
+void
+o_attrib_attach_list (GList *attr_list,
+                      OBJECT *object,
+                      int set_color);
+
+void
+o_attrib_detach_all (OBJECT *object);
+
 void o_attrib_print(GList *attributes);
-void o_attrib_remove(TOPLEVEL *toplevel, GList **list, OBJECT *remove);
+
+void
+o_attrib_remove (GList **list,
+                 OBJECT *remove);
+
 gboolean o_attrib_string_get_name_value (const gchar *string, gchar **name_ptr, gchar **value_ptr);
 gboolean o_attrib_get_name_value (const OBJECT *attrib, gchar **name_ptr, gchar **value_ptr);
 const char *o_attrib_get_name (const OBJECT *attrib);
@@ -76,9 +101,16 @@ void o_unembed (OBJECT *o_current);
 
 /* o_selection.c */
 SELECTION *o_selection_new( void );
-void o_selection_add(TOPLEVEL *toplevel, SELECTION *selection, OBJECT *o_selected);
+
+void
+o_selection_add (SELECTION *selection,
+                 OBJECT *o_selected);
+
 void o_selection_print_all(const SELECTION *selection);
-void o_selection_remove(TOPLEVEL *toplevel, SELECTION *selection, OBJECT *o_selected);
+
+void
+o_selection_remove (SELECTION *selection,
+                    OBJECT *o_selected);
 
 /* s_attrib.c */
 int s_attrib_add_entry(char *new_attrib);
@@ -118,7 +150,7 @@ gchar *s_clib_symbol_get_data_by_name (const gchar *name);
 GList *s_toplevel_get_symbols (const TOPLEVEL *toplevel);
 
 /* s_conn.c */
-void s_conn_remove_object_connections (TOPLEVEL *toplevel, OBJECT *to_remove);
+void s_conn_remove_object_connections (OBJECT *to_remove);
 void s_conn_update_object (PAGE* page, OBJECT *object);
 int s_conn_net_search(OBJECT* new_net, int whichone, GList * conn_list);
 GList *s_conn_return_others(GList *input_list, OBJECT *object);
@@ -148,7 +180,9 @@ void s_menu_init(void);
 
 /* s_slot.c */
 char *s_slot_search_slot(OBJECT *object, OBJECT **return_found);
-void s_slot_update_object(TOPLEVEL *toplevel, OBJECT *object);
+
+void
+s_slot_update_object (OBJECT *object);
 
 /* s_textbuffer.c */
 TextBuffer *s_textbuffer_new (const gchar *data, const gint size, const gchar* name);
diff --git a/liblepton/include/prototype_priv.h b/liblepton/include/prototype_priv.h
index bb81677bd..521df51d6 100644
--- a/liblepton/include/prototype_priv.h
+++ b/liblepton/include/prototype_priv.h
@@ -21,12 +21,12 @@ GList *o_read_attribs(TOPLEVEL *toplevel,
 OBJECT *o_attrib_find_attrib_by_name (const GList *list, const char *name, int count);
 
 /* geda_object.c */
-void o_emit_pre_change_notify(TOPLEVEL *toplevel, OBJECT *object);
-void o_emit_change_notify(TOPLEVEL *toplevel, OBJECT *object);
+void o_emit_pre_change_notify (OBJECT *object);
+void o_emit_change_notify (OBJECT *object);
 
 /* o_selection.c */
-void o_selection_select(TOPLEVEL *toplevel, OBJECT *object);
-void o_selection_unselect(TOPLEVEL *toplevel, OBJECT *object);
+void o_selection_select (OBJECT *object);
+void o_selection_unselect (OBJECT *object);
 
 /* s_clib.c */
 void s_clib_init (void);
@@ -34,7 +34,7 @@ void s_clib_init (void);
 /* s_conn.c */
 CONN *s_conn_return_new(OBJECT *other_object, int type, int x, int y, int whichone, int other_whichone);
 int s_conn_uniq(GList *conn_list, CONN *input_conn);
-int s_conn_remove_other(TOPLEVEL *toplevel, OBJECT *other_object, OBJECT *to_remove);
+int s_conn_remove_other (OBJECT *other_object, OBJECT *to_remove);
 OBJECT *s_conn_check_midpoint(OBJECT *o_current, int x, int y);
 void s_conn_print(GList *conn_list);
 void s_conn_add_object(PAGE *page, OBJECT *object);
diff --git a/liblepton/src/a_basic.c b/liblepton/src/a_basic.c
index c212d6962..742c36a91 100644
--- a/liblepton/src/a_basic.c
+++ b/liblepton/src/a_basic.c
@@ -38,14 +38,15 @@
  *  \bug g_access introduces a race condition in certain cases, but
  *  solves bug #698565 in the normal use-case
  *
- *  \param [in] toplevel    The current TOPLEVEL.
  *  \param [in] object_list The head of a GList of OBJECTs to save.
  *  \param [in] filename    The filename to save the data to.
  *  \param [in,out] err     #GError structure for error reporting.
  *  \return 1 on success, 0 on failure.
  */
-int o_save (TOPLEVEL *toplevel, const GList *object_list,
-            const char *filename, GError **err)
+int
+o_save (const GList *object_list,
+        const char *filename,
+        GError **err)
 {
   char *buffer;
 
@@ -141,39 +142,39 @@ GList *o_read_buffer (TOPLEVEL *toplevel, GList *object_list,
     switch (objtype) {
 
       case(OBJ_LINE):
-        if ((new_obj = o_line_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_line_read (line, release_ver, fileformat_ver, err)) == NULL)
           goto error;
         new_object_list = g_list_prepend (new_object_list, new_obj);
         break;
 
 
       case(OBJ_NET):
-        if ((new_obj = o_net_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_net_read (line, release_ver, fileformat_ver, err)) == NULL)
           goto error;
         new_object_list = g_list_prepend (new_object_list, new_obj);
         break;
 
       case(OBJ_BUS):
-        if ((new_obj = o_bus_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_bus_read (line, release_ver, fileformat_ver, err)) == NULL)
           goto error;
         new_object_list = g_list_prepend (new_object_list, new_obj);
         break;
 
       case(OBJ_BOX):
-        if ((new_obj = o_box_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_box_read (line, release_ver, fileformat_ver, err)) == NULL)
           goto error;
         new_object_list = g_list_prepend (new_object_list, new_obj);
         break;
 
       case(OBJ_PICTURE):
-        new_obj = o_picture_read (toplevel, line, tb, release_ver, fileformat_ver, err);
+        new_obj = o_picture_read (line, tb, release_ver, fileformat_ver, err);
         if (new_obj == NULL)
           goto error;
         new_object_list = g_list_prepend (new_object_list, new_obj);
         break;
 
       case(OBJ_CIRCLE):
-        if ((new_obj = o_circle_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_circle_read (line, release_ver, fileformat_ver, err)) == NULL)
 	  goto error;
         new_object_list = g_list_prepend (new_object_list, new_obj);
         break;
@@ -189,28 +190,28 @@ GList *o_read_buffer (TOPLEVEL *toplevel, GList *object_list,
         break;
 
       case(OBJ_TEXT):
-        new_obj = o_text_read (toplevel, line, tb, release_ver, fileformat_ver, err);
+        new_obj = o_text_read (line, tb, release_ver, fileformat_ver, err);
         if (new_obj == NULL)
           goto error;
         new_object_list = g_list_prepend (new_object_list, new_obj);
         break;
 
       case(OBJ_PATH):
-        new_obj = o_path_read (toplevel, line, tb, release_ver, fileformat_ver, err);
+        new_obj = o_path_read (line, tb, release_ver, fileformat_ver, err);
         if (new_obj == NULL)
           goto error;
         new_object_list = g_list_prepend (new_object_list, new_obj);
         break;
 
       case(OBJ_PIN):
-        if ((new_obj = o_pin_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_pin_read (line, release_ver, fileformat_ver, err)) == NULL)
           goto error;
         new_object_list = g_list_prepend (new_object_list, new_obj);
         found_pin++;
         break;
 
       case(OBJ_ARC):
-        if ((new_obj = o_arc_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_arc_read (line, release_ver, fileformat_ver, err)) == NULL)
           goto error;
         new_object_list = g_list_prepend (new_object_list, new_obj);
         break;
@@ -238,7 +239,7 @@ GList *o_read_buffer (TOPLEVEL *toplevel, GList *object_list,
           if (new_obj != NULL &&
               (new_obj->type == OBJ_COMPONENT ||
                new_obj->type == OBJ_PLACEHOLDER)) {
-            s_slot_update_object (toplevel, new_obj);
+            s_slot_update_object (new_obj);
           }
           new_obj = NULL;
         }
@@ -360,7 +361,7 @@ GList *o_read_buffer (TOPLEVEL *toplevel, GList *object_list,
   return(object_list);
 
 error:
-  geda_object_list_delete (toplevel, new_object_list);
+  geda_object_list_delete (new_object_list);
 
   unsigned long linenum = s_textbuffer_linenum (tb);
   g_prefix_error (err, "Parsing stopped at line %lu:\n", linenum);
diff --git a/liblepton/src/f_basic.c b/liblepton/src/f_basic.c
index d4e4e5610..f9cb2c5ad 100644
--- a/liblepton/src/f_basic.c
+++ b/liblepton/src/f_basic.c
@@ -285,11 +285,11 @@ int f_open_flags(TOPLEVEL *toplevel, PAGE *page,
    * the RC file, it's time to read in the file. */
   if (load_backup_file == 1) {
     /* Load the backup file */
-    s_page_append_list (toplevel, page,
+    s_page_append_list (page,
                         o_read (toplevel, NULL, backup_filename, &tmp_err));
   } else {
     /* Load the original file */
-    s_page_append_list (toplevel, page,
+    s_page_append_list (page,
                         o_read (toplevel, NULL, full_filename, &tmp_err));
   }
 
@@ -344,13 +344,15 @@ void f_close(TOPLEVEL *toplevel)
  *  \bug g_access introduces a race condition in certain cases, but
  *  solves bug #698565 in the normal use-case
  *
- *  \param [in,out] toplevel  The TOPLEVEL object containing the schematic.
  *  \param [in]      filename  The file name to save the schematic to.
  *  \param [in,out] err       #GError structure for error reporting, or
  *                            NULL to disable error reporting
  *  \return 1 on success, 0 on failure.
  */
-int f_save(TOPLEVEL *toplevel, PAGE *page, const char *filename, GError **err)
+int
+f_save (PAGE *page,
+        const char *filename,
+        GError **err)
 {
   gchar *backup_filename;
   gchar *real_filename;
@@ -452,7 +454,7 @@ int f_save(TOPLEVEL *toplevel, PAGE *page, const char *filename, GError **err)
   g_free (dirname);
   g_free (only_filename);
   
-  if (o_save (toplevel, s_page_objects (page), real_filename, &tmp_err)) {
+  if (o_save (s_page_objects (page), real_filename, &tmp_err)) {
 
     page->saved_since_first_loaded = 1;
 
diff --git a/liblepton/src/geda_arc_object.c b/liblepton/src/geda_arc_object.c
index c094a1b97..8f394c5ce 100644
--- a/liblepton/src/geda_arc_object.c
+++ b/liblepton/src/geda_arc_object.c
@@ -32,8 +32,7 @@
 /*! \brief create a new arc object
  *
  *  The line and fill type of the created arc are set to default.
-*
- *  \param [in] toplevel The TOPLEVEL object.
+ *
  *  \param [in] color the color index of the arc
  *  \param [in] center_x the x coordinate of the center
  *  \param [in] center_y the y coordinate of the center
@@ -43,8 +42,7 @@
  *  \return the new arc object
  */
 GedaObject*
-geda_arc_object_new (TOPLEVEL *toplevel,
-                     gint color,
+geda_arc_object_new (gint color,
                      gint center_x,
                      gint center_y,
                      gint radius,
@@ -84,28 +82,26 @@ geda_arc_object_new (TOPLEVEL *toplevel,
   new_node->arc->sweep_angle = sweep_angle;
 
   /* Default init */
-  o_set_line_options (toplevel,
-                      new_node,
+  o_set_line_options (new_node,
                       DEFAULT_OBJECT_END,
                       TYPE_SOLID,
                       LINE_WIDTH,
                       -1,
                       -1);
 
-  o_set_fill_options(toplevel, new_node,
-                     FILLING_HOLLOW, -1, -1, -1, -1, -1);
+  o_set_fill_options (new_node,
+                      FILLING_HOLLOW, -1, -1, -1, -1, -1);
 
   return new_node;
 }
 
 /*! \brief create a copy of an existing arc object
  *
- *  \param [in] toplevel The TOPLEVEL object
  *  \param [in] object the arc object to copy
  *  \return The new arc object
  */
 GedaObject*
-geda_arc_object_copy (TOPLEVEL *toplevel, const GedaObject *object)
+geda_arc_object_copy (const GedaObject *object)
 {
   GedaObject *new_object;
 
@@ -113,24 +109,21 @@ geda_arc_object_copy (TOPLEVEL *toplevel, const GedaObject *object)
   g_return_val_if_fail (object->arc != NULL, NULL);
   g_return_val_if_fail (object->type == OBJ_ARC, NULL);
 
-  new_object = geda_arc_object_new (toplevel,
-                                    object->color,
+  new_object = geda_arc_object_new (object->color,
                                     object->arc->x,
                                     object->arc->y,
                                     object->arc->radius,
                                     object->arc->start_angle,
                                     object->arc->sweep_angle);
 
-  o_set_line_options (toplevel,
-                      new_object,
+  o_set_line_options (new_object,
                       object->line_end,
                       object->line_type,
                       object->line_width,
                       object->line_length,
                       object->line_space);
 
-  o_set_fill_options (toplevel,
-                      new_object,
+  o_set_fill_options (new_object,
                       FILLING_HOLLOW,
                       -1,
                       -1,
@@ -296,31 +289,38 @@ geda_arc_object_set_sweep_angle (GedaObject *object, gint angle)
  *  This function modifies the internal values of the arc object
  *  *object according to the whichone parameter.
  *
- *  The new values are given by <B>x</B> and/or <B>y</B>. Their meaning depends on the value of whichone.
+ *  The new values are given by <B>x</B> and/or <B>y</B>. Their
+ *  meaning depends on the value of whichone.
  *
- *  If <B>whichone</B> is equal to #ARC_CENTER, the (<B>x</B>,<B>y</B>) point is taken as the new center
- *  of the arc in world unit.
+ *  If <B>whichone</B> is equal to #ARC_CENTER, the
+ *  (<B>x</B>,<B>y</B>) point is taken as the new center of the
+ *  arc in world unit.
  *
- *  If <B>whichone</B> is equal to #ARC_RADIUS, the <B>x</B> parameter is taken to be the radius
- *  of the arc in world unit. The <B>y</B> parameter is ignored.
+ *  If <B>whichone</B> is equal to #ARC_RADIUS, the <B>x</B>
+ *  parameter is taken to be the radius of the arc in world
+ *  unit. The <B>y</B> parameter is ignored.
  *
- *  If <B>whichone</B> is equal to #ARC_START_ANGLE, the <B>x</B> parameter is the starting angle of the arc.
- *  <B>x</B> is in degrees. <B>y</B> is ignored.
+ *  If <B>whichone</B> is equal to #ARC_START_ANGLE, the <B>x</B>
+ *  parameter is the starting angle of the arc.  <B>x</B> is in
+ *  degrees. <B>y</B> is ignored.
  *
- *  If <B>whichone</B> is equal to #ARC_SWEEP_ANGLE, the <B>x</B> parameter is the ending angle of the arc.
- *  <B>x</B> is in degrees. <B>y</B> is ignored.
+ *  If <B>whichone</B> is equal to #ARC_SWEEP_ANGLE, the <B>x</B>
+ *  parameter is the ending angle of the arc.  <B>x</B> is in
+ *  degrees. <B>y</B> is ignored.
  *
- *  \param [in]     toplevel  The TOPLEVEL object.
  *  \param [in,out] object
  *  \param [in]     x
  *  \param [in]     y
  *  \param [in]     whichone
  */
 void
-geda_arc_object_modify (TOPLEVEL *toplevel, OBJECT *object, int x, int y, int whichone)
+geda_arc_object_modify (OBJECT *object,
+                        int x,
+                        int y,
+                        int whichone)
 {
 
-	o_emit_pre_change_notify (toplevel, object);
+	o_emit_pre_change_notify (object);
 
 	switch(whichone) {
 		case ARC_CENTER:
@@ -349,7 +349,7 @@ geda_arc_object_modify (TOPLEVEL *toplevel, OBJECT *object, int x, int y, int wh
 	}
 
 	/* update the screen coords and the bounding box */
-	o_emit_change_notify (toplevel, object);
+	o_emit_change_notify (object);
 }
 
 /*! \brief
@@ -372,14 +372,16 @@ geda_arc_object_modify (TOPLEVEL *toplevel, OBJECT *object, int x, int y, int wh
  *
  *  A negative or null radius is not allowed.
  *
- *  \param [in] toplevel    The TOPLEVEL object.
  *  \param [in] buf
  *  \param [in] release_ver
  *  \param [in] fileformat_ver
  *  \return The ARC OBJECT that was created, or NULL on error.
  */
-OBJECT *o_arc_read (TOPLEVEL *toplevel, const char buf[],
-           unsigned int release_ver, unsigned int fileformat_ver, GError **err)
+OBJECT
+*o_arc_read (const char buf[],
+             unsigned int release_ver,
+             unsigned int fileformat_ver,
+             GError **err)
 {
   OBJECT *new_obj;
   char type;
@@ -433,24 +435,21 @@ OBJECT *o_arc_read (TOPLEVEL *toplevel, const char buf[],
   }
 
   /* Allocation and initialization */
-  new_obj = geda_arc_object_new (toplevel,
-                                 color,
+  new_obj = geda_arc_object_new (color,
                                  x1,
                                  y1,
                                  radius,
                                  start_angle,
                                  sweep_angle);
 
-  o_set_line_options(toplevel,
-                     new_obj,
-                     (OBJECT_END) arc_end,
-                     (OBJECT_TYPE) arc_type,
-                     arc_width,
-                     arc_length,
-                     arc_space);
-  o_set_fill_options(toplevel, new_obj,
-                     FILLING_HOLLOW, -1, -1, -1,
-                     -1, -1);
+  o_set_line_options (new_obj,
+                      (OBJECT_END) arc_end,
+                      (OBJECT_TYPE) arc_type,
+                      arc_width,
+                      arc_length,
+                      arc_space);
+  o_set_fill_options (new_obj,
+                      FILLING_HOLLOW, -1, -1, -1, -1, -1);
 
   return new_obj;
 }
@@ -526,15 +525,16 @@ geda_arc_object_translate (GedaObject *object, int dx, int dy)
  *
  *  <B>world_centerx</B> and <B>world_centery</B> are in world units, <B>angle</B> is in degrees.
  *
- *  \param [in] toplevel      The TOPLEVEL object.
  *  \param [in] world_centerx
  *  \param [in] world_centery
  *  \param [in] angle
  *  \param [in] object
  */
-void geda_arc_object_rotate (TOPLEVEL *toplevel,
-			int world_centerx, int world_centery, int angle,
-			OBJECT *object)
+void
+geda_arc_object_rotate (int world_centerx,
+                        int world_centery,
+                        int angle,
+                        OBJECT *object)
 {
   int x, y, newx, newy;
 
@@ -576,13 +576,13 @@ void geda_arc_object_rotate (TOPLEVEL *toplevel,
  *
  *  The arc is finally back translated to its previous location on the page.
  *
- *  \param [in] toplevel      The TOPLEVEL object.
  *  \param [in] world_centerx
  *  \param [in] world_centery
  *  \param [in] object
  */
-void geda_arc_object_mirror (TOPLEVEL *toplevel,
-			int world_centerx, int world_centery,
+void
+geda_arc_object_mirror (int world_centerx,
+                        int world_centery,
 			OBJECT *object)
 {
   g_return_if_fail (object != NULL);
@@ -617,7 +617,6 @@ void geda_arc_object_mirror (TOPLEVEL *toplevel,
  *  They forms a first rectangle but (depending on the start angle and the
  *  sweep of the arc) not the right.
  *
- *  \param [in]  toplevel  The TOPLEVEL object.
  *  \param [in]  object
  *  \param [out] left
  *  \param [out] top
@@ -625,8 +624,7 @@ void geda_arc_object_mirror (TOPLEVEL *toplevel,
  *  \param [out] bottom
  */
 void
-geda_arc_object_calculate_bounds (TOPLEVEL *toplevel,
-                                  const OBJECT *object,
+geda_arc_object_calculate_bounds (const OBJECT *object,
                                   gint *left,
                                   gint *top,
                                   gint *right,
diff --git a/liblepton/src/geda_box_object.c b/liblepton/src/geda_box_object.c
index 4aab1d579..e52fc4407 100644
--- a/liblepton/src/geda_box_object.c
+++ b/liblepton/src/geda_box_object.c
@@ -44,7 +44,6 @@
  *  line type with a width of 0, and no filling. It can be changed after
  *  with the #o_set_line_options() and #o_set_fill_options().
  *
- *  \param [in]     toplevel     The TOPLEVEL object.
  *  \param [in]     type         Box type.
  *  \param [in]     color        Box border color.
  *  \param [in]     x1           Upper x coordinate.
@@ -54,8 +53,12 @@
  *  \return The new OBJECT
  */
 OBJECT*
-geda_box_object_new (TOPLEVEL *toplevel, char type, int color,
-                     int x1, int y1, int x2, int y2)
+geda_box_object_new (char type,
+                     int color,
+                     int x1,
+                     int y1,
+                     int x2,
+                     int y2)
 {
   OBJECT *new_node;
   BOX *box;
@@ -74,16 +77,15 @@ geda_box_object_new (TOPLEVEL *toplevel, char type, int color,
   box->lower_y = y2;
 
   /* line type and filling initialized to default */
-  o_set_line_options (toplevel,
-                      new_node,
+  o_set_line_options (new_node,
                       DEFAULT_OBJECT_END,
                       TYPE_SOLID,
                       LINE_WIDTH,
                       -1,
                       -1);
 
-  o_set_fill_options(toplevel, new_node,
-		     FILLING_HOLLOW, -1, -1, -1, -1, -1);
+  o_set_fill_options (new_node,
+                      FILLING_HOLLOW, -1, -1, -1, -1, -1);
 
   return new_node;
 }
@@ -93,18 +95,17 @@ geda_box_object_new (TOPLEVEL *toplevel, char type, int color,
  *  The function #geda_box_object_copy() creates a verbatim copy of the object
  *  pointed by <B>o_current</B> describing a box.
  *
- *  \param [in]      toplevel  The TOPLEVEL object.
  *  \param [in]      o_current  BOX OBJECT to copy.
  *  \return The new OBJECT
  */
 OBJECT*
-geda_box_object_copy(TOPLEVEL *toplevel, OBJECT *o_current)
+geda_box_object_copy (OBJECT *o_current)
 {
   OBJECT *new_obj;
 
   /* A new box object is created with #geda_box_object_new().
    * Values for its fields are default and need to be modified. */
-  new_obj = geda_box_object_new (toplevel, OBJ_BOX, o_current->color, 0, 0, 0, 0);
+  new_obj = geda_box_object_new (OBJ_BOX, o_current->color, 0, 0, 0, 0);
 
   /*
    * The dimensions of the new box are set with the ones of the original box.
@@ -116,13 +117,13 @@ geda_box_object_copy(TOPLEVEL *toplevel, OBJECT *o_current)
   new_obj->box->lower_x = o_current->box->lower_x;
   new_obj->box->lower_y = o_current->box->lower_y;
 
-  o_set_line_options(toplevel, new_obj, o_current->line_end,
-		     o_current->line_type, o_current->line_width,
-		     o_current->line_length, o_current->line_space);
-  o_set_fill_options(toplevel, new_obj,
-		     o_current->fill_type, o_current->fill_width,
-		     o_current->fill_pitch1, o_current->fill_angle1,
-		     o_current->fill_pitch2, o_current->fill_angle2);
+  o_set_line_options (new_obj, o_current->line_end,
+                      o_current->line_type, o_current->line_width,
+                      o_current->line_length, o_current->line_space);
+  o_set_fill_options (new_obj,
+                      o_current->fill_type, o_current->fill_width,
+                      o_current->fill_pitch1, o_current->fill_angle1,
+                      o_current->fill_pitch2, o_current->fill_angle2);
 
   return new_obj;
 }
@@ -133,7 +134,6 @@ geda_box_object_copy(TOPLEVEL *toplevel, OBJECT *o_current)
  * the box to the rectangle enclosed by the points (\a x1, \a y1) and
  * (\a x2, \a y2).
  *
- * \param [in]     toplevel current #TOPLEVEL.
  * \param [in,out] object   box #OBJECT to be modified.
  * \param [in]     x1       x coordinate of first corner of box.
  * \param [in]     y1       y coordinate of first corner of box.
@@ -141,10 +141,13 @@ geda_box_object_copy(TOPLEVEL *toplevel, OBJECT *o_current)
  * \param [in]     y2       y coordinate of second corner of box,
  */
 void
-geda_box_object_modify_all (TOPLEVEL *toplevel, OBJECT *object,
-                            int x1, int y1, int x2, int y2)
+geda_box_object_modify_all (OBJECT *object,
+                            int x1,
+                            int y1,
+                            int x2,
+                            int y2)
 {
-  o_emit_pre_change_notify (toplevel, object);
+  o_emit_pre_change_notify (object);
 
   object->box->lower_x = (x1 > x2) ? x1 : x2;
   object->box->lower_y = (y1 > y2) ? y2 : y1;
@@ -152,7 +155,7 @@ geda_box_object_modify_all (TOPLEVEL *toplevel, OBJECT *object,
   object->box->upper_x = (x1 > x2) ? x2 : x1;
   object->box->upper_y = (y1 > y2) ? y1 : y2;
 
-  o_emit_change_notify (toplevel, object);
+  o_emit_change_notify (object);
 }
 
 /*! \brief Modify a BOX OBJECT's coordinates.
@@ -164,7 +167,6 @@ geda_box_object_modify_all (TOPLEVEL *toplevel, OBJECT *object,
  *  The coordinates of the corner is modified in the world coordinate system.
  *  Screen coordinates and boundings are then updated.
  *
- *  \param [in]     toplevel  The TOPLEVEL object.
  *  \param [in,out] object     BOX OBJECT to be modified.
  *  \param [in]     x          x coordinate.
  *  \param [in]     y          y coordinate.
@@ -180,11 +182,14 @@ geda_box_object_modify_all (TOPLEVEL *toplevel, OBJECT *object,
  *  </DL>
  */
 void
-geda_box_object_modify (TOPLEVEL *toplevel, OBJECT *object, int x, int y, int whichone)
+geda_box_object_modify (OBJECT *object,
+                        int x,
+                        int y,
+                        int whichone)
 {
 	int tmp;
 
-	o_emit_pre_change_notify (toplevel, object);
+	o_emit_pre_change_notify (object);
 
 	/* change the position of the selected corner */
 	switch(whichone) {
@@ -225,7 +230,7 @@ geda_box_object_modify (TOPLEVEL *toplevel, OBJECT *object, int x, int y, int wh
 		object->box->lower_y = tmp;
 	}
 
-	o_emit_change_notify (toplevel, object);
+	o_emit_change_notify (object);
 
 }
 
@@ -241,14 +246,16 @@ geda_box_object_modify (TOPLEVEL *toplevel, OBJECT *object, int x, int y, int wh
  *    <DT>*</DT><DD>the file format used for the releases after 2000704.
  *  </DL>
  *
- *  \param [in]     toplevel       The TOPLEVEL object.
  *  \param [in]     buf             Character string with box description.
  *  \param [in]     release_ver     libgeda release version number.
  *  \param [in]     fileformat_ver  libgeda file format version number.
  *  \return The BOX OBJECT that was created, or NULL on error.
  */
-OBJECT *o_box_read (TOPLEVEL *toplevel, const char buf[],
-                    unsigned int release_ver, unsigned int fileformat_ver, GError **err)
+OBJECT*
+o_box_read (const char buf[],
+            unsigned int release_ver,
+            unsigned int fileformat_ver,
+            GError **err)
 {
   OBJECT *new_obj;
   char type;
@@ -338,17 +345,16 @@ OBJECT *o_box_read (TOPLEVEL *toplevel, const char buf[],
   d_y2 = y1;
 
   /* create a new box */
-  new_obj = geda_box_object_new (toplevel, type, color, d_x1, d_y1, d_x2, d_y2);
+  new_obj = geda_box_object_new (type, color, d_x1, d_y1, d_x2, d_y2);
   /* set its line options */
-  o_set_line_options (toplevel,
-                      new_obj,
+  o_set_line_options (new_obj,
                       (OBJECT_END) box_end,
                       (OBJECT_TYPE) box_type,
                       box_width,
                       box_length,
                       box_space);
   /* set its fill options */
-  o_set_fill_options (toplevel, new_obj,
+  o_set_fill_options (new_obj,
                       (OBJECT_FILLING) box_filling,
                       fill_width,
                       pitch1, angle1, pitch2, angle2);
@@ -454,15 +460,16 @@ geda_box_object_translate (GedaObject *object, int dx, int dy)
  *  <B>angle</B> degrees.
  *  The center of rotation is in world unit.
  *
- *  \param [in]      toplevel      The TOPLEVEL object.
  *  \param [in]      world_centerx  Rotation center x coordinate in WORLD units.
  *  \param [in]      world_centery  Rotation center y coordinate in WORLD units.
  *  \param [in]      angle          Rotation angle in degrees (See note below).
  *  \param [in,out]  object         BOX OBJECT to rotate.
  *
  */
-void geda_box_object_rotate (TOPLEVEL *toplevel,
-			int world_centerx, int world_centery, int angle,
+void
+geda_box_object_rotate (int world_centerx,
+                        int world_centery,
+                        int angle,
 			OBJECT *object)
 {
   int newx1, newy1;
@@ -522,13 +529,13 @@ void geda_box_object_rotate (TOPLEVEL *toplevel,
  *  The box is first translated to the origin, then mirrored and finally
  *  translated back at its previous position.
  *
- *  \param [in]     toplevel      The TOPLEVEL object.
  *  \param [in]     world_centerx  Origin x coordinate in WORLD units.
  *  \param [in]     world_centery  Origin y coordinate in WORLD units.
  *  \param [in,out] object         BOX OBJECT to mirror.
  */
-void geda_box_object_mirror (TOPLEVEL *toplevel,
-			int world_centerx, int world_centery,
+void
+geda_box_object_mirror (int world_centerx,
+                        int world_centery,
 			OBJECT *object)
 {
   int newx1, newy1;
@@ -569,7 +576,6 @@ void geda_box_object_mirror (TOPLEVEL *toplevel,
  *  parameters to the boundings of the box object described in <B>*box</B>
  *  in world units.
  *
- *  \param [in]  toplevel  The TOPLEVEL object.
  *  \param [in]  object     BOX OBJECT to read coordinates from.
  *  \param [out] left       Left box coordinate in WORLD units.
  *  \param [out] top        Top box coordinate in WORLD units.
@@ -577,8 +583,7 @@ void geda_box_object_mirror (TOPLEVEL *toplevel,
  *  \param [out] bottom     Bottom box coordinate in WORLD units.
  */
 void
-geda_box_object_calculate_bounds (TOPLEVEL *toplevel,
-                                  const OBJECT *object,
+geda_box_object_calculate_bounds (const OBJECT *object,
                                   GedaBounds *bounds)
 {
   gint expand;
diff --git a/liblepton/src/geda_bus_object.c b/liblepton/src/geda_bus_object.c
index 06a20c400..6b7f9c7d9 100644
--- a/liblepton/src/geda_bus_object.c
+++ b/liblepton/src/geda_bus_object.c
@@ -246,13 +246,11 @@ geda_bus_object_get_position (const GedaObject *object, gint *x, gint *y)
  *
  *  On failure, this function sets the bounds to empty.
  *
- *  \param [in]  toplevel Unused
  *  \param [in]  object   The bus object
  *  \param [out] bounds   The bounds of the bus
  */
 void
-geda_bus_object_calculate_bounds (TOPLEVEL *toplevel,
-                                  const GedaObject *object,
+geda_bus_object_calculate_bounds (const GedaObject *object,
                                   GedaBounds *bounds)
 {
   gint expand;
@@ -275,7 +273,6 @@ geda_bus_object_calculate_bounds (TOPLEVEL *toplevel,
  *  \par Function Description
  *  This function creates and returns a new bus object.
  *
- *  \param [in]     toplevel    The TOPLEVEL object.
  *  \param [in]     color       The color of the bus
  *  \param [in]     x1          x-coord of the first point
  *  \param [in]     y1          y-coord of the first point
@@ -285,8 +282,7 @@ geda_bus_object_calculate_bounds (TOPLEVEL *toplevel,
  *  \return A new bus OBJECT
  */
 GedaObject*
-geda_bus_object_new (TOPLEVEL *toplevel,
-                     gint color,
+geda_bus_object_new (gint color,
                      gint x1,
                      gint y1,
                      gint x2,
@@ -318,15 +314,13 @@ geda_bus_object_new (TOPLEVEL *toplevel,
  *  If the bus object was read successfully, a new bus object is
  *  allocated and appended to the \a object_list.
  *
- *  \param [in] toplevel     The TOPLEVEL object
  *  \param [in] buf          a text buffer (usually a line of a schematic file)
  *  \param [in] release_ver  The release number gEDA
  *  \param [in] fileformat_ver a integer value of the file format
  *  \return The object list, or NULL on error.
  */
 GedaObject*
-o_bus_read (TOPLEVEL *toplevel,
-            const char buf[],
+o_bus_read (const char buf[],
             unsigned int release_ver,
             unsigned int fileformat_ver,
             GError **err)
@@ -370,7 +364,7 @@ o_bus_read (TOPLEVEL *toplevel,
     ripper_dir = 0;
   }
 
-  new_obj = geda_bus_object_new (toplevel, color, x1, y1, x2, y2, ripper_dir);
+  new_obj = geda_bus_object_new (color, x1, y1, x2, y2, ripper_dir);
 
   return new_obj;
 }
@@ -426,12 +420,11 @@ geda_bus_object_translate (GedaObject *object, gint dx, gint dy)
  *  \par Function Description
  *  This function creates a copy of the bus object \a o_current.
  *
- *  \param [in] toplevel     The TOPLEVEL object
  *  \param [in] o_current    The object that is copied
  *  \return a new bus object
  */
 GedaObject*
-geda_bus_object_copy (TOPLEVEL *toplevel, const GedaObject *object)
+geda_bus_object_copy (const GedaObject *object)
 {
   GedaObject *new_obj;
 
@@ -443,8 +436,7 @@ geda_bus_object_copy (TOPLEVEL *toplevel, const GedaObject *object)
   /* still doesn't work... you need to pass in the new values */
   /* or don't update and update later */
   /* I think for now I'll disable the update and manually update */
-  new_obj = geda_bus_object_new (toplevel,
-                                 object->color,
+  new_obj = geda_bus_object_new (object->color,
                                  object->line->x[0],
                                  object->line->y[0],
                                  object->line->x[1],
@@ -459,7 +451,6 @@ geda_bus_object_copy (TOPLEVEL *toplevel, const GedaObject *object)
  *  This function rotates a bus \a object around the point
  *  (\a world_centerx, \a world_centery).
  *
- *  \param [in]     toplevel      The TOPLEVEL object
  *  \param [in]     world_centerx x-coord of the rotation center
  *  \param [in]     world_centery y-coord of the rotation center
  *  \param [in]     angle         The angle to rotate the bus object
@@ -467,8 +458,7 @@ geda_bus_object_copy (TOPLEVEL *toplevel, const GedaObject *object)
  *  \note only steps of 90 degrees are allowed for the \a angle
  */
 void
-geda_bus_object_rotate (TOPLEVEL *toplevel,
-                        gint world_centerx,
+geda_bus_object_rotate (gint world_centerx,
                         gint world_centery,
                         gint angle,
                         GedaObject *object)
@@ -513,14 +503,12 @@ geda_bus_object_rotate (TOPLEVEL *toplevel,
  *  This function mirrors a bus \a object horizontaly at the point
  *  (\a world_centerx, \a world_centery).
  *
- *  \param [in]     toplevel      The TOPLEVEL object
  *  \param [in]     world_centerx x-coord of the mirror position
  *  \param [in]     world_centery y-coord of the mirror position
  *  \param [in,out] object        The bus object
  */
 void
-geda_bus_object_mirror (TOPLEVEL *toplevel,
-                        gint world_centerx,
+geda_bus_object_mirror (gint world_centerx,
                         gint world_centery,
                         GedaObject *object)
 {
@@ -569,15 +557,13 @@ geda_bus_object_orientation (const GedaObject *object)
  *  is specified by the \a whichone variable and the new coordinate
  *  is (\a x, \a y).
  *
- *  \param [in]     toplevel   The TOPLEVEL object
  *  \param [in,out] object     The bus OBJECT to modify
  *  \param [in]     x          new x-coord of the bus point
  *  \param [in]     y          new y-coord of the bus point
  *  \param [in]     whichone   bus point to modify
  */
 void
-geda_bus_object_modify (TOPLEVEL *toplevel,
-                        GedaObject *object,
+geda_bus_object_modify (GedaObject *object,
                         gint x,
                         gint y,
                         gint whichone)
diff --git a/liblepton/src/geda_circle_object.c b/liblepton/src/geda_circle_object.c
index 89328781e..07d75b7fb 100644
--- a/liblepton/src/geda_circle_object.c
+++ b/liblepton/src/geda_circle_object.c
@@ -49,7 +49,6 @@
  *  line type with a width of 0, and no filling. It can be changed after
  *  with #o_set_line_options() and #o_set_fill_options().
  *
- *  \param [in]     toplevel     The TOPLEVEL object.
  *  \param [in]     color        Circle line color.
  *  \param [in]     center_x     Center x coordinate.
  *  \param [in]     center_y     Center y coordinate.
@@ -57,8 +56,7 @@
  *  \return A pointer to the new end of the object list.
  */
 GedaObject*
-geda_circle_object_new (TOPLEVEL *toplevel,
-                        gint color,
+geda_circle_object_new (gint color,
                         gint center_x,
                         gint center_y,
                         gint radius)
@@ -77,16 +75,14 @@ geda_circle_object_new (TOPLEVEL *toplevel,
   new_node->circle->radius   = radius;
 
   /* line type and filling initialized to default */
-  o_set_line_options (toplevel,
-                      new_node,
+  o_set_line_options (new_node,
                       DEFAULT_OBJECT_END,
                       TYPE_SOLID,
                       LINE_WIDTH,
                       -1,
                       -1);
 
-  o_set_fill_options (toplevel,
-                      new_node,
+  o_set_fill_options (new_node,
                       FILLING_HOLLOW,
                       -1,
                       -1,
@@ -102,12 +98,11 @@ geda_circle_object_new (TOPLEVEL *toplevel,
  *  The function #geda_circle_object_copy() creates a verbatim copy of the object
  *  pointed by <B>o_current</B> describing a circle.
  *
- *  \param [in]  toplevel  The TOPLEVEL object.
  *  \param [in]  o_current  Circle OBJECT to copy.
  *  \return The new OBJECT
  */
 GedaObject*
-geda_circle_object_copy (TOPLEVEL *toplevel, const GedaObject *object)
+geda_circle_object_copy (const GedaObject *object)
 {
   GedaObject *new_obj;
 
@@ -115,22 +110,19 @@ geda_circle_object_copy (TOPLEVEL *toplevel, const GedaObject *object)
   g_return_val_if_fail (object->circle != NULL, NULL);
   g_return_val_if_fail (object->type == OBJ_CIRCLE, NULL);
 
-  new_obj = geda_circle_object_new (toplevel,
-                                    object->color,
+  new_obj = geda_circle_object_new (object->color,
                                     object->circle->center_x,
                                     object->circle->center_y,
                                     object->circle->radius);
 
-  o_set_line_options (toplevel,
-                      new_obj,
+  o_set_line_options (new_obj,
                       object->line_end,
                       object->line_type,
                       object->line_width,
                       object->line_length,
                       object->line_space);
 
-  o_set_fill_options (toplevel,
-                      new_obj,
+  o_set_fill_options (new_obj,
                       object->fill_type,
                       object->fill_width,
                       object->fill_pitch1,
@@ -249,7 +241,6 @@ geda_circle_object_set_radius (GedaObject *object, gint radius)
  *  The bounding box of the circle object is updated after the modification of its
  *  parameters.
  *
- *  \param [in]     toplevel  The TOPLEVEL object.
  *  \param [in,out] object     Circle OBJECT to modify.
  *  \param [in]     x          New center x coordinate, or radius value.
  *  \param [in]     y          New center y coordinate.
@@ -263,13 +254,12 @@ geda_circle_object_set_radius (GedaObject *object, gint radius)
  *  </DL>
  */
 void
-geda_circle_object_modify (TOPLEVEL *toplevel,
-                           GedaObject *object,
+geda_circle_object_modify (GedaObject *object,
                            gint x,
                            gint y,
                            gint whichone)
 {
-  o_emit_pre_change_notify (toplevel, object);
+  o_emit_pre_change_notify (object);
 
   switch(whichone) {
     case CIRCLE_CENTER:
@@ -285,7 +275,7 @@ geda_circle_object_modify (TOPLEVEL *toplevel,
       break;
   }
 
-  o_emit_change_notify (toplevel, object);
+  o_emit_change_notify (object);
 }
 
 /*! \brief Create circle OBJECT from character string.
@@ -300,15 +290,13 @@ geda_circle_object_modify (TOPLEVEL *toplevel,
  *    <DT>*</DT><DD>the file format used for the releases after 20000704.
  *  </DL>
  *
- *  \param [in]  toplevel       The TOPLEVEL object.
  *  \param [in]  buf             Character string with circle description.
  *  \param [in]  release_ver     libgeda release version number.
  *  \param [in]  fileformat_ver  libgeda file format version number.
  *  \return A pointer to the new circle object, or NULL on error.
  */
 GedaObject*
-o_circle_read (TOPLEVEL *toplevel,
-               const char buf[],
+o_circle_read (const char buf[],
                unsigned int release_ver,
                unsigned int fileformat_ver,
                GError ** err)
@@ -387,23 +375,21 @@ o_circle_read (TOPLEVEL *toplevel,
    * Its filling and line type are set according to the values of the field
    * on the line.
    */
-  new_obj = geda_circle_object_new (toplevel, color, x1, y1, radius);
-
-  o_set_line_options(toplevel,
-                     new_obj,
-                     (OBJECT_END) circle_end,
-                     (OBJECT_TYPE) circle_type,
-                     circle_width,
-                     circle_length,
-                     circle_space);
-  o_set_fill_options(toplevel,
-                     new_obj,
-                     (OBJECT_FILLING) circle_fill,
-                     fill_width,
-                     pitch1,
-                     angle1,
-                     pitch2,
-                     angle2);
+  new_obj = geda_circle_object_new (color, x1, y1, radius);
+
+  o_set_line_options (new_obj,
+                      (OBJECT_END) circle_end,
+                      (OBJECT_TYPE) circle_type,
+                      circle_width,
+                      circle_length,
+                      circle_space);
+  o_set_fill_options (new_obj,
+                      (OBJECT_FILLING) circle_fill,
+                      fill_width,
+                      pitch1,
+                      angle1,
+                      pitch2,
+                      angle2);
 
   return new_obj;
 }
@@ -476,15 +462,13 @@ geda_circle_object_translate (GedaObject *object, gint dx, gint dy)
  *  angle <B>angle</B> degrees.
  *  The center of rotation is in world unit.
  *
- *  \param [in]      toplevel      The TOPLEVEL object.
  *  \param [in]      world_centerx  Rotation center x coordinate in WORLD units.
  *  \param [in]      world_centery  Rotation center y coordinate in WORLD units.
  *  \param [in]      angle          Rotation angle in degrees (See note below).
  *  \param [in,out]  object         Circle OBJECT to rotate.
  */
 void
-geda_circle_object_rotate (TOPLEVEL *toplevel,
-                           gint world_centerx,
+geda_circle_object_rotate (gint world_centerx,
                            gint world_centery,
                            gint angle,
                            GedaObject *object)
@@ -533,14 +517,12 @@ geda_circle_object_rotate (TOPLEVEL *toplevel,
  *  The circle coordinates and its bounding are recalculated as well as the
  *  OBJECT specific (line width, filling ...).
  *
- *  \param [in]     toplevel       The TOPLEVEL object.
  *  \param [in]     world_centerx  Origin x coordinate in WORLD units.
  *  \param [in]     world_centery  Origin y coordinate in WORLD units.
  *  \param [in,out] object         Circle OBJECT to mirror.
  */
 void
-geda_circle_object_mirror (TOPLEVEL *toplevel,
-                           gint world_centerx,
+geda_circle_object_mirror (gint world_centerx,
                            gint world_centery,
                            GedaObject *object)
 {
@@ -564,13 +546,11 @@ geda_circle_object_mirror (TOPLEVEL *toplevel,
  *  parameters to the boundings of the circle object described in <B>*circle</B>
  *  in world units.
  *
- *  \param [in]  toplevel  The TOPLEVEL object.
  *  \param [in]  object    Circle OBJECT to read coordinates from.
  *  \param [out] bounds    The bounds of the circle object.
  */
 void
-geda_circle_object_calculate_bounds (TOPLEVEL *toplevel,
-                                     const GedaObject *object,
+geda_circle_object_calculate_bounds (const GedaObject *object,
                                      GedaBounds *bounds)
 {
   gint expand;
diff --git a/liblepton/src/geda_component_object.c b/liblepton/src/geda_component_object.c
index 8d5fcc096..f318c2123 100644
--- a/liblepton/src/geda_component_object.c
+++ b/liblepton/src/geda_component_object.c
@@ -210,15 +210,13 @@ geda_component_object_get_position (const GedaObject *object, gint *x, gint *y)
  *  An attribute object is promotable if it's promoted by default, or the user
  *  has configered it to promote an attribute.
  *
- *  \param [in] toplevel  The TOPLEVEL object
  *  \param [in] object    The attribute object to check
  *  \return TRUE if the object is a eligible attribute, FALSE otherwise
  */
 static int
-o_component_is_eligible_attribute (TOPLEVEL *toplevel, OBJECT *object)
+o_component_is_eligible_attribute (OBJECT *object)
 {
   gboolean promote_invisible;
-  g_return_val_if_fail (toplevel, FALSE);
   g_return_val_if_fail (object, FALSE);
 
   cfg_read_bool ("schematic.attrib", "promote-invisible",
@@ -244,7 +242,7 @@ o_component_is_eligible_attribute (TOPLEVEL *toplevel, OBJECT *object)
   }
 
   /* object is invisible and we do not want to promote invisible text */
-  if ((!o_is_visible (toplevel, object)) &&
+  if ((!o_is_visible (object)) &&
       (promote_invisible == FALSE))
     return FALSE; /* attribute not eligible for promotion */
 
@@ -285,12 +283,13 @@ o_component_is_embedded (OBJECT *o_current)
  *  from the prim_objs of the component.  If detach is FALSE, the
  *  OBJECTs are left in place.
  *
- *  \param [in]  toplevel The toplevel environment.
  *  \param [in]  object   The component object being modified.
  *  \param [in]  detach   Should the attributes be detached?
  *  \returns              A linked list of OBJECTs to promote.
  */
-GList *o_component_get_promotable (TOPLEVEL *toplevel, OBJECT *object, int detach)
+GList*
+o_component_get_promotable (OBJECT *object,
+                            int detach)
 {
   GList *promoted = NULL;
   GList *attribs;
@@ -310,7 +309,7 @@ GList *o_component_get_promotable (TOPLEVEL *toplevel, OBJECT *object, int detac
     tmp = (OBJECT*) iter->data;
 
     /* Is it an attribute we want to promote? */
-    if (!o_component_is_eligible_attribute (toplevel, tmp))
+    if (!o_component_is_eligible_attribute (tmp))
       continue;
 
     if (detach) {
@@ -334,11 +333,11 @@ GList *o_component_get_promotable (TOPLEVEL *toplevel, OBJECT *object, int detac
  *  Selects promotable attributes from \a object, and returns a new
  *  #GList containing them (suitable for appending to a #PAGE).
  *
- *  \param [in]  toplevel The #TOPLEVEL environment.
  *  \param [in]  object   The component #OBJECT to promote from.
  *  \return A #GList of promoted attributes.
  */
-GList *o_component_promote_attribs (TOPLEVEL *toplevel, OBJECT *object)
+GList*
+o_component_promote_attribs (OBJECT *object)
 {
   GList *promoted = NULL;
   GList *promotable = NULL;
@@ -348,7 +347,7 @@ GList *o_component_promote_attribs (TOPLEVEL *toplevel, OBJECT *object)
   cfg_read_bool ("schematic.attrib", "keep-invisible",
                  default_keep_invisible, &keep_invisible);
 
-  promotable = o_component_get_promotable (toplevel, object, FALSE);
+  promotable = o_component_get_promotable (object, FALSE);
 
   /* Run through the attributes deciding if we want to keep them (in
    * which case we copy them and make them invisible) or if we want to
@@ -356,8 +355,8 @@ GList *o_component_promote_attribs (TOPLEVEL *toplevel, OBJECT *object)
   if (keep_invisible) {
     for (iter = promotable; iter != NULL; iter = g_list_next (iter)) {
       OBJECT *o_kept = (OBJECT *) iter->data;
-      OBJECT *o_copy = o_object_copy (toplevel, o_kept);
-      o_set_visibility (toplevel, o_kept, INVISIBLE);
+      OBJECT *o_copy = o_object_copy (o_kept);
+      o_set_visibility (o_kept, INVISIBLE);
       o_copy->parent = NULL;
       promoted = g_list_prepend (promoted, o_copy);
     }
@@ -374,7 +373,7 @@ GList *o_component_promote_attribs (TOPLEVEL *toplevel, OBJECT *object)
 
   /* Attach promoted attributes to the original component
      object. */
-  o_attrib_attach_list (toplevel, promoted, object, TRUE);
+  o_attrib_attach_list (promoted, object, TRUE);
 
   return promoted;
 }
@@ -393,15 +392,15 @@ GList *o_component_promote_attribs (TOPLEVEL *toplevel, OBJECT *object)
  *  true, attributes eligible for promotion are kept in memory but
  *  flagged as invisible.
  *
- *  \param [in]  toplevel The toplevel environment.
  *  \param [in]  object   The component object being altered.
  */
-static void o_component_remove_promotable_attribs (TOPLEVEL *toplevel, OBJECT *object)
+static void
+o_component_remove_promotable_attribs (OBJECT *object)
 {
   GList *promotable, *iter;
   gboolean keep_invisible;
 
-  promotable = o_component_get_promotable (toplevel, object, FALSE);
+  promotable = o_component_get_promotable (object, FALSE);
 
   if (promotable == NULL)
     return;
@@ -412,11 +411,11 @@ static void o_component_remove_promotable_attribs (TOPLEVEL *toplevel, OBJECT *o
   for (iter = promotable; iter != NULL; iter = g_list_next (iter)) {
     OBJECT *a_object = (OBJECT*) iter->data;
     if (keep_invisible == TRUE) {   /* Hide promotable attributes */
-      o_set_visibility (toplevel, a_object, INVISIBLE);
+      o_set_visibility (a_object, INVISIBLE);
     } else {                                /* Delete promotable attributes */
       object->component->prim_objs =
         g_list_remove (object->component->prim_objs, a_object);
-      s_delete_object (toplevel, a_object);
+      s_delete_object (a_object);
     }
   }
 
@@ -459,12 +458,10 @@ static void create_placeholder(TOPLEVEL * toplevel, OBJECT * new_node, int x, in
     }
 
     /* Mark the origin of the missing component */
-    new_prim_obj = geda_line_object_new (toplevel,
-                                        DETACHED_ATTRIBUTE_COLOR,
-                                        x - 50, y, x + 50, y);
+    new_prim_obj = geda_line_object_new (DETACHED_ATTRIBUTE_COLOR,
+                                         x - 50, y, x + 50, y);
     new_node->component->prim_objs = g_list_prepend (new_node->component->prim_objs, new_prim_obj);
-    new_prim_obj = geda_line_object_new (toplevel,
-                                         DETACHED_ATTRIBUTE_COLOR,
+    new_prim_obj = geda_line_object_new (DETACHED_ATTRIBUTE_COLOR,
                                          x, y + 50, x, y - 50);
     new_node->component->prim_objs = g_list_prepend (new_node->component->prim_objs, new_prim_obj);
 
@@ -472,8 +469,7 @@ static void create_placeholder(TOPLEVEL * toplevel, OBJECT * new_node, int x, in
     not_found_text =
       g_strdup_printf (_("Component not found:\n %1$s"),
            new_node->component_basename);
-    new_prim_obj = geda_text_object_new (toplevel,
-                                         DETACHED_ATTRIBUTE_COLOR,
+    new_prim_obj = geda_text_object_new (DETACHED_ATTRIBUTE_COLOR,
                                          x + NOT_FOUND_TEXT_X,
                                          y + NOT_FOUND_TEXT_Y,
                                          LOWER_LEFT,
@@ -492,35 +488,31 @@ static void create_placeholder(TOPLEVEL * toplevel, OBJECT * new_node, int x, in
     y_offset = bounds.max_y - bounds.min_y + 100;  /* 100 is just an additional offset */
 
     /* add hazard triangle */
-    new_prim_obj = geda_line_object_new (toplevel,
-                                         DETACHED_ATTRIBUTE_COLOR,
+    new_prim_obj = geda_line_object_new (DETACHED_ATTRIBUTE_COLOR,
                                          x + NOT_FOUND_TEXT_X + x_offset,
                                          y + NOT_FOUND_TEXT_Y + y_offset,
                                          x + NOT_FOUND_TEXT_X + x_offset + 600,
                                          y + NOT_FOUND_TEXT_Y + y_offset);
-    o_set_line_options(toplevel, new_prim_obj, END_ROUND, TYPE_SOLID,
-                       50, -1, -1);
+    o_set_line_options (new_prim_obj, END_ROUND, TYPE_SOLID,
+                        50, -1, -1);
     new_node->component->prim_objs = g_list_prepend (new_node->component->prim_objs, new_prim_obj);
-    new_prim_obj = geda_line_object_new (toplevel,
-                                         DETACHED_ATTRIBUTE_COLOR,
+    new_prim_obj = geda_line_object_new (DETACHED_ATTRIBUTE_COLOR,
                                          x + NOT_FOUND_TEXT_X + x_offset,
                                          y + NOT_FOUND_TEXT_Y + y_offset,
                                          x + NOT_FOUND_TEXT_X + x_offset + 300,
                                          y + NOT_FOUND_TEXT_Y + y_offset + 500);
-    o_set_line_options(toplevel, new_prim_obj, END_ROUND, TYPE_SOLID,
-                       50, -1, -1);
+    o_set_line_options (new_prim_obj, END_ROUND, TYPE_SOLID,
+                        50, -1, -1);
     new_node->component->prim_objs = g_list_prepend (new_node->component->prim_objs, new_prim_obj);
-    new_prim_obj = geda_line_object_new (toplevel,
-                                         DETACHED_ATTRIBUTE_COLOR,
+    new_prim_obj = geda_line_object_new (DETACHED_ATTRIBUTE_COLOR,
                                          x + NOT_FOUND_TEXT_X + x_offset + 300,
                                          y + NOT_FOUND_TEXT_Y + y_offset + 500,
                                          x + NOT_FOUND_TEXT_X + x_offset + 600,
                                          y + NOT_FOUND_TEXT_Y + y_offset);
-    o_set_line_options(toplevel, new_prim_obj, END_ROUND, TYPE_SOLID,
-                       50, -1, -1);
+    o_set_line_options (new_prim_obj, END_ROUND, TYPE_SOLID,
+                        50, -1, -1);
     new_node->component->prim_objs = g_list_prepend (new_node->component->prim_objs, new_prim_obj);
-    new_prim_obj = geda_text_object_new (toplevel,
-                                         DETACHED_ATTRIBUTE_COLOR,
+    new_prim_obj = geda_text_object_new (DETACHED_ATTRIBUTE_COLOR,
                                          x + NOT_FOUND_TEXT_X + x_offset + 270,
                                          y + NOT_FOUND_TEXT_Y + y_offset + 90,
                                          LOWER_LEFT,
@@ -588,10 +580,10 @@ OBJECT *o_component_new (TOPLEVEL *toplevel,
     }
     else {
       if (mirror) {
-        geda_object_list_mirror (new_node->component->prim_objs, 0, 0, toplevel);
+        geda_object_list_mirror (new_node->component->prim_objs, 0, 0);
       }
 
-      geda_object_list_rotate (new_node->component->prim_objs, 0, 0, angle, toplevel);
+      geda_object_list_rotate (new_node->component->prim_objs, 0, 0, angle);
       geda_object_list_translate (new_node->component->prim_objs, x, y);
     }
 
@@ -732,7 +724,7 @@ OBJECT *o_component_read (TOPLEVEL *toplevel,
     /* Delete or hide attributes eligible for promotion inside the
        component. */
     if (new_obj)
-      o_component_remove_promotable_attribs (toplevel, new_obj);
+      o_component_remove_promotable_attribs (new_obj);
   }
 
   g_free (basename);
@@ -808,11 +800,11 @@ geda_component_object_translate (GedaObject *object, int dx, int dy)
  *  This function creates a copy of the component object \a
  *  o_current.
  *
- *  \param [in] toplevel     The TOPLEVEL object
  *  \param [in] o_current    The object that is copied
  *  \return a new component object
  */
-OBJECT *o_component_copy(TOPLEVEL *toplevel, OBJECT *o_current)
+OBJECT*
+o_component_copy (OBJECT *o_current)
 {
   OBJECT *o_new;
   GList *iter;
@@ -833,7 +825,7 @@ OBJECT *o_component_copy(TOPLEVEL *toplevel, OBJECT *o_current)
 
   /* Copy contents and set the parent pointers on the copied objects. */
   o_new->component->prim_objs =
-    o_glist_copy_all (toplevel, o_current->component->prim_objs,
+    o_glist_copy_all (o_current->component->prim_objs,
                       NULL);
 
   for (iter = o_new->component->prim_objs;
@@ -844,9 +836,9 @@ OBJECT *o_component_copy(TOPLEVEL *toplevel, OBJECT *o_current)
 
   /* Delete or hide attributes eligible for promotion inside the
      component. */
-  o_component_remove_promotable_attribs (toplevel, o_new);
+  o_component_remove_promotable_attribs (o_new);
 
-  s_slot_update_object (toplevel, o_new);
+  s_slot_update_object (o_new);
 
   /* deal with stuff that has changed */
 
@@ -864,16 +856,16 @@ OBJECT *o_component_copy(TOPLEVEL *toplevel, OBJECT *o_current)
  *  (\a centerx,\a centery) point by \a angle degrees.
  *  The center of rotation is in world units.
  *
- *  \param [in]      toplevel  The toplevel environment.
  *  \param [in]      centerx   X coordinate of rotation center (world coords).
  *  \param [in]      centery   Y coordinate of rotation center (world coords).
  *  \param [in]      angle     Rotation angle in degrees.
  *  \param [in,out]  object    Component object to rotate.
  */
 void
-geda_component_object_rotate (TOPLEVEL *toplevel,
-                              int centerx, int centery,
-                              int angle, OBJECT *object)
+geda_component_object_rotate (int centerx,
+                              int centery,
+                              int angle,
+                              OBJECT *object)
 {
   int x, y;
   int newx, newy;
@@ -892,7 +884,7 @@ geda_component_object_rotate (TOPLEVEL *toplevel,
 
   geda_component_object_translate (object, -object->component->x, -object->component->y);
 
-  geda_object_list_rotate (object->component->prim_objs, 0, 0, angle, toplevel);
+  geda_object_list_rotate (object->component->prim_objs, 0, 0, angle);
 
   object->component->x = 0;
   object->component->y = 0;
@@ -909,8 +901,8 @@ geda_component_object_rotate (TOPLEVEL *toplevel,
  *
  */
 void
-geda_component_object_mirror (TOPLEVEL *toplevel,
-                              int world_centerx, int world_centery,
+geda_component_object_mirror (int world_centerx,
+                              int world_centery,
                               OBJECT *object)
 {
   int x, y;
@@ -925,7 +917,7 @@ geda_component_object_mirror (TOPLEVEL *toplevel,
 
   geda_component_object_translate (object, -object->component->x, -object->component->y);
 
-  geda_object_list_mirror (object->component->prim_objs, 0, 0, toplevel);
+  geda_object_list_mirror (object->component->prim_objs, 0, 0);
 
   switch(object->component->angle) {
     case(90):
diff --git a/liblepton/src/geda_line_object.c b/liblepton/src/geda_line_object.c
index 1126a5682..27a8fcbbc 100644
--- a/liblepton/src/geda_line_object.c
+++ b/liblepton/src/geda_line_object.c
@@ -48,7 +48,6 @@
  *  It can be changed after with the #o_set_line_options() and
  *  #o_set_fill_options().
  *
- *  \param [in]     toplevel     The TOPLEVEL object.
  *  \param [in]     type         Must be OBJ_LINE.
  *  \param [in]     color        Circle line color.
  *  \param [in]     x1           Upper x coordinate.
@@ -58,8 +57,7 @@
  *  \return A pointer to the new end of the object list.
  */
 GedaObject*
-geda_line_object_new (TOPLEVEL *toplevel,
-                      gint color,
+geda_line_object_new (gint color,
                       gint x1,
                       gint y1,
                       gint x2,
@@ -80,16 +78,14 @@ geda_line_object_new (TOPLEVEL *toplevel,
   new_node->line->y[1] = y2;
 
   /* line type and filling initialized to default */
-  o_set_line_options (toplevel,
-                      new_node,
+  o_set_line_options (new_node,
                       DEFAULT_OBJECT_END,
                       TYPE_SOLID,
                       LINE_WIDTH,
                       -1,
                       -1);
 
-  o_set_fill_options (toplevel,
-                      new_node,
+  o_set_fill_options (new_node,
                       FILLING_HOLLOW,
                       -1,
                       -1,
@@ -105,39 +101,35 @@ geda_line_object_new (TOPLEVEL *toplevel,
  *  This function creates a verbatim copy of the
  *  object pointed by <B>o_current</B> describing a line.
  *
- *  \param [in]  toplevel  The TOPLEVEL object.
  *  \param [in]  o_current  Line OBJECT to copy.
  *  \return The new OBJECT
  */
 OBJECT*
-geda_line_object_copy (TOPLEVEL *toplevel, OBJECT *o_current)
+geda_line_object_copy (OBJECT *o_current)
 {
   OBJECT *new_obj;
 
-  new_obj = geda_line_object_new (toplevel,
-                                  o_current->color,
+  new_obj = geda_line_object_new (o_current->color,
                                   o_current->line->x[0],
                                   o_current->line->y[0],
                                   o_current->line->x[1],
                                   o_current->line->y[1]);
 
   /* copy the line type and filling options */
-  o_set_line_options (toplevel,
-                      new_obj,
+  o_set_line_options (new_obj,
                       o_current->line_end,
                       o_current->line_type,
                       o_current->line_width,
                       o_current->line_length,
                       o_current->line_space);
 
-  o_set_fill_options(toplevel,
-                     new_obj,
-                     o_current->fill_type,
-                     o_current->fill_width,
-                     o_current->fill_pitch1,
-                     o_current->fill_angle1,
-                     o_current->fill_pitch2,
-                     o_current->fill_angle2);
+  o_set_fill_options (new_obj,
+                      o_current->fill_type,
+                      o_current->fill_width,
+                      o_current->fill_pitch1,
+                      o_current->fill_angle1,
+                      o_current->fill_pitch2,
+                      o_current->fill_angle2);
 
   return new_obj;
 }
@@ -304,7 +296,6 @@ geda_line_object_set_y1 (GedaObject *object, gint y)
  *  The coordinates of the end of line is modified in the world
  *  coordinate system. Screen coordinates and boundings are then updated.
  *
- *  \param [in]     toplevel  The TOPLEVEL object.
  *  \param [in,out] object     Line OBJECT to modify.
  *  \param [in]     x          New x coordinate.
  *  \param [in]     y          New y coordinate.
@@ -317,10 +308,10 @@ geda_line_object_set_y1 (GedaObject *object, gint y)
  *  </DL>
  */
 void
-geda_line_object_modify (TOPLEVEL *toplevel, OBJECT *object,
+geda_line_object_modify (OBJECT *object,
                          int x, int y, int whichone)
 {
-  o_emit_pre_change_notify (toplevel, object);
+  o_emit_pre_change_notify (object);
 
   switch (whichone) {
     case LINE_END1:
@@ -337,7 +328,7 @@ geda_line_object_modify (TOPLEVEL *toplevel, OBJECT *object,
       return;
   }
 
-  o_emit_change_notify (toplevel, object);
+  o_emit_change_notify (object);
 }
 
 /*! \brief Create line OBJECT from character string.
@@ -355,14 +346,16 @@ geda_line_object_modify (TOPLEVEL *toplevel, OBJECT *object,
  *    <DT>*</DT><DD>the file format used for the releases after 20010704.
  *  </DL>
  *
- *  \param [in]  toplevel       The TOPLEVEL object.
  *  \param [in]  buf             Character string with line description.
  *  \param [in]  release_ver     libgeda release version number.
  *  \param [in]  fileformat_ver  libgeda file format version number.
  *  \return A pointer to the new line object, or NULL on error.
  */
-OBJECT *o_line_read (TOPLEVEL *toplevel, const char buf[],
-                     unsigned int release_ver, unsigned int fileformat_ver, GError ** err)
+OBJECT*
+o_line_read (const char buf[],
+             unsigned int release_ver,
+             unsigned int fileformat_ver,
+             GError ** err)
 {
   OBJECT *new_obj;
   char type;
@@ -428,23 +421,21 @@ OBJECT *o_line_read (TOPLEVEL *toplevel, const char buf[],
    * type is set according to the values of the fields on the line.
    */
   /* create and add the line to the list */
-  new_obj = geda_line_object_new (toplevel,
-                                  color,
+  new_obj = geda_line_object_new (color,
                                   x1,
                                   y1,
                                   x2,
                                   y2);
 
   /* set its line options */
-  o_set_line_options (toplevel,
-                      new_obj,
+  o_set_line_options (new_obj,
                       (OBJECT_END) line_end,
                       (OBJECT_TYPE) line_type,
                       line_width,
                       line_length,
                       line_space);
   /* filling is irrelevant for line, just set to default */
-  o_set_fill_options (toplevel, new_obj,
+  o_set_fill_options (new_obj,
                       FILLING_HOLLOW, -1, -1, -1, -1, -1);
 
   return new_obj;
@@ -515,14 +506,15 @@ geda_line_object_translate (GedaObject *object, int dx, int dy)
  *  point by <B>angle</B> degrees.
  *  The center of rotation is in world units.
  *
- *  \param [in]      toplevel      The TOPLEVEL object.
  *  \param [in]      world_centerx  Rotation center x coordinate in WORLD units.
  *  \param [in]      world_centery  Rotation center y coordinate in WORLD units.
  *  \param [in]      angle          Rotation angle in degrees (See note below).
  *  \param [in,out]  object         Line OBJECT to rotate.
  */
-void geda_line_object_rotate (TOPLEVEL *toplevel,
-			 int world_centerx, int world_centery, int angle,
+void
+geda_line_object_rotate (int world_centerx,
+                         int world_centery,
+                         int angle,
 			 OBJECT *object)
 {
   int newx, newy;
@@ -575,13 +567,14 @@ void geda_line_object_rotate (TOPLEVEL *toplevel,
  *  The line if first translated to the origin, then mirrored
  *  and finally translated back at its previous position.
  *
- *  \param [in]     toplevel      The TOPLEVEL object.
  *  \param [in]     world_centerx  Origin x coordinate in WORLD units.
  *  \param [in]     world_centery  Origin y coordinate in WORLD units.
  *  \param [in,out] object         Line OBJECT to mirror.
  */
-void geda_line_object_mirror (TOPLEVEL *toplevel, int world_centerx,
-			 int world_centery, OBJECT *object)
+void
+geda_line_object_mirror (int world_centerx,
+			 int world_centery,
+                         OBJECT *object)
 {
   g_return_if_fail (object != NULL);
   g_return_if_fail (object->line != NULL);
@@ -603,13 +596,11 @@ void geda_line_object_mirror (TOPLEVEL *toplevel, int world_centerx,
  *
  *  On failure, this function sets the bounds to empty.
  *
- *  \param [in]  toplevel Unused
  *  \param [in]  object   The line object
  *  \param [out] bounds   The bounds of the line
  */
 void
-geda_line_object_calculate_bounds (TOPLEVEL *toplevel,
-                                   const OBJECT *object,
+geda_line_object_calculate_bounds (const OBJECT *object,
                                    GedaBounds *bounds)
 {
   gint expand;
diff --git a/liblepton/src/geda_net_object.c b/liblepton/src/geda_net_object.c
index cec1576fc..a1c9239c5 100644
--- a/liblepton/src/geda_net_object.c
+++ b/liblepton/src/geda_net_object.c
@@ -212,13 +212,11 @@ geda_net_object_set_y1 (GedaObject *object, gint y)
  *
  *  On failure, this function sets the bounds to empty.
  *
- *  \param [in]  toplevel Unused
  *  \param [in]  object   The net object
  *  \param [out] bounds   The bounds of the net
  */
 void
-geda_net_object_calculate_bounds (TOPLEVEL *toplevel,
-                                  const OBJECT *object,
+geda_net_object_calculate_bounds (const OBJECT *object,
                                   GedaBounds *bounds)
 {
   gint expand;
@@ -241,7 +239,6 @@ geda_net_object_calculate_bounds (TOPLEVEL *toplevel,
  *  \par Function Description
  *  This function creates and returns a new net object.
  *
- *  \param [in]     toplevel    The TOPLEVEL object.
  *  \param [in]     type        The OBJECT type (usually OBJ_NET)
  *  \param [in]     color       The color of the net
  *  \param [in]     x1          x-coord of the first point
@@ -251,8 +248,12 @@ geda_net_object_calculate_bounds (TOPLEVEL *toplevel,
  *  \return A new net OBJECT
  */
 OBJECT*
-geda_net_object_new (TOPLEVEL *toplevel, char type,
-                     int color, int x1, int y1, int x2, int y2)
+geda_net_object_new (char type,
+                     int color,
+                     int x1,
+                     int y1,
+                     int x2,
+                     int y2)
 {
   OBJECT *new_node;
 
@@ -276,15 +277,17 @@ geda_net_object_new (TOPLEVEL *toplevel, char type,
  *  If the netobject was read successfully, a new net object is
  *  allocated and appended to the \a object_list.
  *
- *  \param [in] toplevel     The TOPLEVEL object
  *  \param [in] buf          a text buffer (usually a line of a schematic file)
  *  \param [in] release_ver  The release number gEDA
  *  \param [in] fileformat_ver a integer value of the file format
  *  \return The object list, or NULL on error.
  *
  */
-OBJECT *o_net_read (TOPLEVEL *toplevel, const char buf[],
-                    unsigned int release_ver, unsigned int fileformat_ver, GError **err)
+OBJECT*
+o_net_read (const char buf[],
+            unsigned int release_ver,
+            unsigned int fileformat_ver,
+            GError **err)
 {
   OBJECT *new_obj;
   char type;
@@ -309,7 +312,7 @@ OBJECT *o_net_read (TOPLEVEL *toplevel, const char buf[],
     color = DEFAULT_COLOR;
   }
 
-  new_obj = geda_net_object_new (toplevel, type, color, x1, y1, x2, y2);
+  new_obj = geda_net_object_new (type, color, x1, y1, x2, y2);
 
   return new_obj;
 }
@@ -364,12 +367,11 @@ geda_net_object_translate (GedaObject *object, int dx, int dy)
  *  \par Function Description
  *  This function creates a copy of the net object \a o_current.
  *
- *  \param [in] toplevel     The TOPLEVEL object
  *  \param [in] o_current    The object that is copied
  *  \return a new net object
  */
 OBJECT*
-geda_net_object_copy (TOPLEVEL *toplevel,  OBJECT *o_current)
+geda_net_object_copy (OBJECT *o_current)
 {
   OBJECT *new_obj;
 
@@ -377,9 +379,12 @@ geda_net_object_copy (TOPLEVEL *toplevel,  OBJECT *o_current)
   /* still doesn't work... you need to pass in the new values */
   /* or don't update and update later */
   /* I think for now I'll disable the update and manually update */
-  new_obj = geda_net_object_new (toplevel, OBJ_NET, o_current->color,
-                                 o_current->line->x[0], o_current->line->y[0],
-                                 o_current->line->x[1], o_current->line->y[1]);
+  new_obj = geda_net_object_new (OBJ_NET,
+                                 o_current->color,
+                                 o_current->line->x[0],
+                                 o_current->line->y[0],
+                                 o_current->line->x[1],
+                                 o_current->line->y[1]);
 
   return new_obj;
 }
@@ -389,15 +394,16 @@ geda_net_object_copy (TOPLEVEL *toplevel,  OBJECT *o_current)
  *  This function rotates a net \a object around the point
  *  (\a world_centerx, \a world_centery).
  *
- *  \param [in] toplevel      The TOPLEVEL object
  *  \param [in] world_centerx x-coord of the rotation center
  *  \param [in] world_centery y-coord of the rotation center
  *  \param [in] angle         The angle to rotat the net object
  *  \param [in] object        The net object
  *  \note only steps of 90 degrees are allowed for the \a angle
  */
-void geda_net_object_rotate (TOPLEVEL *toplevel,
-			int world_centerx, int world_centery, int angle,
+void
+geda_net_object_rotate (int world_centerx,
+                        int world_centery,
+                        int angle,
 			OBJECT *object)
 {
   int newx, newy;
@@ -432,13 +438,14 @@ void geda_net_object_rotate (TOPLEVEL *toplevel,
  *  This function mirrors a net \a object horizontaly at the point
  *  (\a world_centerx, \a world_centery).
  *
- *  \param [in] toplevel      The TOPLEVEL object
  *  \param [in] world_centerx x-coord of the mirror position
  *  \param [in] world_centery y-coord of the mirror position
  *  \param [in] object        The net object
  */
-void geda_net_object_mirror (TOPLEVEL *toplevel, int world_centerx,
-			int world_centery, OBJECT *object)
+void
+geda_net_object_mirror (int world_centerx,
+			int world_centery,
+                        OBJECT *object)
 {
   g_return_if_fail (object != NULL);
   g_return_if_fail (object->line != NULL);
@@ -604,12 +611,12 @@ static int o_net_consolidate_nomidpoint (OBJECT *object, int x, int y)
  *  This function tries to consolidate a net with any other object
  *  that is connected to the current \a object.
  *
- *  \param toplevel   The TOPLEVEL object
  *  \param object     The object to consolidate
  *  \return 0 if no consolidation was possible, -1 otherwise
  *
  */
-static int o_net_consolidate_segments (TOPLEVEL *toplevel, OBJECT *object)
+static int
+o_net_consolidate_segments (OBJECT *object)
 {
   int object_orient;
   int other_orient;
@@ -619,7 +626,6 @@ static int o_net_consolidate_segments (TOPLEVEL *toplevel, OBJECT *object)
   PAGE *page;
   int changed = 0;
 
-  g_return_val_if_fail ((toplevel != NULL), 0);
   g_return_val_if_fail ((object != NULL), 0);
   g_return_val_if_fail ((object->type == OBJ_NET), 0);
 
@@ -656,17 +662,17 @@ static int o_net_consolidate_segments (TOPLEVEL *toplevel, OBJECT *object)
 
           changed++;
           if (other_object->selected == TRUE ) {
-            o_selection_remove (toplevel, page->selection_list, other_object);
+            o_selection_remove (page->selection_list, other_object);
 
             /* If we're consolidating with a selected object,
              * ensure we select the resulting object.
              */
             if (object->selected == FALSE) {
-              o_selection_add (toplevel, page->selection_list, object);
+              o_selection_add (page->selection_list, object);
             }
           }
 
-          s_delete_object (toplevel, other_object);
+          s_delete_object (other_object);
           s_conn_update_object (page, object);
           return(-1);
         }
@@ -685,18 +691,16 @@ static int o_net_consolidate_segments (TOPLEVEL *toplevel, OBJECT *object)
  *  This function consolidates all net objects in a page until no more
  *  consolidations are possible.
  *
- *  \param toplevel  The TOPLEVEL object.
  *  \param page      The PAGE to consolidate nets in.
  */
 void
-geda_net_object_consolidate (TOPLEVEL *toplevel, PAGE *page)
+geda_net_object_consolidate (PAGE *page)
 {
   OBJECT *o_current;
   const GList *iter;
   int status = 0;
   gboolean net_consolidate;
 
-  g_return_if_fail (toplevel != NULL);
   g_return_if_fail (page != NULL);
 
   cfg_read_bool ("schematic", "net-consolidate",
@@ -711,7 +715,7 @@ geda_net_object_consolidate (TOPLEVEL *toplevel, PAGE *page)
     o_current = (OBJECT *)iter->data;
 
     if (o_current->type == OBJ_NET) {
-      status = o_net_consolidate_segments(toplevel, o_current);
+      status = o_net_consolidate_segments (o_current);
     }
 
     if (status == -1) {
@@ -729,7 +733,6 @@ geda_net_object_consolidate (TOPLEVEL *toplevel, PAGE *page)
  *  is specified by the \a whichone variable and the new coordinate
  *  is (\a x, \a y).
  *
- *  \param toplevel   The TOPLEVEL object
  *  \param object     The net OBJECT to modify
  *  \param x          new x-coord of the net point
  *  \param y          new y-coord of the net point
@@ -737,8 +740,10 @@ geda_net_object_consolidate (TOPLEVEL *toplevel, PAGE *page)
  *
  */
 void
-geda_net_object_modify (TOPLEVEL *toplevel, OBJECT *object,
-                        int x, int y, int whichone)
+geda_net_object_modify (OBJECT *object,
+                        int x,
+                        int y,
+                        int whichone)
 {
   object->line->x[whichone] = x;
   object->line->y[whichone] = y;
diff --git a/liblepton/src/geda_object.c b/liblepton/src/geda_object.c
index aca262cfe..98f4785b5 100644
--- a/liblepton/src/geda_object.c
+++ b/liblepton/src/geda_object.c
@@ -158,63 +158,61 @@ s_basic_new_object (int type, char const *prefix)
  *  look at above.. this returns what was passed in!!!!
  *  copies selected to list_head (!! returns new list)
  *
- *  \param [in]  toplevel   The TOPLEVEL object.
  *  \param [in]  selected
  *  \return OBJECT pointer.
  */
-OBJECT *o_object_copy (TOPLEVEL *toplevel,
-                       OBJECT *selected)
+OBJECT*
+o_object_copy (OBJECT *selected)
 {
   OBJECT *new_obj;
 
-  g_return_val_if_fail (toplevel != NULL, NULL);
   g_return_val_if_fail (selected != NULL, NULL);
 
   switch(selected->type) {
 
     case(OBJ_LINE):
-      new_obj = geda_line_object_copy (toplevel, selected);
+      new_obj = geda_line_object_copy (selected);
       break;
 
     case(OBJ_NET):
-      new_obj = geda_net_object_copy (toplevel, selected);
+      new_obj = geda_net_object_copy (selected);
       break;
 
     case(OBJ_BUS):
-      new_obj = geda_bus_object_copy (toplevel, selected);
+      new_obj = geda_bus_object_copy (selected);
       break;
 
     case(OBJ_BOX):
-      new_obj = geda_box_object_copy (toplevel, selected);
+      new_obj = geda_box_object_copy (selected);
       break;
 
     case(OBJ_PICTURE):
-      new_obj = o_picture_copy (toplevel, selected);
+      new_obj = o_picture_copy (selected);
       break;
 
     case(OBJ_CIRCLE):
-      new_obj = geda_circle_object_copy (toplevel, selected);
+      new_obj = geda_circle_object_copy (selected);
       break;
 
     case(OBJ_COMPONENT):
     case(OBJ_PLACEHOLDER):
-      new_obj = o_component_copy (toplevel, selected);
+      new_obj = o_component_copy (selected);
       break;
 
     case(OBJ_TEXT):
-      new_obj = geda_text_object_copy (toplevel, selected);
+      new_obj = geda_text_object_copy (selected);
       break;
 
     case(OBJ_PATH):
-      new_obj = geda_path_object_copy (toplevel, selected);
+      new_obj = geda_path_object_copy (selected);
       break;
 
     case(OBJ_PIN):
-      new_obj = geda_pin_object_copy (toplevel, selected);
+      new_obj = geda_pin_object_copy (selected);
       break;
 
     case(OBJ_ARC):
-      new_obj = geda_arc_object_copy (toplevel, selected);
+      new_obj = geda_arc_object_copy (selected);
       break;
 
     default:
@@ -241,19 +239,19 @@ OBJECT *o_object_copy (TOPLEVEL *toplevel,
  *
  */
 void
-s_delete_object(TOPLEVEL *toplevel, OBJECT *o_current)
+s_delete_object (OBJECT *o_current)
 {
   if (o_current != NULL) {
     /* If currently attached to a page, remove it from the page */
     if (o_current->page != NULL) {
-      s_page_remove (toplevel, o_current->page, o_current);
+      s_page_remove (o_current->page, o_current);
     }
 
-    s_conn_remove_object_connections (toplevel, o_current);
+    s_conn_remove_object_connections (o_current);
 
     if (o_current->attached_to != NULL) {
       /* do the actual remove */
-      o_attrib_remove(toplevel, &o_current->attached_to->attribs, o_current);
+      o_attrib_remove (&o_current->attached_to->attribs, o_current);
     }
 
     /* printf("sdeleting line\n"); */
@@ -301,7 +299,7 @@ s_delete_object(TOPLEVEL *toplevel, OBJECT *o_current)
 
       if (o_current->component->prim_objs) {
         /* printf("sdeleting component's primitive objects\n");*/
-        geda_object_list_delete (toplevel, o_current->component->prim_objs);
+        geda_object_list_delete (o_current->component->prim_objs);
         o_current->component->prim_objs = NULL;
       }
 
@@ -309,7 +307,7 @@ s_delete_object(TOPLEVEL *toplevel, OBJECT *o_current)
       o_current->component = NULL;
     }
 
-    o_attrib_detach_all (toplevel, o_current);
+    o_attrib_detach_all (o_current);
 
     o_current->weak_refs = s_weakref_notify (o_current, o_current->weak_refs);
 
@@ -404,7 +402,6 @@ s_object_remove_weak_ptr (OBJECT *object,
  *  See #OBJECT_END and #OBJECT_TYPE for information on valid
  *  object end and type values.
  *
- *  \param [in]     toplevel  The TOPLEVEL object.
  *  \param [in,out] o_current  OBJECT to set line options on.
  *  \param [in]     end        An OBJECT_END.
  *  \param [in]     type       An OBJECT_TYPE.
@@ -415,9 +412,13 @@ s_object_remove_weak_ptr (OBJECT *object,
  *  \todo Make space an unsigned int and check for a max value instead.
  *        If a max value is not required, then it would simplify the code.
  */
-void o_set_line_options(TOPLEVEL *toplevel, OBJECT *o_current,
-			OBJECT_END end, OBJECT_TYPE type,
-			int width, int length, int space)
+void
+o_set_line_options (OBJECT *o_current,
+                    OBJECT_END end,
+                    OBJECT_TYPE type,
+                    int width,
+                    int length,
+                    int space)
 {
   g_return_if_fail (o_current != NULL);
 
@@ -448,7 +449,7 @@ void o_set_line_options(TOPLEVEL *toplevel, OBJECT *o_current,
     break;
   }
 
-  o_emit_pre_change_notify (toplevel, o_current);
+  o_emit_pre_change_notify (o_current);
 
   o_current->line_width = width;
   o_current->line_end   = end;
@@ -457,7 +458,7 @@ void o_set_line_options(TOPLEVEL *toplevel, OBJECT *o_current,
   o_current->line_length = length;
   o_current->line_space  = space;
 
-  o_emit_change_notify (toplevel, o_current);
+  o_emit_change_notify (o_current);
 
 }
 
@@ -501,7 +502,6 @@ gboolean o_get_line_options(OBJECT *object,
  *  This function allows an #OBJECT's fill options to be configured.
  *  See #OBJECT_FILLING for information on valid fill types.
  *
- *  \param [in]      toplevel  The TOPLEVEL object.
  *  \param [in,out]  o_current  OBJECT to be updated.
  *  \param [in]      type       OBJECT_FILLING type.
  *  \param [in]      width      fill width.
@@ -511,10 +511,14 @@ gboolean o_get_line_options(OBJECT *object,
  *  \param [in]      angle2     cross hatch angle
  *
  */
-void o_set_fill_options(TOPLEVEL *toplevel, OBJECT *o_current,
-			OBJECT_FILLING type, int width,
-			int pitch1, int angle1,
-			int pitch2, int angle2)
+void
+o_set_fill_options (OBJECT *o_current,
+                    OBJECT_FILLING type,
+                    int width,
+                    int pitch1,
+                    int angle1,
+                    int pitch2,
+                    int angle2)
 {
   if(o_current == NULL) {
     return;
@@ -549,7 +553,7 @@ void o_set_fill_options(TOPLEVEL *toplevel, OBJECT *o_current,
     pitch2 = -1;
   }
 
-  o_emit_pre_change_notify (toplevel, o_current);
+  o_emit_pre_change_notify (o_current);
 
   o_current->fill_type = type;
   o_current->fill_width = width;
@@ -560,7 +564,7 @@ void o_set_fill_options(TOPLEVEL *toplevel, OBJECT *o_current,
   o_current->fill_pitch2 = pitch2;
   o_current->fill_angle2 = angle2;
 
-  o_emit_change_notify (toplevel, o_current);
+  o_emit_change_notify (o_current);
 }
 
 /*! \brief get #OBJECT's fill properties.
@@ -602,7 +606,6 @@ gboolean o_get_fill_options(OBJECT *object,
  *  \par Function Description
  *  This function gets the position of an object in world coordinates.
  *
- *  \param [in] toplevel The toplevel environment.
  *  \param [out] x       pointer to the x-position
  *  \param [out] y       pointer to the y-position
  *  \param [in] object   The object to get the position.
@@ -685,15 +688,18 @@ geda_object_translate (GedaObject *object, gint dx, gint dy)
  *  This function rotates the object <B>object</B> about the coordinates
  *  <B>world_centerx</B> and <B>world_centery</B>, by <B>angle</B>degrees.
  *
- *  \param [in] toplevel The toplevel environment.
  *  \param [in] world_centerx  X coordinate of rotation center (world coords)
  *  \param [in] world_centery  Y coordinate of rotation center (world coords)
  *  \param [in] angle          Angle of rotation (degrees)
  *  \param [in] object         The object to rotate.
  */
-void geda_object_rotate (TOPLEVEL *toplevel, int world_centerx, int world_centery, int angle, OBJECT *object)
+void
+geda_object_rotate (int world_centerx,
+                    int world_centery,
+                    int angle,
+                    OBJECT *object)
 {
-  void (*func) (TOPLEVEL*, int, int, int, OBJECT*) = NULL;
+  void (*func) (int, int, int, OBJECT*) = NULL;
 
   switch (object->type) {
       case OBJ_LINE:    func = geda_line_object_rotate;    break;
@@ -715,7 +721,7 @@ void geda_object_rotate (TOPLEVEL *toplevel, int world_centerx, int world_center
   }
 
   if (func != NULL) {
-    (*func) (toplevel, world_centerx, world_centery, angle, object);
+    (*func) (world_centerx, world_centery, angle, object);
   }
 }
 
@@ -725,14 +731,16 @@ void geda_object_rotate (TOPLEVEL *toplevel, int world_centerx, int world_center
  *  This function mirrors an object about the point
  *  (<B>world_centerx</B>,<B>world_centery</B>) in world units.
  *
- *  \param [in]     toplevel       The TOPLEVEL object.
  *  \param [in]     world_centerx  Origin x coordinate in WORLD units.
  *  \param [in]     world_centery  Origin y coordinate in WORLD units.
  *  \param [in,out] object         The OBJECT to mirror.
  */
-void geda_object_mirror (TOPLEVEL *toplevel, int world_centerx, int world_centery, OBJECT *object)
+void
+geda_object_mirror (int world_centerx,
+                    int world_centery,
+                    OBJECT *object)
 {
-  void (*func) (TOPLEVEL*, int, int, OBJECT*) = NULL;
+  void (*func) (int, int, OBJECT*) = NULL;
 
   switch (object->type) {
       case OBJ_LINE:    func = geda_line_object_mirror;    break;
@@ -754,7 +762,7 @@ void geda_object_mirror (TOPLEVEL *toplevel, int world_centerx, int world_center
   }
 
   if (func != NULL) {
-    (*func) (toplevel, world_centerx, world_centery, object);
+    (*func) (world_centerx, world_centery, object);
   }
 }
 
@@ -827,14 +835,12 @@ geda_object_shortest_distance_full (TOPLEVEL *toplevel, OBJECT *object,
 
 /*! \brief Change the color of an object
  *
- *  \par Function Description
- *  This function changes the color of an object.
- *
- *  \param [in] toplevel  The TOPLEVEL structure.
  *  \param [in] object    The OBJECT to change color.
  *  \param [in] color     The new color.
  */
-void o_set_color (TOPLEVEL *toplevel, OBJECT *object, int color)
+void
+o_set_color (OBJECT *object,
+             int color)
 {
   g_return_if_fail (object != NULL);
 
@@ -842,7 +848,7 @@ void o_set_color (TOPLEVEL *toplevel, OBJECT *object, int color)
 
   if (object->type == OBJ_COMPONENT ||
       object->type == OBJ_PLACEHOLDER)
-    geda_object_list_set_color (object->component->prim_objs, color, toplevel);
+    geda_object_list_set_color (object->component->prim_objs, color);
 }
 
 
@@ -873,12 +879,11 @@ o_get_page (OBJECT *object)
  * If \a object is part of a component #OBJECT, returns that
  * #OBJECT. Otherwise, returns NULL.
  *
- * \param [in] toplevel  The TOPLEVEL structure.
  * \param [in] object    The OBJECT for which to get the containing OBJECT.
  * \return The component OBJECT which owns \a object, or NULL.
  */
 OBJECT *
-o_get_parent (TOPLEVEL *toplevel, OBJECT *object)
+o_get_parent (OBJECT *object)
 {
   g_return_val_if_fail ((object != NULL), NULL);
 
@@ -963,19 +968,26 @@ o_remove_change_notify (TOPLEVEL *toplevel,
 
 /*! \brief Emit an object pre-change notification.
  * \par Function Description
- * Calls each pre-change callback function registered with #TOPLEVEL
- * to notify listeners that \a object is about to be modified.  All
- * libgeda functions that modify #OBJECT structures should call this
- * just before making a change to an #OBJECT.
  *
- * \param toplevel #TOPLEVEL structure to emit notifications from.
+ * Calls each pre-change callback function registered with \a
+ * object's #TOPLEVEL to notify listeners that \a object is about
+ * to be modified.  All liblepton functions that modify #OBJECT
+ * structures should call this just before making a change to an
+ * #OBJECT.
+ *
  * \param object   #OBJECT structure to emit notifications for.
  */
 void
-o_emit_pre_change_notify (TOPLEVEL *toplevel, OBJECT *object)
+o_emit_pre_change_notify (OBJECT *object)
 {
   GList *iter;
 
+  if (object->page == NULL) {
+    return;
+  }
+
+  TOPLEVEL *toplevel = object->page->toplevel;
+
   if (toplevel == NULL) {
     return;
   }
@@ -994,19 +1006,26 @@ o_emit_pre_change_notify (TOPLEVEL *toplevel, OBJECT *object)
 
 /*! \brief Emit an object change notification.
  * \par Function Description
- * Calls each change callback function registered with #TOPLEVEL to
- * notify listeners that \a object has just been modified.  All
- * libgeda functions that modify #OBJECT structures should call this
- * just after making a change to an #OBJECT.
  *
- * \param toplevel #TOPLEVEL structure to emit notifications from.
+ * Calls each change callback function registered with \a object's
+ * #TOPLEVEL to notify listeners that \a object has just been
+ * modified.  All liblepton functions that modify #OBJECT
+ * structures should call this just after making a change to an
+ * #OBJECT.
+ *
  * \param object   #OBJECT structure to emit notifications for.
  */
 void
-o_emit_change_notify (TOPLEVEL *toplevel, OBJECT *object)
+o_emit_change_notify (OBJECT *object)
 {
   GList *iter;
 
+  if (object->page == NULL) {
+    return;
+  }
+
+  TOPLEVEL *toplevel = object->page->toplevel;
+
   if (toplevel == NULL) {
     return;
   }
@@ -1027,12 +1046,11 @@ o_emit_change_notify (TOPLEVEL *toplevel, OBJECT *object)
  *  \par Function Description
  *  Attribute getter for the visible field within the object.
  *
- *  \param toplevel The TOPLEVEL structure
  *  \param object   The OBJECT structure to be queried
  *  \return TRUE when VISIBLE, FALSE otherwise
  */
 gboolean
-o_is_visible (const TOPLEVEL *toplevel, const OBJECT *object)
+o_is_visible (const OBJECT *object)
 {
   g_return_val_if_fail (object != NULL, FALSE);
   return object->visibility == VISIBLE;
@@ -1052,16 +1070,12 @@ geda_object_get_visible (const GedaObject *object)
 }
 
 /*! \brief Set visibility of the object.
- *  \par Function Description
- *  Set value of visibility field within the object.
- *  If resulting visibility value is changed,
- *  invalidate the bounds of the object and parent objects.
  *
- *  \param toplevel The #TOPLEVEL structure
- *  \param object   The #OBJECT structure to be modified
+ *  \param object     The #OBJECT structure to be modified
+ *  \param visibility If the object should be visible
  */
 void
-o_set_visibility (TOPLEVEL *toplevel, OBJECT *object, int visibility)
+o_set_visibility (OBJECT *object, int visibility)
 {
   g_return_if_fail (object != NULL);
   object->visibility = visibility;
@@ -1094,7 +1108,7 @@ geda_object_calculate_visible_bounds (TOPLEVEL *toplevel,
   /* only do bounding boxes for visible or doing show_hidden_text*/
   /* you might lose some attrs though */
   if (o_current->type == OBJ_TEXT &&
-      ! (o_is_visible (toplevel, o_current) || toplevel->show_hidden_text)) {
+      ! (o_is_visible (o_current) || toplevel->show_hidden_text)) {
     return 0;
   }
 
@@ -1106,28 +1120,28 @@ geda_object_calculate_visible_bounds (TOPLEVEL *toplevel,
     if (o_current->line == NULL) {
       return 0;
     }
-    geda_line_object_calculate_bounds (toplevel, o_current, &bounds);
+    geda_line_object_calculate_bounds (o_current, &bounds);
     break;
 
   case(OBJ_NET):
     if (o_current->line == NULL) {
       return 0;
     }
-    geda_net_object_calculate_bounds (toplevel, o_current, &bounds);
+    geda_net_object_calculate_bounds (o_current, &bounds);
     break;
 
   case(OBJ_BUS):
     if (o_current->line == NULL) {
       return 0;
     }
-    geda_bus_object_calculate_bounds(toplevel, o_current, &bounds);
+    geda_bus_object_calculate_bounds (o_current, &bounds);
     break;
 
   case(OBJ_BOX):
     if (o_current->box == NULL) {
       return 0;
     }
-    geda_box_object_calculate_bounds (toplevel, o_current, &bounds);
+    geda_box_object_calculate_bounds (o_current, &bounds);
     break;
 
   case(OBJ_PATH):
@@ -1135,7 +1149,7 @@ geda_object_calculate_visible_bounds (TOPLEVEL *toplevel,
     if (o_current->path->num_sections <= 0) {
       return 0;
     }
-    geda_path_object_calculate_bounds (toplevel, o_current, &bounds);
+    geda_path_object_calculate_bounds (o_current, &bounds);
     break;
 
   case(OBJ_PICTURE):
@@ -1149,7 +1163,7 @@ geda_object_calculate_visible_bounds (TOPLEVEL *toplevel,
     if (o_current->circle == NULL) {
       return 0;
     }
-    geda_circle_object_calculate_bounds (toplevel, o_current, &bounds);
+    geda_circle_object_calculate_bounds (o_current, &bounds);
     break;
 
   case(OBJ_COMPONENT):
@@ -1168,14 +1182,14 @@ geda_object_calculate_visible_bounds (TOPLEVEL *toplevel,
     if (o_current->line == NULL) {
       return 0;
     }
-    geda_pin_object_calculate_bounds (toplevel, o_current, &bounds);
+    geda_pin_object_calculate_bounds (o_current, &bounds);
     break;
 
   case(OBJ_ARC):
     if (o_current->arc == NULL) {
       return 0;
     }
-    geda_arc_object_calculate_bounds (toplevel, o_current,
+    geda_arc_object_calculate_bounds (o_current,
                                       &bounds.min_x,
                                       &bounds.min_y,
                                       &bounds.max_x,
diff --git a/liblepton/src/geda_object_list.c b/liblepton/src/geda_object_list.c
index 9767f89f4..7df632a64 100644
--- a/liblepton/src/geda_object_list.c
+++ b/liblepton/src/geda_object_list.c
@@ -48,14 +48,13 @@ extern int global_sid;
  *  objects are unselected before they are copied and then reselected
  *  this is necessary to preserve the color info
  *
- *  \param [in] toplevel       The TOPLEVEL object.
  *  \param [in] src_list       The GList to copy from.
  *  \param [in] dest_list      The GList to copy to.
  *  \return the dest_list GList with objects appended to it.
  */
-GList *o_glist_copy_all (TOPLEVEL *toplevel,
-                         const GList *src_list,
-                         GList *dest_list)
+GList*
+o_glist_copy_all (const GList *src_list,
+                  GList *dest_list)
 {
   const GList *src;
   GList *dest;
@@ -77,17 +76,17 @@ GList *o_glist_copy_all (TOPLEVEL *toplevel,
     /* unselect the object before the copy */
     selected_save = src_object->selected;
     if (selected_save)
-      o_selection_unselect (toplevel, src_object);
+      o_selection_unselect (src_object);
 
     if (src_object->type != OBJ_TEXT) {
-      dst_object = o_object_copy (toplevel, src_object);
+      dst_object = o_object_copy (src_object);
       dst_object->sid = global_sid++;
       dest = g_list_prepend (dest, dst_object);
     }
 
     /* reselect it */
     if (selected_save)
-      o_selection_select (toplevel, src_object);
+      o_selection_select (src_object);
 
     src = g_list_next(src);
   }
@@ -101,27 +100,28 @@ GList *o_glist_copy_all (TOPLEVEL *toplevel,
     /* unselect the object before the copy */
     selected_save = src_object->selected;
     if (selected_save)
-      o_selection_unselect (toplevel, src_object);
+      o_selection_unselect (src_object);
 
     if (src_object->type == OBJ_TEXT) {
-      dst_object = o_object_copy (toplevel, src_object);
+      dst_object = o_object_copy (src_object);
       dst_object->sid = global_sid++;
       dest = g_list_prepend (dest, dst_object);
 
       if (src_object->attached_to != NULL &&
           src_object->attached_to->copied_to != NULL) {
-        o_attrib_attach(toplevel, dst_object,
-                        src_object->attached_to->copied_to, FALSE);
+        o_attrib_attach (dst_object,
+                         src_object->attached_to->copied_to,
+                         FALSE);
         /* handle slot= attribute, it's a special case */
         if (g_ascii_strncasecmp (geda_text_object_get_string (dst_object),
                                  "slot=", 5) == 0)
-          s_slot_update_object (toplevel, src_object->attached_to->copied_to);
+          s_slot_update_object (src_object->attached_to->copied_to);
       }
     }
 
     /* reselect it */
     if (selected_save)
-      o_selection_select (toplevel, src_object);
+      o_selection_select (src_object);
 
     src = g_list_next(src);
   }
@@ -144,11 +144,10 @@ GList *o_glist_copy_all (TOPLEVEL *toplevel,
  *
  *  This function deletes everything, including the GList.
  *
- *  \param [in] toplevel The toplevel object.
  *  \param [in] objects A GList of objects to delete.
  */
 void
-geda_object_list_delete (TOPLEVEL *toplevel, GList *objects)
+geda_object_list_delete (GList *objects)
 {
   OBJECT *o_current=NULL;
   GList *ptr;
@@ -158,7 +157,7 @@ geda_object_list_delete (TOPLEVEL *toplevel, GList *objects)
   /* do the delete backwards */
   while(ptr != NULL) {
     o_current = (OBJECT *) ptr->data;
-    s_delete_object(toplevel, o_current);
+    s_delete_object (o_current);
     ptr = g_list_previous (ptr);
   }
   g_list_free(objects);
@@ -220,17 +219,16 @@ geda_object_list_translate (const GList *objects, int dx, int dy)
  *  \param [in]     x        The x center of rotation.
  *  \param [in]     y        The y center of rotation.
  *  \param [in]     angle    The angle rotation in multiples of 90 degrees.
- *  \param [in]     toplevel The toplevel object. (used for change notification)
  */
 void
-geda_object_list_rotate (const GList *objects, int x, int y, int angle, TOPLEVEL *toplevel)
+geda_object_list_rotate (const GList *objects, int x, int y, int angle)
 {
   const GList *iter = objects;
 
   while (iter != NULL) {
     GedaObject *object = (GedaObject*)iter->data;
 
-    geda_object_rotate (toplevel, x, y, angle, object);
+    geda_object_rotate (x, y, angle, object);
     iter = g_list_next (iter);
   }
 }
@@ -240,17 +238,16 @@ geda_object_list_rotate (const GList *objects, int x, int y, int angle, TOPLEVEL
  *  \param [in,out] objects  A GList of objects to mirror.
  *  \param [in]     x        The x center of mirroring
  *  \param [in]     y        Unused, essentially
- *  \param [in]     toplevel The toplevel object. (used for change notification)
  */
 void
-geda_object_list_mirror (const GList *objects, int x, int y, TOPLEVEL *toplevel)
+geda_object_list_mirror (const GList *objects, int x, int y)
 {
   const GList *iter = objects;
 
   while (iter != NULL) {
     GedaObject *object = (GedaObject*)iter->data;
 
-    geda_object_mirror (toplevel, x, y, object);
+    geda_object_mirror (x, y, object);
     iter = g_list_next (iter);
   }
 }
@@ -260,17 +257,17 @@ geda_object_list_mirror (const GList *objects, int x, int y, TOPLEVEL *toplevel)
  *
  *  \param [in,out] objects  A GList of objects to mirror.
  *  \param [in]     color    The new color.
- *  \param [in]     toplevel The toplevel object. (used for change notification)
  */
 void
-geda_object_list_set_color (const GList *objects, int color, TOPLEVEL *toplevel)
+geda_object_list_set_color (const GList *objects,
+                            int color)
 {
   const GList *iter = objects;
 
   while (iter != NULL) {
     GedaObject *object = (GedaObject*)iter->data;
 
-    o_set_color (toplevel, object, color);
+    o_set_color (object, color);
     iter = g_list_next (iter);
   }
 }
@@ -299,7 +296,6 @@ geda_object_list_set_selectable (const GList *objects, gboolean selectable)
  *  format. The buffer should be freed when no longer needed.
  *
  *  \param [in] objects The head of a GList of OBJECTs to save.
- *  \param [in] toplevel The current TOPLEVEL.
  *  \returns a buffer containing schematic data or NULL on failure.
  */
 gchar*
@@ -347,7 +343,6 @@ static const gchar
  *  we recurse for saving out those attributes, the function must be called
  *  with save_attribs passed as TRUE.
  *
- *  \param [in] toplevel      A TOPLEVEL structure.
  *  \param [in] object_list   The head of a GList of objects to save.
  *  \param [in] save_attribs  Should attribute objects encounterd be saved?
  *  \returns a buffer containing schematic data or NULL on failure.
diff --git a/liblepton/src/geda_page.c b/liblepton/src/geda_page.c
index ce136d397..51dc38c67 100644
--- a/liblepton/src/geda_page.c
+++ b/liblepton/src/geda_page.c
@@ -57,7 +57,7 @@ static gint global_pid = 0;
 /* Called just before removing an OBJECT from a PAGE
  * or after appending an OBJECT to a PAGE. */
 static void
-object_added (TOPLEVEL *toplevel, PAGE *page, OBJECT *object)
+object_added (PAGE *page, OBJECT *object)
 {
   /* Set up object parent pointer */
 #ifndef NDEBUG
@@ -70,14 +70,14 @@ object_added (TOPLEVEL *toplevel, PAGE *page, OBJECT *object)
   /* Update object connection tracking */
   s_conn_update_object (page, object);
 
-  o_emit_change_notify (toplevel, object);
+  o_emit_change_notify (object);
 }
 
 /* Called just before removing an OBJECT from a PAGE. */
 static void
-pre_object_removed (TOPLEVEL *toplevel, PAGE *page, OBJECT *object)
+pre_object_removed (PAGE *page, OBJECT *object)
 {
-  o_emit_pre_change_notify (toplevel, object);
+  o_emit_pre_change_notify (object);
 
   /* Remove object from the list of connectible objects */
   s_conn_remove_object (page, object);
@@ -96,7 +96,7 @@ pre_object_removed (TOPLEVEL *toplevel, PAGE *page, OBJECT *object)
   }
 
   /* Remove object from connection system */
-  s_conn_remove_object_connections (toplevel, object);
+  s_conn_remove_object_connections (object);
 }
 
 /*! \brief create a new page object
@@ -218,10 +218,10 @@ void s_page_delete (TOPLEVEL *toplevel, PAGE *page)
   g_object_unref( page->selection_list );
 
   /* then delete objects of page */
-  s_page_delete_objects (toplevel, page);
+  s_page_delete_objects (page);
 
   /* Free the objects in the place list. */
-  geda_object_list_delete (toplevel, page->place_list);
+  geda_object_list_delete (page->place_list);
   page->place_list = NULL;
 
   /*  This removes all objects from the list of connectible objects
@@ -236,7 +236,7 @@ void s_page_delete (TOPLEVEL *toplevel, PAGE *page)
   page->connectible_list = NULL;
 
   /* free current page undo structs */
-  s_undo_free_all (toplevel, page);
+  s_undo_free_all (page);
 
   /* ouch, deal with parents going away and the children still around */
   page->up = -2;
@@ -527,8 +527,7 @@ gint s_page_save_all (TOPLEVEL *toplevel)
 
     p_current = (PAGE *)iter->data;
 
-    if (f_save (toplevel, p_current,
-                s_page_get_filename (p_current), NULL)) {
+    if (f_save (p_current, s_page_get_filename (p_current), NULL)) {
       s_log_message (_("Saved [%1$s]"),
                      s_page_get_filename (p_current));
       /* reset the CHANGED flag of p_current */
@@ -659,14 +658,15 @@ gint s_page_autosave (TOPLEVEL *toplevel)
  *  Links the passed OBJECT to the end of the PAGE's
  *  linked list of objects.
  *
- *  \param [in] toplevel  The TOPLEVEL object.
  *  \param [in] page      The PAGE the object is being added to.
  *  \param [in] object    The OBJECT being added to the page.
  */
-void s_page_append (TOPLEVEL *toplevel, PAGE *page, OBJECT *object)
+void
+s_page_append (PAGE *page,
+               OBJECT *object)
 {
   page->_object_list = g_list_append (page->_object_list, object);
-  object_added (toplevel, page, object);
+  object_added (page, object);
 }
 
 /*! \brief Append a GList of OBJECTs to the PAGE
@@ -675,16 +675,17 @@ void s_page_append (TOPLEVEL *toplevel, PAGE *page, OBJECT *object)
  *  Links the passed OBJECT GList to the end of the PAGE's
  *  object_list.
  *
- *  \param [in] toplevel  The TOPLEVEL object.
  *  \param [in] page      The PAGE the objects are being added to.
  *  \param [in] obj_list  The OBJECT list being added to the page.
  */
-void s_page_append_list (TOPLEVEL *toplevel, PAGE *page, GList *obj_list)
+void
+s_page_append_list (PAGE *page,
+                    GList *obj_list)
 {
   GList *iter;
   page->_object_list = g_list_concat (page->_object_list, obj_list);
   for (iter = obj_list; iter != NULL; iter = g_list_next (iter)) {
-    object_added (toplevel, page, (OBJECT*) iter->data);
+    object_added (page, (OBJECT*) iter->data);
   }
 }
 
@@ -694,13 +695,14 @@ void s_page_append_list (TOPLEVEL *toplevel, PAGE *page, GList *obj_list)
  *  Removes the passed OBJECT from the PAGE's
  *  linked list of objects.
  *
- *  \param [in] toplevel  The TOPLEVEL object.
  *  \param [in] page      The PAGE the object is being removed from.
  *  \param [in] object    The OBJECT being removed from the page.
  */
-void s_page_remove (TOPLEVEL *toplevel, PAGE *page, OBJECT *object)
+void
+s_page_remove (PAGE *page,
+               OBJECT *object)
 {
-  pre_object_removed (toplevel, page, object);
+  pre_object_removed (page, object);
   page->_object_list = g_list_remove (page->_object_list, object);
 }
 
@@ -711,45 +713,42 @@ void s_page_remove (TOPLEVEL *toplevel, PAGE *page, OBJECT *object)
  * \a object2 in the position thus vacated. If \a object1 is not in \a
  * page, object2 is appended to \a page.
  *
- * \param [in] toplevel  The TOPLEVEL object.
  * \param [in] page      The PAGE to be modified.
  * \param [in] object1   The OBJECT being removed from the page.
  * \param [in] object2   The OBJECT being added to the page.
  */
 void
-s_page_replace (TOPLEVEL *toplevel, PAGE *page,
-                OBJECT *object1, OBJECT *object2)
+s_page_replace (PAGE *page,
+                OBJECT *object1,
+                OBJECT *object2)
 {
   GList *iter = g_list_find (page->_object_list, object1);
 
   /* If object1 not found, append object2 */
   if (iter == NULL) {
-    s_page_append (toplevel, page, object2);
+    s_page_append (page, object2);
     return;
   }
 
-  pre_object_removed (toplevel, page, object1);
+  pre_object_removed (page, object1);
   iter->data = object2;
-  object_added (toplevel, page, object2);
+  object_added (page, object2);
 }
 
 /*! \brief Remove and free all OBJECTs from the PAGE
  *
- *  \par Function Description
- *  Removes and frees all OBJECTs from the PAGE.
- *
- *  \param [in] toplevel  The TOPLEVEL object.
  *  \param [in] page      The PAGE being cleared.
  */
-void s_page_delete_objects (TOPLEVEL *toplevel, PAGE *page)
+void
+s_page_delete_objects (PAGE *page)
 {
   GList *objects = page->_object_list;
   GList *iter;
   for (iter = objects; iter != NULL; iter = g_list_next (iter)) {
-    pre_object_removed (toplevel, page, (OBJECT*) iter->data);
+    pre_object_removed (page, (OBJECT*) iter->data);
   }
   page->_object_list = NULL;
-  geda_object_list_delete (toplevel, objects);
+  geda_object_list_delete (objects);
 }
 
 
diff --git a/liblepton/src/geda_path_object.c b/liblepton/src/geda_path_object.c
index fe33bacbd..e4668a3c3 100644
--- a/liblepton/src/geda_path_object.c
+++ b/liblepton/src/geda_path_object.c
@@ -60,16 +60,17 @@ typedef void (*FILL_FUNC) (TOPLEVEL *toplevel, FILE *fp, PATH *path,
  *  The object is added to the end of the list described by the
  *  <B>object_list</B> parameter by the #s_basic_link_object().
  *
- *  \param [in]     toplevel     The TOPLEVEL object.
  *  \param [in]     type         Must be OBJ_PATH.
  *  \param [in]     color        The path color.
  *  \param [in]     path_string  The string representation of the path
  *  \return A pointer to the new end of the object list.
  */
-OBJECT *geda_path_object_new (TOPLEVEL *toplevel,
-                              char type, int color, const char *path_string)
+OBJECT*
+geda_path_object_new (char type,
+                      int color,
+                      const char *path_string)
 {
-  return geda_path_object_new_take_path (toplevel, type, color,
+  return geda_path_object_new_take_path (type, color,
                                          s_path_parse (path_string));
 }
 
@@ -82,15 +83,15 @@ OBJECT *geda_path_object_new (TOPLEVEL *toplevel,
  *
  *  \see geda_path_object_new().
  *
- *  \param [in]     toplevel     The TOPLEVEL object.
  *  \param [in]     type         Must be OBJ_PATH.
  *  \param [in]     color        The path color.
  *  \param [in]     path_data    The #PATH data structure to use.
  *  \return A pointer to the new end of the object list.
  */
 OBJECT*
-geda_path_object_new_take_path (TOPLEVEL *toplevel,
-                                char type, int color, PATH *path_data)
+geda_path_object_new_take_path (char type,
+                                int color,
+                                PATH *path_data)
 {
   OBJECT *new_node;
 
@@ -101,15 +102,14 @@ geda_path_object_new_take_path (TOPLEVEL *toplevel,
   new_node->path  = path_data;
 
   /* path type and filling initialized to default */
-  o_set_line_options (toplevel,
-                      new_node,
+  o_set_line_options (new_node,
                       DEFAULT_OBJECT_END,
                       TYPE_SOLID,
                       LINE_WIDTH,
                       -1,
                       -1);
 
-  o_set_fill_options (toplevel, new_node,
+  o_set_fill_options (new_node,
                       FILLING_HOLLOW, -1, -1, -1, -1, -1);
 
   return new_node;
@@ -123,25 +123,24 @@ geda_path_object_new_take_path (TOPLEVEL *toplevel,
  *  is added at the end of the list following the <B>list_tail</B>
  *  parameter.
  *
- *  \param [in]  toplevel  The TOPLEVEL object.
  *  \param [in]  o_current  Line OBJECT to copy.
  *  \return A new pointer to the end of the object list.
  */
 OBJECT*
-geda_path_object_copy (TOPLEVEL *toplevel, OBJECT *o_current)
+geda_path_object_copy (OBJECT *o_current)
 {
   OBJECT *new_obj;
   char *path_string;
 
   path_string = s_path_string_from_path (o_current->path);
-  new_obj = geda_path_object_new (toplevel, OBJ_PATH, o_current->color, path_string);
+  new_obj = geda_path_object_new (OBJ_PATH, o_current->color, path_string);
   g_free (path_string);
 
   /* copy the path type and filling options */
-  o_set_line_options (toplevel, new_obj, o_current->line_end,
+  o_set_line_options (new_obj, o_current->line_end,
                       o_current->line_type, o_current->line_width,
                       o_current->line_length, o_current->line_space);
-  o_set_fill_options (toplevel, new_obj,
+  o_set_fill_options (new_obj,
                       o_current->fill_type, o_current->fill_width,
                       o_current->fill_pitch1, o_current->fill_angle1,
                       o_current->fill_pitch2, o_current->fill_angle2);
@@ -164,16 +163,18 @@ geda_path_object_copy (TOPLEVEL *toplevel, OBJECT *o_current)
  *    <DT>*</DT><DD>the file format used for the releases after 20010704.
  *  </DL>
  *
- *  \param [in]  toplevel       The TOPLEVEL object.
  *  \param [in]  first_line      Character string with path description.
  *  \param [in]  tb              Text buffer containing the path string.
  *  \param [in]  release_ver     libgeda release version number.
  *  \param [in]  fileformat_ver  libgeda file format version number.
  *  \return A pointer to the new path object, or NULL on error;
  */
-OBJECT *o_path_read (TOPLEVEL *toplevel,
-                     const char *first_line, TextBuffer *tb,
-                     unsigned int release_ver, unsigned int fileformat_ver, GError **err)
+OBJECT*
+o_path_read (const char *first_line,
+             TextBuffer *tb,
+             unsigned int release_ver,
+             unsigned int fileformat_ver,
+             GError **err)
 {
   OBJECT *new_obj;
   char type;
@@ -235,20 +236,18 @@ OBJECT *o_path_read (TOPLEVEL *toplevel,
   string = geda_string_remove_ending_newline (string);
 
   /* create a new path */
-  new_obj = geda_path_object_new (toplevel, type, color, string);
+  new_obj = geda_path_object_new (type, color, string);
   g_free (string);
 
   /* set its line options */
-  o_set_line_options (toplevel,
-                      new_obj,
+  o_set_line_options (new_obj,
                       (OBJECT_END) line_end,
                       (OBJECT_TYPE) line_type,
                       line_width,
                       line_length,
                       line_space);
   /* set its fill options */
-  o_set_fill_options (toplevel,
-                      new_obj,
+  o_set_fill_options (new_obj,
                       (OBJECT_FILLING) fill_type,
                       fill_width,
                       pitch1,
@@ -321,21 +320,22 @@ geda_path_object_to_buffer (const GedaObject *object)
  *
  *  The new position is given by <B>x</B> and <B>y</B>.
  *
- *  \param [in]     toplevel  The TOPLEVEL object.
  *  \param [in,out] object    The path OBJECT
  *  \param [in]     x         New x coordinate for the control point
  *  \param [in]     y         New y coordinate for the control point
  *  \param [in]     whichone  Which control point is being modified
  */
 void
-geda_path_object_modify (TOPLEVEL *toplevel, OBJECT *object,
-                         int x, int y, int whichone)
+geda_path_object_modify (OBJECT *object,
+                         int x,
+                         int y,
+                         int whichone)
 {
   int i;
   int grip_no = 0;
   PATH_SECTION *section;
 
-  o_emit_pre_change_notify (toplevel, object);
+  o_emit_pre_change_notify (object);
 
   for (i = 0; i <  object->path->num_sections; i++) {
     section = &object->path->sections[i];
@@ -366,7 +366,7 @@ geda_path_object_modify (TOPLEVEL *toplevel, OBJECT *object,
     }
   }
 
-  o_emit_change_notify (toplevel, object);
+  o_emit_change_notify (object);
 }
 
 
@@ -419,15 +419,16 @@ geda_path_object_translate (GedaObject *object, int dx, int dy)
  *  point by <B>angle</B> degrees.
  *  The center of rotation is in world units.
  *
- *  \param [in]      toplevel      The TOPLEVEL object.
  *  \param [in]      world_centerx  Rotation center x coordinate in WORLD units.
  *  \param [in]      world_centery  Rotation center y coordinate in WORLD units.
  *  \param [in]      angle          Rotation angle in degrees (See note below).
  *  \param [in,out]  object         Line OBJECT to rotate.
  */
-void geda_path_object_rotate (TOPLEVEL *toplevel,
-                          int world_centerx, int world_centery, int angle,
-                          OBJECT *object)
+void
+geda_path_object_rotate (int world_centerx,
+                         int world_centery,
+                         int angle,
+                         OBJECT *object)
 {
   PATH_SECTION *section;
   int i;
@@ -469,13 +470,14 @@ void geda_path_object_rotate (TOPLEVEL *toplevel,
  *  This function mirrors the path from the point
  *  (<B>world_centerx</B>,<B>world_centery</B>) in world unit.
  *
- *  \param [in]     toplevel      The TOPLEVEL object.
  *  \param [in]     world_centerx  Origin x coordinate in WORLD units.
  *  \param [in]     world_centery  Origin y coordinate in WORLD units.
  *  \param [in,out] object         Line OBJECT to mirror.
  */
-void geda_path_object_mirror (TOPLEVEL *toplevel, int world_centerx,
-                          int world_centery, OBJECT *object)
+void
+geda_path_object_mirror (int world_centerx,
+                         int world_centery,
+                         OBJECT *object)
 {
   PATH_SECTION *section;
   int i;
@@ -510,13 +512,11 @@ void geda_path_object_mirror (TOPLEVEL *toplevel, int world_centerx,
  *
  *  On failure, this function sets the bounds to empty.
  *
- *  \param [in]  toplevel  Unused
  *  \param [in]  object    The path to calculate bounds of.
  *  \param [out] bounds    The bounds of the path
  */
 void
-geda_path_object_calculate_bounds (TOPLEVEL *toplevel,
-                                   const OBJECT *object,
+geda_path_object_calculate_bounds (const OBJECT *object,
                                    GedaBounds *bounds)
 {
   gint expand;
diff --git a/liblepton/src/geda_picture_object.c b/liblepton/src/geda_picture_object.c
index 12fcdd6ef..d7a315260 100644
--- a/liblepton/src/geda_picture_object.c
+++ b/liblepton/src/geda_picture_object.c
@@ -337,19 +337,18 @@ static const char* fallback_xpm[] = {
  *  Parses \a first_line and subsequent lines from \a tb, and returns
  *  a newly-created picture #OBJECT.
  *
- *  \param [in]  toplevel       The TOPLEVEL object.
  *  \param [in]  first_line      Character string with picture description.
  *  \param [in]  tb              Text buffer to load embedded data from.
  *  \param [in]  release_ver     libgeda release version number.
  *  \param [in]  fileformat_ver  libgeda file format version number.
  *  \return A pointer to the new picture object, or NULL on error.
  */
-OBJECT *o_picture_read (TOPLEVEL *toplevel,
-                        const char *first_line,
-                        TextBuffer *tb,
-                        unsigned int release_ver,
-                        unsigned int fileformat_ver,
-                        GError **err)
+OBJECT*
+o_picture_read (const char *first_line,
+                TextBuffer *tb,
+                unsigned int release_ver,
+                unsigned int fileformat_ver,
+                GError **err)
 {
   OBJECT *new_obj;
   int x1, y1;
@@ -451,7 +450,7 @@ OBJECT *o_picture_read (TOPLEVEL *toplevel,
 
   /* create the picture */
   /* The picture is described by its upper left and lower right corner */
-  new_obj = o_picture_new (toplevel, file_content, file_length, filename,
+  new_obj = o_picture_new (file_content, file_length, filename,
                            type,
                            x1, y1+height, x1+width, y1,
                            angle, mirrored, embedded);
@@ -554,7 +553,6 @@ geda_picture_object_to_buffer (const GedaObject *object)
  *  attempt to be loaded from \a filename.  Otherwise, the picture
  *  object will be initially empty.
  *
- *  \param [in]     toplevel      The TOPLEVEL object.
  *  \param [in]     file_content  Raw data of the image file, or NULL.
  *  \param [in]     file_length   Length of raw data buffer
  *  \param [in]     filename      File name backing this picture, or NULL.
@@ -568,11 +566,17 @@ geda_picture_object_to_buffer (const GedaObject *object)
  *  \param [in]     embedded      Whether the embedded flag should be set or not.
  *  \return A pointer to a new picture #OBJECT.
  */
-OBJECT *o_picture_new (TOPLEVEL *toplevel,
-                       const gchar *file_content, gsize file_length,
+OBJECT *o_picture_new (const gchar *file_content,
+                       gsize file_length,
                        const gchar *filename,
-                       char type, int x1, int y1, int x2, int y2, int angle,
-                       int mirrored, int embedded)
+                       char type,
+                       int x1,
+                       int y1,
+                       int x2,
+                       int y2,
+                       int angle,
+                       int mirrored,
+                       int embedded)
 {
   OBJECT *new_node;
   PICTURE *picture;
@@ -601,7 +605,7 @@ OBJECT *o_picture_new (TOPLEVEL *toplevel,
 
   if (file_content != NULL) {
     GError *error = NULL;
-    if (!o_picture_set_from_buffer (toplevel, new_node, filename,
+    if (!o_picture_set_from_buffer (new_node, filename,
                                     file_content, file_length, &error)) {
       s_log_message (_("Failed to load buffer image [%1$s]: %2$s"),
                      filename, error->message);
@@ -615,12 +619,12 @@ OBJECT *o_picture_new (TOPLEVEL *toplevel,
   }
   if (picture->pixbuf == NULL && filename != NULL) {
     GError *error = NULL;
-    if (!o_picture_set_from_file (toplevel, new_node, filename, &error)) {
+    if (!o_picture_set_from_file (new_node, filename, &error)) {
       s_log_message (_("Failed to load image from [%1$s]: %2$s"),
                      filename, error->message);
       g_error_free (error);
       /* picture not found; try to open a fall back pixbuf */
-      picture->pixbuf = o_picture_get_fallback_pixbuf(toplevel);
+      picture->pixbuf = o_picture_get_fallback_pixbuf ();
     }
   }
 
@@ -719,7 +723,6 @@ o_picture_get_ratio (OBJECT *object)
  *  The coordinates of the corner is modified in the world coordinate system.
  *  Screen coordinates and boundings are then updated.
  *
- *  \param [in]     toplevel  The TOPLEVEL object.
  *  \param [in,out] object     Picture OBJECT to modify.
  *  \param [in]     x          New x coordinate.
  *  \param [in]     y          New y coordinate.
@@ -733,13 +736,16 @@ o_picture_get_ratio (OBJECT *object)
  *    <DT>*</DT><DD>PICTURE_LOWER_RIGHT
  *  </DL>
  */
-void o_picture_modify(TOPLEVEL *toplevel, OBJECT *object,
-                      int x, int y, int whichone)
+void
+o_picture_modify (OBJECT *object,
+                  int x,
+                  int y,
+                  int whichone)
 {
   int tmp;
   double ratio = o_picture_get_ratio (object);
 
-  o_emit_pre_change_notify (toplevel, object);
+  o_emit_pre_change_notify (object);
 
   /* change the position of the selected corner */
   switch(whichone) {
@@ -796,7 +802,7 @@ void o_picture_modify(TOPLEVEL *toplevel, OBJECT *object,
     object->picture->lower_y = tmp;
   }
 
-  o_emit_change_notify (toplevel, object);
+  o_emit_change_notify (object);
 }
 
 /*! \brief Modify a picture object's coordinates.
@@ -806,7 +812,6 @@ void o_picture_modify(TOPLEVEL *toplevel, OBJECT *object,
  * the points (\a x1, \a y1) and (\a x2, \a y2), and scaled as large
  * as possible to still fit within that rectangle.
  *
- * \param [in]     toplevel current #TOPLEVEL.
  * \param [in,out] object   picture #OBJECT to be modified.
  * \param [in]     x1       x coordinate of first corner of box.
  * \param [in]     y1       y coordinate of first corner of box.
@@ -814,10 +819,13 @@ void o_picture_modify(TOPLEVEL *toplevel, OBJECT *object,
  * \param [in]     y2       y coordinate of second corner of box.
  */
 void
-o_picture_modify_all (TOPLEVEL *toplevel, OBJECT *object,
-                      int x1, int y1, int x2, int y2)
+o_picture_modify_all (OBJECT *object,
+                      int x1,
+                      int y1,
+                      int x2,
+                      int y2)
 {
-  o_emit_pre_change_notify (toplevel, object);
+  o_emit_pre_change_notify (object);
 
   /* Normalise the requested rectangle. */
   object->picture->lower_x = (x1 > x2) ? x1 : x2;
@@ -825,7 +833,7 @@ o_picture_modify_all (TOPLEVEL *toplevel, OBJECT *object,
   object->picture->upper_x = (x1 > x2) ? x2 : x1;
   object->picture->upper_y = (y1 > y2) ? y1 : y2;
 
-  o_emit_change_notify (toplevel, object);
+  o_emit_change_notify (object);
 }
 
 /*! \brief Rotate picture OBJECT using WORLD coordinates.
@@ -835,7 +843,6 @@ o_picture_modify_all (TOPLEVEL *toplevel, OBJECT *object,
  *  degrees.
  *  The center of rotation is in world units.
  *
- *  \param [in]      toplevel      The TOPLEVEL object.
  *  \param [in]      world_centerx  Rotation center x coordinate in
  *                                  WORLD units.
  *  \param [in]      world_centery  Rotation center y coordinate in
@@ -843,8 +850,10 @@ o_picture_modify_all (TOPLEVEL *toplevel, OBJECT *object,
  *  \param [in]      angle          Rotation angle in degrees (See note below).
  *  \param [in,out]  object         Picture OBJECT to rotate.
  */
-void geda_picture_object_rotate (TOPLEVEL *toplevel,
-                            int world_centerx, int world_centery, int angle,
+void
+geda_picture_object_rotate (int world_centerx,
+                            int world_centery,
+                            int angle,
                             OBJECT *object)
 {
   int newx1, newy1;
@@ -902,13 +911,13 @@ void geda_picture_object_rotate (TOPLEVEL *toplevel,
  *  The picture is first translated to the origin, then mirrored and
  *  finally translated back at its previous position.
  *
- *  \param [in]     toplevel      The TOPLEVEL object.
  *  \param [in]     world_centerx  Origin x coordinate in WORLD units.
  *  \param [in]     world_centery  Origin y coordinate in WORLD units.
  *  \param [in,out] object         Picture OBJECT to mirror.
  */
-void geda_picture_object_mirror(TOPLEVEL *toplevel,
-                            int world_centerx, int world_centery,
+void
+geda_picture_object_mirror (int world_centerx,
+                            int world_centery,
                             OBJECT *object)
 {
   int newx1, newy1;
@@ -983,11 +992,11 @@ geda_picture_object_translate (GedaObject *object, int dx, int dy)
  *  This function creates a verbatim copy of the object pointed by
  *  <B>o_current</B> describing a picture.
  *
- *  \param [in]  toplevel   The TOPLEVEL object.
  *  \param [in]  object     Picture OBJECT to copy.
  *  \return The new OBJECT
  */
-OBJECT *o_picture_copy(TOPLEVEL *toplevel, OBJECT *object)
+OBJECT*
+o_picture_copy (OBJECT *object)
 {
   OBJECT *new_node;
   PICTURE *picture;
@@ -1022,7 +1031,7 @@ OBJECT *o_picture_copy(TOPLEVEL *toplevel, OBJECT *object)
   picture->embedded    = object->picture->embedded;
 
   /* Get the picture data */
-  picture->pixbuf = o_picture_get_pixbuf (toplevel, object);
+  picture->pixbuf = o_picture_get_pixbuf (object);
 
   return new_node;
 }
@@ -1032,10 +1041,10 @@ OBJECT *o_picture_copy(TOPLEVEL *toplevel, OBJECT *object)
  * Verify that a picture has valid data associated with it, and if so,
  * mark it to be embedded.
  *
- *  \param [in]     toplevel     The TOPLEVEL object.
  *  \param [in]     object       The picture OBJECT to embed
  */
-void o_picture_embed (TOPLEVEL *toplevel, OBJECT *object)
+void
+o_picture_embed (OBJECT *object)
 {
   const gchar *filename = o_picture_get_filename (object);
   gchar *basename;
@@ -1062,10 +1071,10 @@ void o_picture_embed (TOPLEVEL *toplevel, OBJECT *object)
  * Verify that the file associated with \a object exists on disk and
  * is usable, and if so, reload the picture and mark it as unembedded.
  *
- *  \param [in]     toplevel     The TOPLEVEL object.
  *  \param [in]     object       The picture OBJECT to unembed
  */
-void o_picture_unembed (TOPLEVEL *toplevel, OBJECT *object)
+void
+o_picture_unembed (OBJECT *object)
 {
   GError *err = NULL;
   const gchar *filename = o_picture_get_filename (object);
@@ -1073,7 +1082,7 @@ void o_picture_unembed (TOPLEVEL *toplevel, OBJECT *object)
 
   if (!o_picture_is_embedded (object)) return;
 
-  o_picture_set_from_file (toplevel, object, filename, &err);
+  o_picture_set_from_file (object, filename, &err);
 
   if (err != NULL) {
     s_log_message (_("Failed to load image from file [%1$s]: %2$s"),
@@ -1152,12 +1161,11 @@ o_picture_is_embedded (const OBJECT *object)
  * The returned value should have its reference count decremented with
  * g_object_unref() when no longer needed.
  *
- * \param toplevel  The current #TOPLEVEL.
  * \param object    The picture #OBJECT to inspect.
  * \return A #GdkPixbuf for the picture.
  */
 GdkPixbuf *
-o_picture_get_pixbuf (TOPLEVEL *toplevel, OBJECT *object)
+o_picture_get_pixbuf (OBJECT *object)
 {
   g_return_val_if_fail (object != NULL, NULL);
   g_return_val_if_fail (object->picture != NULL, NULL);
@@ -1169,33 +1177,12 @@ o_picture_get_pixbuf (TOPLEVEL *toplevel, OBJECT *object)
   }
 }
 
-/*! \brief Get the raw image data from a picture object.
- * \par Function Description
- * Returns the raw image file data underlying the picture \a object,
- * or NULL if the picture could not be loaded.
- *
- * \param toplevel  The current #TOPLEVEL.
- * \param object    The picture #OBJECT to inspect.
- * \param len       Location to store buffer length.
- * \return A read-only buffer of raw image data.
- */
-const char *
-o_picture_get_data (TOPLEVEL *toplevel, OBJECT *object,
-                    size_t *len)
-{
-  g_return_val_if_fail (object != NULL, NULL);
-  g_return_val_if_fail (object->picture != NULL, NULL);
-
-  *len = object->picture->file_length;
-  return object->picture->file_content;
-}
 
 /*! \brief Set a picture object's contents from a buffer.
  * \par Function Description
  * Sets the contents of the picture \a object by reading image data
  * from a buffer.  The buffer should be in on-disk format.
  *
- * \param toplevel The current #TOPLEVEL.
  * \param object   The picture #OBJECT to modify.
  * \param filename The new filename for the picture.
  * \param data     The new image data buffer.
@@ -1204,9 +1191,10 @@ o_picture_get_data (TOPLEVEL *toplevel, OBJECT *object,
  * \return TRUE on success, FALSE on failure.
  */
 gboolean
-o_picture_set_from_buffer (TOPLEVEL *toplevel, OBJECT *object,
+o_picture_set_from_buffer (OBJECT *object,
                            const gchar *filename,
-                           const gchar *data, size_t len,
+                           const gchar *data,
+                           size_t len,
                            GError **error)
 {
   GdkPixbuf *pixbuf;
@@ -1224,7 +1212,7 @@ o_picture_set_from_buffer (TOPLEVEL *toplevel, OBJECT *object,
   g_object_unref (stream);
   if (pixbuf == NULL) return FALSE;
 
-  o_emit_pre_change_notify (toplevel, object);
+  o_emit_pre_change_notify (object);
 
   if (object->picture->pixbuf != NULL) {
     g_object_unref (object->picture->pixbuf);
@@ -1246,7 +1234,7 @@ o_picture_set_from_buffer (TOPLEVEL *toplevel, OBJECT *object,
   object->picture->file_content = buf;
   object->picture->file_length = len;
 
-  o_emit_change_notify (toplevel, object);
+  o_emit_change_notify (object);
   return TRUE;
 }
 
@@ -1255,14 +1243,13 @@ o_picture_set_from_buffer (TOPLEVEL *toplevel, OBJECT *object,
  * Sets the contents of the picture \a object by reading image data
  * from a file.
  *
- * \param toplevel The current #TOPLEVEL.
  * \param object   The picture #OBJECT to modify.
  * \param filename The filename to load image data from.
  * \param error    Location to return error information.
  * \return TRUE on success, FALSE on failure.
  */
 gboolean
-o_picture_set_from_file (TOPLEVEL *toplevel, OBJECT *object,
+o_picture_set_from_file (OBJECT *object,
                          const gchar *filename,
                          GError **error)
 {
@@ -1276,7 +1263,7 @@ o_picture_set_from_file (TOPLEVEL *toplevel, OBJECT *object,
     return FALSE;
   }
 
-  status = o_picture_set_from_buffer (toplevel, object, filename,
+  status = o_picture_set_from_buffer (object, filename,
                                       buf, len, error);
   g_free (buf);
   return status;
@@ -1307,7 +1294,7 @@ o_picture_get_filename (const GedaObject *object)
  * \return a #GdkPixbuf containing a warning image.
  */
 GdkPixbuf *
-o_picture_get_fallback_pixbuf (TOPLEVEL *toplevel)
+o_picture_get_fallback_pixbuf ()
 {
   static GdkPixbuf *pixbuf = NULL;
   static gboolean failed = FALSE;
diff --git a/liblepton/src/geda_pin_object.c b/liblepton/src/geda_pin_object.c
index 3a1f47668..28d02cc84 100644
--- a/liblepton/src/geda_pin_object.c
+++ b/liblepton/src/geda_pin_object.c
@@ -32,13 +32,11 @@
  *
  *  On failure, this function sets the bounds to empty.
  *
- *  \param [in]  toplevel Unused
  *  \param [in]  object   The pin object
  *  \param [out] bounds   The bounds of the pin
  */
 void
-geda_pin_object_calculate_bounds (TOPLEVEL *toplevel,
-                                  const OBJECT *object,
+geda_pin_object_calculate_bounds (const OBJECT *object,
                                   GedaBounds *bounds)
 {
   gint expand;
@@ -277,7 +275,6 @@ geda_pin_object_set_y1 (GedaObject *object, gint y)
  *  \par Function Description
  *  This function creates and returns a new pin object.
  *
- *  \param [in]     toplevel    The TOPLEVEL object.
  *  \param [in]     color       The color of the pin
  *  \param [in]     x1          x-coord of the first point
  *  \param [in]     y1          y-coord of the first point
@@ -288,8 +285,7 @@ geda_pin_object_set_y1 (GedaObject *object, gint y)
  *  \return A new pin OBJECT
  */
 OBJECT*
-geda_pin_object_new (TOPLEVEL *toplevel,
-                     int color,
+geda_pin_object_new (int color,
                      int x1,
                      int y1,
                      int x2,
@@ -309,7 +305,7 @@ geda_pin_object_new (TOPLEVEL *toplevel,
   new_node->line->x[1] = x2;
   new_node->line->y[1] = y2;
 
-  geda_pin_object_set_type (toplevel, new_node, pin_type);
+  geda_pin_object_set_type (new_node, pin_type);
 
   new_node->whichend = whichend;
 
@@ -322,14 +318,16 @@ geda_pin_object_new (TOPLEVEL *toplevel,
  *  If the pin object was read successfully, a new pin object is
  *  allocated and appended to the \a object_list.
  *
- *  \param [in] toplevel     The TOPLEVEL object
  *  \param [in] buf          a text buffer (usually a line of a schematic file)
  *  \param [in] release_ver  The release number gEDA
  *  \param [in] fileformat_ver a integer value of the file format
  *  \return The object list, or NULL on error.
  */
-OBJECT *o_pin_read (TOPLEVEL *toplevel, const char buf[],
-                    unsigned int release_ver, unsigned int fileformat_ver, GError **err)
+OBJECT*
+o_pin_read (const char buf[],
+            unsigned int release_ver,
+            unsigned int fileformat_ver,
+            GError **err)
 {
   OBJECT *new_obj;
   char type;
@@ -369,8 +367,7 @@ OBJECT *o_pin_read (TOPLEVEL *toplevel, const char buf[],
     color = DEFAULT_COLOR;
   }
 
-  new_obj = geda_pin_object_new (toplevel,
-                                 color,
+  new_obj = geda_pin_object_new (color,
                                  x1,
                                  y1,
                                  x2,
@@ -438,12 +435,11 @@ geda_pin_object_translate (GedaObject *object, int dx, int dy)
  *  \par Function Description
  *  This function creates a copy of the pin object \a o_current.
  *
- *  \param [in] toplevel     The TOPLEVEL object
  *  \param [in] o_current    The object that is copied
  *  \return a new pin object
  */
 OBJECT*
-geda_pin_object_copy(TOPLEVEL *toplevel, OBJECT *o_current)
+geda_pin_object_copy (OBJECT *o_current)
 {
   OBJECT *new_obj;
 
@@ -451,8 +447,7 @@ geda_pin_object_copy(TOPLEVEL *toplevel, OBJECT *o_current)
   g_return_val_if_fail (o_current->line != NULL, NULL);
   g_return_val_if_fail (o_current->type == OBJ_PIN, NULL);
 
-  new_obj = geda_pin_object_new (toplevel,
-                                 o_current->color,
+  new_obj = geda_pin_object_new (o_current->color,
                                  o_current->line->x[0],
                                  o_current->line->y[0],
                                  o_current->line->x[1],
@@ -468,15 +463,16 @@ geda_pin_object_copy(TOPLEVEL *toplevel, OBJECT *o_current)
  *  This function rotates a pin \a object around the point
  *  (\a world_centerx, \a world_centery).
  *
- *  \param [in] toplevel      The TOPLEVEL object
  *  \param [in] world_centerx x-coord of the rotation center
  *  \param [in] world_centery y-coord of the rotation center
  *  \param [in] angle         The angle to rotat the pin object
  *  \param [in] object        The pin object
  *  \note only steps of 90 degrees are allowed for the \a angle
  */
-void geda_pin_object_rotate (TOPLEVEL *toplevel, int world_centerx,
-			int world_centery, int angle,
+void
+geda_pin_object_rotate (int world_centerx,
+			int world_centery,
+                        int angle,
 			OBJECT *object)
 {
   int newx, newy;
@@ -511,13 +507,14 @@ void geda_pin_object_rotate (TOPLEVEL *toplevel, int world_centerx,
  *  This function mirrors a pin \a object horizontaly at the point
  *  (\a world_centerx, \a world_centery).
  *
- *  \param [in] toplevel      The TOPLEVEL object
  *  \param [in] world_centerx x-coord of the mirror position
  *  \param [in] world_centery y-coord of the mirror position
  *  \param [in] object        The pin object
  */
-void geda_pin_object_mirror (TOPLEVEL *toplevel,
-			int world_centerx, int world_centery, OBJECT *object)
+void
+geda_pin_object_mirror (int world_centerx,
+                        int world_centery,
+                        OBJECT *object)
 {
   g_return_if_fail (object != NULL);
   g_return_if_fail (object->line != NULL);
@@ -539,7 +536,6 @@ void geda_pin_object_mirror (TOPLEVEL *toplevel,
  *  is specified by the \a whichone variable and the new coordinate
  *  is (\a x, \a y).
  *
- *  \param toplevel   The TOPLEVEL object
  *  \param object     The pin OBJECT to modify
  *  \param x          new x-coord of the pin point
  *  \param y          new y-coord of the pin point
@@ -547,7 +543,10 @@ void geda_pin_object_mirror (TOPLEVEL *toplevel,
  *
  */
 void
-geda_pin_object_modify(TOPLEVEL *toplevel, OBJECT *object, int x, int y, int whichone)
+geda_pin_object_modify (OBJECT *object,
+                        int x,
+                        int y,
+                        int whichone)
 {
   g_return_if_fail (object != NULL);
   g_return_if_fail (object->line != NULL);
@@ -699,17 +698,17 @@ geda_pin_object_update_whichend (TOPLEVEL *toplevel,
  *  \par Function Description
  *  Sets the pin's type and width to a particular style.
  *
- *  \param [in] toplevel   The TOPLEVEL object
  *  \param [in] o_current  The pin OBJECT being modified
  *  \param [in] pin_type   The new type of this pin
  */
 void
-geda_pin_object_set_type (TOPLEVEL *toplevel, OBJECT *o_current, int pin_type)
+geda_pin_object_set_type (OBJECT *o_current,
+                          int pin_type)
 {
   g_return_if_fail (o_current != NULL);
   g_return_if_fail (o_current->type == OBJ_PIN);
 
-  o_emit_pre_change_notify (toplevel, o_current);
+  o_emit_pre_change_notify (o_current);
   switch (pin_type) {
     default:
       g_critical ("geda_pin_object_set_type: Got invalid pin type %1$i\n", pin_type);
@@ -723,5 +722,5 @@ geda_pin_object_set_type (TOPLEVEL *toplevel, OBJECT *o_current, int pin_type)
       o_current->pin_type = PIN_TYPE_BUS;
       break;
   }
-  o_emit_change_notify (toplevel, o_current);
+  o_emit_change_notify (o_current);
 }
diff --git a/liblepton/src/geda_text_object.c b/liblepton/src/geda_text_object.c
index 320a67001..73dda8596 100644
--- a/liblepton/src/geda_text_object.c
+++ b/liblepton/src/geda_text_object.c
@@ -419,7 +419,6 @@ update_disp_string (OBJECT *object)
  *  \par Function Description
  *  Create an OBJECT of type OBJ_TEXT.
  *
- *  \param [in]  toplevel              The TOPLEVEL object.
  *  \param [in]  type                   OBJ_TEXT (TODO: why bother)
  *  \param [in]  color                  The color of the text.
  *  \param [in]  x                      World x coord of text.
@@ -436,8 +435,7 @@ update_disp_string (OBJECT *object)
  *  Caller is responsible for string; this function allocates its own copy.
  */
 GedaObject*
-geda_text_object_new (TOPLEVEL *toplevel,
-                      gint color,
+geda_text_object_new (gint color,
                       gint x,
                       gint y,
                       gint alignment,
@@ -469,7 +467,7 @@ geda_text_object_new (TOPLEVEL *toplevel,
   new_node->text = text;
 
   new_node->color = color;
-  o_set_visibility (toplevel, new_node, visibility);
+  o_set_visibility (new_node, visibility);
   new_node->show_name_value = show_name_value;
 
   update_disp_string (new_node);
@@ -484,7 +482,6 @@ geda_text_object_new (TOPLEVEL *toplevel,
  *  If the line object was read successfully, a new object is
  *  create and appended to the \a object_list.
  *
- *  \param [in] toplevel     The TOPLEVEL object
  *  \param [in] first_line   the first line of the text
  *  \param [in] tb           a text buffer (usually a line of a schematic file)
  *  \param [in] release_ver  The release number gEDA
@@ -492,8 +489,7 @@ geda_text_object_new (TOPLEVEL *toplevel,
  *  \return The object list, or NULL on error.
  */
 OBJECT*
-o_text_read (TOPLEVEL *toplevel,
-             const char *first_line,
+o_text_read (const char *first_line,
              TextBuffer *tb,
              unsigned int release_ver,
              unsigned int fileformat_ver,
@@ -620,8 +616,7 @@ o_text_read (TOPLEVEL *toplevel,
     }
   }
 
-  new_obj = geda_text_object_new (toplevel,
-                                  color,
+  new_obj = geda_text_object_new (color,
                                   x,
                                   y,
                                   alignment,
@@ -676,15 +671,14 @@ geda_text_object_to_buffer (const GedaObject *object)
  *  This function updates the underlying primary of the text object
  *  \a o_current.
  *
- *  \param toplevel  The TOPLEVEL object
  *  \param o_current The text object to update
  */
 void
-o_text_recreate (TOPLEVEL *toplevel, OBJECT *o_current)
+o_text_recreate (OBJECT *o_current)
 {
-  o_emit_pre_change_notify (toplevel, o_current);
+  o_emit_pre_change_notify (o_current);
   update_disp_string (o_current);
-  o_emit_change_notify (toplevel, o_current);
+  o_emit_change_notify (o_current);
 }
 
 /*! \brief move a text object
@@ -710,12 +704,11 @@ geda_text_object_translate (GedaObject *object, int dx, int dy)
  *  \par Function Description
  *  This function creates a copy of the text object \a o_current.
  *
- *  \param [in] toplevel     The TOPLEVEL object
  *  \param [in] object    The object that is copied
  *  \return a new text object
  */
 GedaObject*
-geda_text_object_copy (TOPLEVEL *toplevel, const GedaObject *object)
+geda_text_object_copy (const GedaObject *object)
 {
   GedaObject *new_obj;
 
@@ -723,8 +716,7 @@ geda_text_object_copy (TOPLEVEL *toplevel, const GedaObject *object)
   g_return_val_if_fail (object->text != NULL, NULL);
   g_return_val_if_fail (object->type == OBJ_TEXT, NULL);
 
-  new_obj = geda_text_object_new (toplevel,
-                                  object->color,
+  new_obj = geda_text_object_new (object->color,
                                   object->text->x,
                                   object->text->y,
                                   object->text->alignment,
@@ -742,7 +734,6 @@ geda_text_object_copy (TOPLEVEL *toplevel, const GedaObject *object)
  *  This function rotates a text \a object around the point
  *  (\a world_centerx, \a world_centery).
  *
- *  \param [in] toplevel      The TOPLEVEL object
  *  \param [in] world_centerx x-coord of the rotation center
  *  \param [in] world_centery y-coord of the rotation center
  *  \param [in] angle         The angle to rotate the text object
@@ -750,8 +741,7 @@ geda_text_object_copy (TOPLEVEL *toplevel, const GedaObject *object)
  *  \note only steps of 90 degrees are allowed for the \a angle
  */
 void
-geda_text_object_rotate (TOPLEVEL *toplevel,
-                         int world_centerx,
+geda_text_object_rotate (int world_centerx,
                          int world_centery,
                          int angle,
                          OBJECT *object)
@@ -776,7 +766,7 @@ geda_text_object_rotate (TOPLEVEL *toplevel,
 
   geda_text_object_translate (object, x-object->text->x, y-object->text->y);
 
-  o_text_recreate(toplevel, object);
+  o_text_recreate (object);
 }
 
 
@@ -785,14 +775,12 @@ geda_text_object_rotate (TOPLEVEL *toplevel,
  *  This function mirrors a text \a object horizontaly at the point
  *  (\a world_centerx, \a world_centery).
  *
- *  \param [in] toplevel      The TOPLEVEL object
  *  \param [in] world_centerx x-coord of the mirror position
  *  \param [in] world_centery y-coord of the mirror position
  *  \param [in] object        The text object
  */
 void
-geda_text_object_mirror (TOPLEVEL *toplevel,
-                         int world_centerx,
+geda_text_object_mirror (int world_centerx,
                          int world_centery,
                          OBJECT *object)
 {
@@ -872,7 +860,7 @@ geda_text_object_mirror (TOPLEVEL *toplevel,
   object->text->x = -x + (world_centerx);
   object->text->y =  y + (world_centery);
 
-  o_text_recreate(toplevel, object);
+  o_text_recreate (object);
 }
 
 /*! \brief Calculates the distance between the given point and the closest
@@ -920,14 +908,13 @@ geda_text_object_shortest_distance (TOPLEVEL *toplevel,
  *  \par Function Description
  *  Updates the text object with a new text string.
  *
- *  \param [in]  toplevel              The TOPLEVEL object.
  *  \param [in]  obj                   The text object.
  *  \param [in]  new_string            The new value.
  */
 void
-o_text_set_string (TOPLEVEL *toplevel, OBJECT *obj, const gchar *new_string)
+o_text_set_string (OBJECT *obj,
+                   const gchar *new_string)
 {
-  g_return_if_fail (toplevel != NULL);
   g_return_if_fail (obj != NULL);
   g_return_if_fail (obj->type == OBJ_TEXT);
   g_return_if_fail (obj->text != NULL);
@@ -936,7 +923,7 @@ o_text_set_string (TOPLEVEL *toplevel, OBJECT *obj, const gchar *new_string)
   g_free (obj->text->string);
   obj->text->string = g_strdup (new_string);
 
-  o_text_recreate (toplevel, obj);
+  o_text_recreate (obj);
 }
 
 /*! \brief Set the font-renderer-specific bounds function.
diff --git a/liblepton/src/geda_undo.c b/liblepton/src/geda_undo.c
index 700a60c21..b82ce445e 100644
--- a/liblepton/src/geda_undo.c
+++ b/liblepton/src/geda_undo.c
@@ -181,7 +181,8 @@ void s_undo_print_all( UNDO *head )
  *  \par Function Description
  *
  */
-void s_undo_destroy_all(TOPLEVEL *toplevel, UNDO *head)
+void
+s_undo_destroy_all (UNDO *head)
 {
   UNDO *u_current;
   UNDO *u_prev;
@@ -193,7 +194,7 @@ void s_undo_destroy_all(TOPLEVEL *toplevel, UNDO *head)
     g_free(u_current->filename);
 
     if (u_current->object_list) {
-      geda_object_list_delete (toplevel, u_current->object_list);
+      geda_object_list_delete (u_current->object_list);
       u_current->object_list = NULL;
     }
 
@@ -202,54 +203,14 @@ void s_undo_destroy_all(TOPLEVEL *toplevel, UNDO *head)
   }
 }
 
-/*! \todo Finish function documentation!!!
- *  \brief
- *  \par Function Description
- *
- */
-void s_undo_remove(TOPLEVEL *toplevel, UNDO *head, UNDO *u_tos)
-{
-  UNDO *u_current;
-
-  if (u_tos == NULL) {
-    fprintf(stderr, "Got NULL for u_tos in s_undo_remove\n");
-    return;
-  }
-
-  u_current = head;
-
-  while (u_current != NULL) {
-    if (u_current == u_tos) {
-      if (u_current->next)
-        u_current->next->prev = u_current->prev;
-      else
-        u_current->next = NULL;
-
-      if (u_current->prev)
-        u_current->prev->next = u_current->next;
-      else
-        u_current->prev = NULL;
-
-      g_free(u_current->filename);
-
-      if (u_current->object_list) {
-        geda_object_list_delete (toplevel, u_current->object_list);
-        u_current->object_list = NULL;
-      }
-
-      g_free(u_current);
-      return;
-    }
-    u_current = u_current->next;
-  }
-}
 
 /*! \todo Finish function documentation!!!
  *  \brief
  *  \par Function Description
  *
  */
-void s_undo_remove_rest(TOPLEVEL *toplevel, UNDO *head)
+void
+s_undo_remove_rest (UNDO *head)
 {
   UNDO *u_current;
   UNDO *u_next;
@@ -265,7 +226,7 @@ void s_undo_remove_rest(TOPLEVEL *toplevel, UNDO *head)
     }
 
     if (u_current->object_list) {
-      geda_object_list_delete (toplevel, u_current->object_list);
+      geda_object_list_delete (u_current->object_list);
       u_current->object_list = NULL;
     }
 
@@ -312,9 +273,10 @@ void s_undo_init(PAGE *p_current)
  *  \par Function Description
  *
  */
-void s_undo_free_all(TOPLEVEL *toplevel, PAGE *p_current)
+void
+s_undo_free_all (PAGE *p_current)
 {
-  s_undo_destroy_all(toplevel, p_current->undo_bottom);
+  s_undo_destroy_all (p_current->undo_bottom);
   p_current->undo_bottom = NULL;
   p_current->undo_tos = NULL;
   p_current->undo_current = NULL;
diff --git a/liblepton/src/o_attrib.c b/liblepton/src/o_attrib.c
index 9c1a09013..81d485cb4 100644
--- a/liblepton/src/o_attrib.c
+++ b/liblepton/src/o_attrib.c
@@ -55,12 +55,12 @@
  *  \par Function Description
  *  Add an attribute to an existing attribute list.
  *
- *  \param [in]  toplevel   The TOPLEVEL object.
  *  \param [in]  object     The OBJECT we're adding the attribute to.
  *  \param [in]  item       The item you want to add as an attribute.
  *  \return nothing.
  */
-void o_attrib_add(TOPLEVEL *toplevel, OBJECT *object, OBJECT *item)
+void
+o_attrib_add (OBJECT *object, OBJECT *item)
 {
   /* Add link from item to attrib listing */
   item->attached_to = object;
@@ -68,40 +68,18 @@ void o_attrib_add(TOPLEVEL *toplevel, OBJECT *object, OBJECT *item)
 }
 
 
-/*! \brief Check whether a attrib is attached to another object
- *  \par Function Description
- *  This function checks whether the object \a attrib is attached to
- *  the \a object.
- *
- *  \param [in]  toplevel   The TOPLEVEL object.
- *  \param [in]  attrib     The attribute to be checket.
- *  \param [in]  object     The object where you want to add item as an attribute.
- *  \return TRUE if attrib is an attribute of object, FALSE otherwise
- */
-gboolean o_attrib_is_attached (TOPLEVEL *toplevel,
-                               OBJECT *attrib, OBJECT *object)
-{
-  if (attrib == NULL || object == NULL)
-    return FALSE;
-
-  if (attrib->attached_to == object)
-    return TRUE;
-
-  return FALSE;
-}
-
-
 /*! \brief Attach existing attribute to an object.
  *  \par Function Description
  *  Attach existing attribute to an object.
  *
- *  \param [in]  toplevel     The TOPLEVEL object.
  *  \param [in]  attrib       The attribute to be added.
  *  \param [out] object       The object where you want to add item as an attribute.
  *  \param [in]  set_color    Whether or not we should set the new attribute's color.
  */
-void o_attrib_attach (TOPLEVEL *toplevel, OBJECT *attrib, OBJECT *object,
-                      int set_color)
+void
+o_attrib_attach (OBJECT *attrib,
+                 OBJECT *object,
+                 int set_color)
 {
   g_return_if_fail (attrib != NULL);
   g_return_if_fail (object != NULL);
@@ -128,10 +106,10 @@ void o_attrib_attach (TOPLEVEL *toplevel, OBJECT *attrib, OBJECT *object,
   */
   attrib->selectable = object->selectable;
 
-  o_attrib_add (toplevel, object, attrib);
+  o_attrib_add (object, attrib);
 
   if (set_color)
-    o_set_color (toplevel, attrib, ATTRIBUTE_COLOR);
+    o_set_color (attrib, ATTRIBUTE_COLOR);
 }
 
 
@@ -139,18 +117,19 @@ void o_attrib_attach (TOPLEVEL *toplevel, OBJECT *attrib, OBJECT *object,
  *  \par Function Description
  *  Attach list of existing attributes to an object.
  *
- *  \param [in]  toplevel   The TOPLEVEL object.
  *  \param [in]  attr_list  The list of attributes to be added.
  *  \param [out] object     The object where you want to add item as an attribute.
  *  \param [in]  set_color    Whether or not we should set the new attribute's color.
  */
-void o_attrib_attach_list (TOPLEVEL *toplevel,
-                           GList *attr_list, OBJECT *object, int set_color)
+void
+o_attrib_attach_list (GList *attr_list,
+                      OBJECT *object,
+                      int set_color)
 {
   GList *iter;
 
   for (iter = attr_list; iter != NULL; iter = g_list_next (iter))
-    o_attrib_attach (toplevel, (OBJECT*) iter->data, object, set_color);
+    o_attrib_attach ((OBJECT*) iter->data, object, set_color);
 }
 
 
@@ -158,10 +137,10 @@ void o_attrib_attach_list (TOPLEVEL *toplevel,
  *  \par Function Description
  *  Detach all attributes from an object.
  *
- *  \param [in]     toplevel  The TOPLEVEL object.
  *  \param [in,out] object    The object whos attributes to detach.
  */
-void o_attrib_detach_all(TOPLEVEL *toplevel, OBJECT *object)
+void
+o_attrib_detach_all (OBJECT *object)
 {
   OBJECT *a_current;
   GList *a_iter;
@@ -171,7 +150,7 @@ void o_attrib_detach_all(TOPLEVEL *toplevel, OBJECT *object)
     a_current = (OBJECT*) a_iter->data;
 
     a_current->attached_to = NULL;
-    o_set_color (toplevel, a_current, DETACHED_ATTRIBUTE_COLOR);
+    o_set_color (a_current, DETACHED_ATTRIBUTE_COLOR);
   }
 
   g_list_free (object->attribs);
@@ -208,11 +187,12 @@ void o_attrib_print(GList *attributes)
  *  This function removes the given attribute from an attribute list.
  *  This function should be used when detaching an attribute.
  *
- *  \param [in] toplevel  The TOPLEVEL object.
  *  \param [in] list      The attribute list to remove attribute from.
  *  \param [in] remove    The OBJECT to remove from list.
  */
-void o_attrib_remove(TOPLEVEL *toplevel, GList **list, OBJECT *remove)
+void
+o_attrib_remove (GList **list,
+                 OBJECT *remove)
 {
   g_return_if_fail (remove != NULL);
 
@@ -252,32 +232,32 @@ GList *o_read_attribs (TOPLEVEL *toplevel,
     switch (objtype) {
 
       case(OBJ_LINE):
-        if ((new_obj = o_line_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_line_read (line, release_ver, fileformat_ver, err)) == NULL)
           goto error;
         object_list = g_list_prepend (object_list, new_obj);
         break;
 
 
       case(OBJ_NET):
-        if ((new_obj = o_net_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_net_read (line, release_ver, fileformat_ver, err)) == NULL)
           goto error;
         object_list = g_list_prepend (object_list, new_obj);
         break;
 
       case(OBJ_BUS):
-        if ((new_obj = o_bus_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_bus_read (line, release_ver, fileformat_ver, err)) == NULL)
           goto error;
         object_list = g_list_prepend (object_list, new_obj);
         break;
 
       case(OBJ_BOX):
-        if ((new_obj = o_box_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_box_read (line, release_ver, fileformat_ver, err)) == NULL)
           goto error;
         object_list = g_list_prepend (object_list, new_obj);
         break;
 
       case(OBJ_CIRCLE):
-        if ((new_obj = o_circle_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_circle_read (line, release_ver, fileformat_ver, err)) == NULL)
           goto error;
         object_list = g_list_prepend (object_list, new_obj);
         break;
@@ -290,26 +270,26 @@ GList *o_read_attribs (TOPLEVEL *toplevel,
         break;
 
       case(OBJ_PATH):
-        new_obj = o_path_read (toplevel, line, tb, release_ver, fileformat_ver, err);
+        new_obj = o_path_read (line, tb, release_ver, fileformat_ver, err);
         if (new_obj == NULL)
           goto error;
         object_list = g_list_prepend (object_list, new_obj);
         break;
 
       case(OBJ_PIN):
-        if ((new_obj = o_pin_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_pin_read (line, release_ver, fileformat_ver, err)) == NULL)
           goto error;
         object_list = g_list_prepend (object_list, new_obj);
         break;
 
       case(OBJ_ARC):
-        if ((new_obj = o_arc_read (toplevel, line, release_ver, fileformat_ver, err)) == NULL)
+        if ((new_obj = o_arc_read (line, release_ver, fileformat_ver, err)) == NULL)
           goto error;
         object_list = g_list_prepend (object_list, new_obj);
         break;
 
       case(OBJ_TEXT):
-        new_obj = o_text_read (toplevel, line, tb, release_ver, fileformat_ver, err);
+        new_obj = o_text_read (line, tb, release_ver, fileformat_ver, err);
         if (new_obj == NULL)
           goto error;
         object_list = g_list_prepend (object_list, new_obj);
@@ -323,7 +303,7 @@ GList *o_read_attribs (TOPLEVEL *toplevel,
     }
 
     if (ATTACH) {
-      o_attrib_attach (toplevel, new_obj, object_to_get_attribs, FALSE);
+      o_attrib_attach (new_obj, object_to_get_attribs, FALSE);
       ATTACH=FALSE;
     } else {
       g_set_error(err, EDA_ERROR, EDA_ERROR_PARSE, _("Tried to attach a non-text item as an attribute"));
@@ -336,7 +316,7 @@ GList *o_read_attribs (TOPLEVEL *toplevel,
                _("Unexpected end-of-file in attribute list"));
 
 error:
-  geda_object_list_delete (toplevel, object_list);
+  geda_object_list_delete (object_list);
   return NULL;
 }
 
diff --git a/liblepton/src/o_embed.c b/liblepton/src/o_embed.c
index 069ddb65b..ef22fc4a5 100644
--- a/liblepton/src/o_embed.c
+++ b/liblepton/src/o_embed.c
@@ -42,14 +42,9 @@ o_embed (OBJECT *o_current)
 {
   int page_modified = 0;
   PAGE *page = NULL;
-  TOPLEVEL *toplevel = NULL;
 
   page = o_get_page (o_current);
 
-  if (page != NULL) {
-    toplevel = page->toplevel;
-  }
-
   /* check o_current is a component and is not already embedded */
   if (o_current->type == OBJ_COMPONENT &&
       !o_component_is_embedded (o_current))
@@ -66,7 +61,7 @@ o_embed (OBJECT *o_current)
   /* If it's a picture and it's not embedded */
   if ( (o_current->type == OBJ_PICTURE) &&
        !o_picture_is_embedded (o_current) ) {
-    o_picture_embed (toplevel, o_current);
+    o_picture_embed (o_current);
 
     page_modified = 1;
   }
@@ -91,14 +86,9 @@ o_unembed (OBJECT *o_current)
   const CLibSymbol *sym;
   int page_modified = 0;
   PAGE *page = NULL;
-  TOPLEVEL *toplevel = NULL;
 
   page = o_get_page (o_current);
 
-  if (page != NULL) {
-    toplevel = page->toplevel;
-  }
-
   /* check o_current is an embedded component */
   if (o_current->type == OBJ_COMPONENT &&
       o_component_is_embedded (o_current))
@@ -127,7 +117,7 @@ o_unembed (OBJECT *o_current)
   /* If it's a picture and it's embedded */
   if ( (o_current->type == OBJ_PICTURE) &&
        o_picture_is_embedded (o_current)) {
-    o_picture_unembed (toplevel, o_current);
+    o_picture_unembed (o_current);
 
     page_modified = 1;
   }
diff --git a/liblepton/src/o_selection.c b/liblepton/src/o_selection.c
index 0a0e7c9d1..b66ab0ad6 100644
--- a/liblepton/src/o_selection.c
+++ b/liblepton/src/o_selection.c
@@ -41,15 +41,16 @@ SELECTION *o_selection_new( void )
  *  object visually selected.
  *  Skip objects that are already selected.
  *
- *  \param [in] toplevel   The TOPLEVEL object
  *  \param [in] selection  Pointer to the selection list
  *  \param [in] o_selected Object to select.
  */
-void o_selection_add (TOPLEVEL *toplevel, SELECTION *selection, OBJECT *o_selected)
+void
+o_selection_add (SELECTION *selection,
+                 OBJECT *o_selected)
 {
   if (o_selected->selected == FALSE)
   {
-    o_selection_select (toplevel, o_selected);
+    o_selection_select (o_selected);
     geda_list_add( (GedaList *)selection, o_selected );
   }
 }
@@ -60,11 +61,12 @@ void o_selection_add (TOPLEVEL *toplevel, SELECTION *selection, OBJECT *o_select
  *  It's ok to call this function with an object which is not necessarily
  *  selected.
  *
- *  \param [in] toplevel   The TOPLEVEL object
  *  \param [in] selection  Pointer to the selection list
  *  \param [in] o_selected Object to unselect and remove from the list.
  */
-void o_selection_remove (TOPLEVEL *toplevel, SELECTION *selection, OBJECT *o_selected)
+void
+o_selection_remove (SELECTION *selection,
+                    OBJECT *o_selected)
 {
   if (o_selected == NULL) {
     fprintf(stderr, "Got NULL for o_selected in o_selection_remove\n");
@@ -72,7 +74,7 @@ void o_selection_remove (TOPLEVEL *toplevel, SELECTION *selection, OBJECT *o_sel
   }
 
   if (g_list_find( geda_list_get_glist( selection ), o_selected ) != NULL) {
-    o_selection_unselect (toplevel, o_selected);
+    o_selection_unselect (o_selected);
     geda_list_remove( (GedaList *)selection, o_selected );
   }
 }
@@ -104,17 +106,17 @@ void o_selection_print_all(const SELECTION *selection)
  *  \par Sets the select flag, saves the color, and then selects the 
  *  given object
  *
- *  \param [in] toplevel  The TOPLEVEL object
  *  \param [in] object    Object to select.
  */
-void o_selection_select(TOPLEVEL *toplevel, OBJECT *object)
+void
+o_selection_select (OBJECT *object)
 {
   if (object->selected == TRUE)
     return;
 
-  o_emit_pre_change_notify (toplevel, object);
+  o_emit_pre_change_notify (object);
   object->selected = TRUE;
-  o_emit_change_notify (toplevel, object);
+  o_emit_change_notify (object);
 }
 
 /*! \brief Unselects the given object.
@@ -122,16 +124,16 @@ void o_selection_select(TOPLEVEL *toplevel, OBJECT *object)
  *  given object.
  *  This function should not be called by anybody outside of this file.
  *
- *  \param [in] toplevel  The TOPLEVEL object
  *  \param [in] object    Object to unselect.
  */
-void o_selection_unselect (TOPLEVEL *toplevel, OBJECT *object)
+void
+o_selection_unselect (OBJECT *object)
 {
   if (object->selected == FALSE)
     return;
 
-  o_emit_pre_change_notify (toplevel, object);
+  o_emit_pre_change_notify (object);
   object->selected = FALSE;
-  o_emit_change_notify (toplevel, object);
+  o_emit_change_notify (object);
 }
 
diff --git a/liblepton/src/s_conn.c b/liblepton/src/s_conn.c
index 466fe40c7..9c0b3a04e 100644
--- a/liblepton/src/s_conn.c
+++ b/liblepton/src/s_conn.c
@@ -106,18 +106,19 @@ int s_conn_uniq(GList * conn_list, CONN * input_conn)
  *  \par Function Description
  *  This function removes the OBJECT <b>to_remove</b> from the connection
  *  list of the OBJECT <b>other_object</b>.
- *  \param toplevel (currently not used)
+ *
  *  \param other_object OBJECT from that the to_remove OBJECT needs to be removed
  *  \param to_remove OBJECT to remove
  *  \return TRUE if a connection has been deleted, FALSE otherwise
  */
-int s_conn_remove_other (TOPLEVEL *toplevel, OBJECT *other_object,
-                         OBJECT *to_remove)
+int
+s_conn_remove_other (OBJECT *other_object,
+                     OBJECT *to_remove)
 {
     GList *c_current = NULL;
     CONN *conn = NULL;
 
-    o_emit_pre_change_notify (toplevel, other_object);
+    o_emit_pre_change_notify (other_object);
 
     c_current = other_object->conn_list;
     while (c_current != NULL) {
@@ -153,7 +154,7 @@ int s_conn_remove_other (TOPLEVEL *toplevel, OBJECT *other_object,
 	c_current = g_list_next(c_current);
     }
 
-    o_emit_change_notify (toplevel, other_object);
+    o_emit_change_notify (other_object);
 
     return (FALSE);
 }
@@ -162,11 +163,11 @@ int s_conn_remove_other (TOPLEVEL *toplevel, OBJECT *other_object,
  *  \par Function Description
  *  This function removes all connections from and to the OBJECT
  *  <b>to_remove</b>.
- *  \param toplevel  The TOPLEVEL structure
+ *
  *  \param to_remove OBJECT to unconnected from all other objects
  */
 void
-s_conn_remove_object_connections (TOPLEVEL *toplevel, OBJECT *to_remove)
+s_conn_remove_object_connections (OBJECT *to_remove)
 {
   GList *c_iter;
   CONN *conn;
@@ -184,7 +185,7 @@ s_conn_remove_object_connections (TOPLEVEL *toplevel, OBJECT *to_remove)
 
         /* keep calling this till it returns false (all refs removed) */
         /* there is NO body to this while loop */
-        while (s_conn_remove_other (toplevel, conn->other_object, to_remove));
+        while (s_conn_remove_other (conn->other_object, to_remove));
 
         c_iter->data = NULL;
         g_free (conn);
@@ -198,7 +199,7 @@ s_conn_remove_object_connections (TOPLEVEL *toplevel, OBJECT *to_remove)
     case OBJ_PLACEHOLDER:
       for (iter = to_remove->component->prim_objs; iter != NULL; iter = g_list_next (iter)) {
         o_current = (OBJECT*) iter->data;
-        s_conn_remove_object_connections (toplevel, o_current);
+        s_conn_remove_object_connections (o_current);
       }
       break;
   }
@@ -340,12 +341,8 @@ static void s_conn_update_line_object (PAGE* page, OBJECT *object)
   OBJECT *found;
   int j, k;
   OBJECT *component, *other_component;
-  TOPLEVEL *toplevel;
-
-  toplevel = page->toplevel;
-  g_return_if_fail (toplevel != NULL);
 
-  component = o_get_parent (toplevel, object);
+  component = o_get_parent (object);
 
   /* loop over all connectible objects */
   for (object_list = page->connectible_list;
@@ -356,7 +353,7 @@ static void s_conn_update_line_object (PAGE* page, OBJECT *object)
     if (object == other_object)
       continue;
 
-    other_component = o_get_parent (toplevel, other_object);
+    other_component = o_get_parent (other_object);
 
     /* An object inside a symbol can only be connected up to another
      * object if they are (a) both inside the same object, or (b)
@@ -399,7 +396,7 @@ static void s_conn_update_line_object (PAGE* page, OBJECT *object)
             object->line->y[j] == other_object->line->y[k] &&
             check_direct_compat (object, other_object)) {
 
-          o_emit_pre_change_notify (toplevel, other_object);
+          o_emit_pre_change_notify (other_object);
 
           add_connection (object, other_object, CONN_ENDPOINT,
                           other_object->line->x[k],
@@ -409,7 +406,7 @@ static void s_conn_update_line_object (PAGE* page, OBJECT *object)
                           object->line->x[j],
                           object->line->y[j], k, j);
 
-          o_emit_change_notify (toplevel, other_object);
+          o_emit_change_notify (other_object);
         }
       }
     }
diff --git a/liblepton/src/s_slot.c b/liblepton/src/s_slot.c
index 169cf5406..ce679d2b0 100644
--- a/liblepton/src/s_slot.c
+++ b/liblepton/src/s_slot.c
@@ -115,10 +115,10 @@ static char *s_slot_search_slotdef (OBJECT *object, int slotnumber)
  *  parts, but on slotted parts, this is what sets the
  *  pinnumber= attribute on slots 2, 3, 4....
  *
- *  \param [in]     toplevel  The TOPLEVEL object.
  *  \param [in,out] object     The OBJECT to update.
  */
-void s_slot_update_object (TOPLEVEL *toplevel, OBJECT *object)
+void
+s_slot_update_object (OBJECT *object)
 {
   OBJECT *o_pin_object;
   OBJECT *o_pinnum_attrib;
@@ -200,8 +200,7 @@ void s_slot_update_object (TOPLEVEL *toplevel, OBJECT *object)
       g_list_free (attributes);
 
       if (o_pinnum_attrib != NULL) {
-        o_text_set_string (toplevel,
-                           o_pinnum_attrib,
+        o_text_set_string (o_pinnum_attrib,
                            g_strdup_printf ("pinnumber=%s", current_pin));
       }
 
diff --git a/liblepton/src/scheme_attrib.c b/liblepton/src/scheme_attrib.c
index 536dc2e51..fdabd9303 100644
--- a/liblepton/src/scheme_attrib.c
+++ b/liblepton/src/scheme_attrib.c
@@ -190,7 +190,6 @@ SCM_DEFINE (attach_attrib_x, "%attach-attrib!", 2, 0, 0,
   SCM_ASSERT (edascm_is_object_type (attrib_s, OBJ_TEXT), attrib_s,
               SCM_ARG2, s_attach_attrib_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
   OBJECT *attrib = edascm_to_object (attrib_s);
 
@@ -219,9 +218,9 @@ SCM_DEFINE (attach_attrib_x, "%attach-attrib!", 2, 0, 0,
   }
 
   /* Carry out the attachment */
-  o_emit_pre_change_notify (toplevel, attrib);
-  o_attrib_attach (toplevel, attrib, obj, TRUE);
-  o_emit_change_notify (toplevel, attrib);
+  o_emit_pre_change_notify (attrib);
+  o_attrib_attach (attrib, obj, TRUE);
+  o_emit_change_notify (attrib);
 
   o_page_changed (obj);
 
@@ -251,7 +250,6 @@ SCM_DEFINE (detach_attrib_x, "%detach-attrib!", 2, 0, 0,
   SCM_ASSERT (edascm_is_object_type (attrib_s, OBJ_TEXT), attrib_s,
               SCM_ARG2, s_detach_attrib_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
   OBJECT *attrib = edascm_to_object (attrib_s);
 
@@ -268,10 +266,10 @@ SCM_DEFINE (detach_attrib_x, "%detach-attrib!", 2, 0, 0,
   }
 
   /* Detach object */
-  o_emit_pre_change_notify (toplevel, attrib);
-  o_attrib_remove (toplevel, &obj->attribs, attrib);
-  o_set_color (toplevel, attrib, DETACHED_ATTRIBUTE_COLOR);
-  o_emit_change_notify (toplevel, attrib);
+  o_emit_pre_change_notify (attrib);
+  o_attrib_remove (&obj->attribs, attrib);
+  o_set_color (attrib, DETACHED_ATTRIBUTE_COLOR);
+  o_emit_change_notify (attrib);
 
   o_page_changed (obj);
 
@@ -294,10 +292,9 @@ SCM_DEFINE (promotable_attribs, "%promotable-attribs", 1, 0, 0,
   SCM_ASSERT (edascm_is_object_type (component_s, OBJ_COMPONENT), component_s,
               SCM_ARG1, s_promotable_attribs);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (component_s);
 
-  GList *lst = o_component_get_promotable (toplevel, obj, FALSE);
+  GList *lst = o_component_get_promotable (obj, FALSE);
 
   return edascm_from_object_glist (lst);
 }
diff --git a/liblepton/src/scheme_component.c b/liblepton/src/scheme_component.c
index 25662f4bf..aa6c9fc11 100644
--- a/liblepton/src/scheme_component.c
+++ b/liblepton/src/scheme_component.c
@@ -133,7 +133,6 @@ SCM_DEFINE (set_component_x, "%set-component!", 6, 0, 0,
   SCM_ASSERT (scm_is_bool (mirror_s), mirror_s,  SCM_ARG5, s_set_component_x);
   SCM_ASSERT (scm_is_bool (locked_s), locked_s,  SCM_ARG6, s_set_component_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (component_s);
 
   /* Angle */
@@ -152,7 +151,7 @@ SCM_DEFINE (set_component_x, "%set-component!", 6, 0, 0,
                     scm_list_1 (angle_s));
   }
 
-  o_emit_pre_change_notify (toplevel, obj);
+  o_emit_pre_change_notify (obj);
 
   int x = scm_to_int (x_s);
   int y = scm_to_int (y_s);
@@ -161,7 +160,7 @@ SCM_DEFINE (set_component_x, "%set-component!", 6, 0, 0,
   obj->component->mirror = scm_is_true (mirror_s);
   obj->selectable = scm_is_false (locked_s);
 
-  o_emit_change_notify (toplevel, obj);
+  o_emit_change_notify (obj);
 
   o_page_changed (obj);
 
@@ -257,7 +256,6 @@ SCM_DEFINE (component_append_x, "%component-append!", 2, 0, 0,
                && !edascm_is_object_type (obj_s, OBJ_PLACEHOLDER)),
               obj_s, SCM_ARG2, s_component_append_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *parent = edascm_to_object (component_s);
   OBJECT *child = edascm_to_object (obj_s);
 
@@ -279,7 +277,7 @@ SCM_DEFINE (component_append_x, "%component-append!", 2, 0, 0,
 
   /* Don't need to emit change notifications for the child because
    * it's guaranteed not to be present in a page at this point. */
-  o_emit_pre_change_notify (toplevel, parent);
+  o_emit_pre_change_notify (parent);
 
   parent->component->prim_objs =
     g_list_append (parent->component->prim_objs, child);
@@ -291,7 +289,7 @@ SCM_DEFINE (component_append_x, "%component-append!", 2, 0, 0,
     s_conn_update_object (parent_page, child);
   }
 
-  o_emit_change_notify (toplevel, parent);
+  o_emit_change_notify (parent);
 
   o_page_changed (parent);
 
@@ -320,7 +318,6 @@ SCM_DEFINE (component_remove_x, "%component-remove!", 2, 0, 0,
               SCM_ARG1, s_component_remove_x);
   SCM_ASSERT (EDASCM_OBJECTP (obj_s), obj_s, SCM_ARG2, s_component_remove_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *parent = edascm_to_object (component_s);
   OBJECT *child = edascm_to_object (obj_s);
   PAGE *child_page = o_get_page (child);
@@ -357,7 +354,7 @@ SCM_DEFINE (component_remove_x, "%component-remove!", 2, 0, 0,
 
   /* Don't need to emit change notifications for the child because
    * only the parent will remain in the page. */
-  o_emit_pre_change_notify (toplevel, parent);
+  o_emit_pre_change_notify (parent);
 
   parent->component->prim_objs =
     g_list_remove_all (parent->component->prim_objs, child);
@@ -365,9 +362,9 @@ SCM_DEFINE (component_remove_x, "%component-remove!", 2, 0, 0,
 
   /* We may need to update connections */
   s_conn_remove_object (child_page, child);
-  s_conn_remove_object_connections (toplevel, child);
+  s_conn_remove_object_connections (child);
 
-  o_emit_change_notify (toplevel, parent);
+  o_emit_change_notify (parent);
 
   o_page_changed (parent);
 
diff --git a/liblepton/src/scheme_object.c b/liblepton/src/scheme_object.c
index c8311507e..3edb870a4 100644
--- a/liblepton/src/scheme_object.c
+++ b/liblepton/src/scheme_object.c
@@ -187,10 +187,9 @@ SCM_DEFINE (copy_object, "%copy-object", 1, 0, 0,
   SCM_ASSERT (EDASCM_OBJECTP (obj_s), obj_s,
               SCM_ARG1, s_copy_object);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
 
-  result = edascm_from_object (o_object_copy (toplevel, obj));
+  result = edascm_from_object (o_object_copy (obj));
 
   /* At the moment, the only pointer to the object is owned by the
    * smob. */
@@ -425,7 +424,6 @@ SCM_DEFINE (set_object_stroke_x, "%set-object-stroke!", 4, 2, 0,
                || edascm_is_object_type (obj_s, OBJ_PATH)),
               obj_s, SCM_ARG1, s_set_object_stroke_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
   int cap, type, width, length = -1, space = -1;
 
@@ -483,8 +481,7 @@ SCM_DEFINE (set_object_stroke_x, "%set-object-stroke!", 4, 2, 0,
     /* This case intentionally falls through */
   }
 
-  o_set_line_options (toplevel,
-                      obj,
+  o_set_line_options (obj,
                       (OBJECT_END) cap,
                       (OBJECT_TYPE) type,
                       width,
@@ -581,7 +578,6 @@ SCM_DEFINE (set_object_fill_x, "%set-object-fill!", 2, 5, 0,
                || edascm_is_object_type (obj_s, OBJ_PATH)),
               obj_s, SCM_ARG1, s_set_object_fill_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
   int type, width = -1, angle1 = -1, space1 = -1, angle2 = -1, space2 = -1;
 
@@ -645,8 +641,7 @@ SCM_DEFINE (set_object_fill_x, "%set-object-fill!", 2, 5, 0,
     /* This case intentionally falls through */
   }
 
-  o_set_fill_options (toplevel,
-                      obj,
+  o_set_fill_options (obj,
                       (OBJECT_FILLING) type,
                       width,
                       space1,
@@ -701,9 +696,8 @@ SCM_DEFINE (set_object_color_x, "%set-object-color!", 2, 0, 0,
   SCM_ASSERT (scm_is_integer (color_s), color_s,
               SCM_ARG2, s_set_object_color_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
-  o_set_color (toplevel, obj, scm_to_int (color_s));
+  o_set_color (obj, scm_to_int (color_s));
 
   o_page_changed (obj);
 
@@ -881,8 +875,7 @@ SCM_DEFINE (set_object_embedded_x, "%set-object-embedded!", 2, 0, 0,
 SCM_DEFINE (make_line, "%make-line", 0, 0, 0,
             (), "Create a new line object.")
 {
-  GedaObject *object = geda_line_object_new (edascm_c_current_toplevel (),
-                                             DEFAULT_COLOR,
+  GedaObject *object = geda_line_object_new (DEFAULT_COLOR,
                                              0,
                                              0,
                                              0,
@@ -933,7 +926,6 @@ SCM_DEFINE (set_line_x, "%set-line!", 6, 0, 0,
   SCM_ASSERT (scm_is_integer (y2_s),    y2_s,    SCM_ARG5, s_set_line_x);
   SCM_ASSERT (scm_is_integer (color_s), color_s, SCM_ARG6, s_set_line_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (line_s);
   int x1 = scm_to_int (x1_s);
   int y1 = scm_to_int (y1_s);
@@ -941,30 +933,30 @@ SCM_DEFINE (set_line_x, "%set-line!", 6, 0, 0,
   int y2 = scm_to_int (y2_s);
 
   /* We may need to update connectivity. */
-  s_conn_remove_object_connections (toplevel, obj);
+  s_conn_remove_object_connections (obj);
 
   switch (obj->type) {
   case OBJ_LINE:
-    geda_line_object_modify (toplevel, obj, x1, y1, LINE_END1);
-    geda_line_object_modify (toplevel, obj, x2, y2, LINE_END2);
+    geda_line_object_modify (obj, x1, y1, LINE_END1);
+    geda_line_object_modify (obj, x2, y2, LINE_END2);
     break;
   case OBJ_NET:
-    geda_net_object_modify (toplevel, obj, x1, y1, 0);
-    geda_net_object_modify (toplevel, obj, x2, y2, 1);
+    geda_net_object_modify (obj, x1, y1, 0);
+    geda_net_object_modify (obj, x2, y2, 1);
     break;
   case OBJ_BUS:
-    geda_bus_object_modify (toplevel, obj, x1, y1, 0);
-    geda_bus_object_modify (toplevel, obj, x2, y2, 1);
+    geda_bus_object_modify (obj, x1, y1, 0);
+    geda_bus_object_modify (obj, x2, y2, 1);
     break;
   case OBJ_PIN:
     /* Swap ends according to pin's whichend flag. */
-    geda_pin_object_modify (toplevel, obj, x1, y1, obj->whichend ? 1 : 0);
-    geda_pin_object_modify (toplevel, obj, x2, y2, obj->whichend ? 0 : 1);
+    geda_pin_object_modify (obj, x1, y1, obj->whichend ? 1 : 0);
+    geda_pin_object_modify (obj, x2, y2, obj->whichend ? 0 : 1);
     break;
   default:
     return line_s;
   }
-  o_set_color (toplevel, obj, scm_to_int (color_s));
+  o_set_color (obj, scm_to_int (color_s));
 
   /* We may need to update connectivity. */
   PAGE *page = o_get_page (obj);
@@ -1036,8 +1028,7 @@ SCM_DEFINE (make_net, "%make-net", 0, 0, 0,
   OBJECT *obj;
   SCM result;
 
-  obj = geda_net_object_new (edascm_c_current_toplevel (),
-                             OBJ_NET, NET_COLOR, 0, 0, 0, 0);
+  obj = geda_net_object_new (OBJ_NET, NET_COLOR, 0, 0, 0, 0);
 
 
   result = edascm_from_object (obj);
@@ -1067,8 +1058,7 @@ SCM_DEFINE (make_bus, "%make-bus", 0, 0, 0,
   OBJECT *obj;
   SCM result;
 
-  obj = geda_bus_object_new (edascm_c_current_toplevel (),
-                             BUS_COLOR,
+  obj = geda_bus_object_new (BUS_COLOR,
                              0,
                              0,
                              0,
@@ -1112,8 +1102,7 @@ SCM_DEFINE (make_pin, "%make-pin", 1, 0, 0,
                     scm_list_1 (type_s));
   }
 
-  OBJECT *obj = geda_pin_object_new (edascm_c_current_toplevel (),
-                                     PIN_COLOR,
+  OBJECT *obj = geda_pin_object_new (PIN_COLOR,
                                      0,
                                      0,
                                      0,
@@ -1177,8 +1166,7 @@ SCM_DEFINE (pin_type, "%pin-type", 1, 0, 0,
 SCM_DEFINE (make_box, "%make-box", 0, 0, 0,
             (), "Create a new box object.")
 {
-  OBJECT *obj = geda_box_object_new (edascm_c_current_toplevel (),
-                                     OBJ_BOX, DEFAULT_COLOR,
+  OBJECT *obj = geda_box_object_new (OBJ_BOX, DEFAULT_COLOR,
                                      0, 0, 0, 0);
 
   SCM result = edascm_from_object (obj);
@@ -1219,12 +1207,11 @@ SCM_DEFINE (set_box_x, "%set-box!", 6, 0, 0,
   SCM_ASSERT (scm_is_integer (y2_s),    y2_s,    SCM_ARG5, s_set_box_x);
   SCM_ASSERT (scm_is_integer (color_s), color_s, SCM_ARG6, s_set_box_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (box_s);
-  geda_box_object_modify_all (toplevel, obj,
+  geda_box_object_modify_all (obj,
                               scm_to_int (x1_s), scm_to_int (y1_s),
                               scm_to_int (x2_s), scm_to_int (y2_s));
-  o_set_color (toplevel, obj, scm_to_int (color_s));
+  o_set_color (obj, scm_to_int (color_s));
 
   o_page_changed (obj);
 
@@ -1275,8 +1262,7 @@ SCM_DEFINE (box_info, "%box-info", 1, 0, 0,
 SCM_DEFINE (make_circle, "%make-circle", 0, 0, 0,
             (), "Create a new circle object.")
 {
-  GedaObject *object = geda_circle_object_new (edascm_c_current_toplevel (),
-                                               DEFAULT_COLOR,
+  GedaObject *object = geda_circle_object_new (DEFAULT_COLOR,
                                                0,
                                                0,
                                                1);
@@ -1317,12 +1303,11 @@ SCM_DEFINE (set_circle_x, "%set-circle!", 5, 0, 0,
   SCM_ASSERT (scm_is_integer (r_s),     r_s,     SCM_ARG4, s_set_circle_x);
   SCM_ASSERT (scm_is_integer (color_s), color_s, SCM_ARG5, s_set_circle_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (circle_s);
-  geda_circle_object_modify (toplevel, obj, scm_to_int(x_s), scm_to_int(y_s),
+  geda_circle_object_modify (obj, scm_to_int(x_s), scm_to_int(y_s),
                              CIRCLE_CENTER);
-  geda_circle_object_modify (toplevel, obj, scm_to_int(r_s), 0, CIRCLE_RADIUS);
-  o_set_color (toplevel, obj, scm_to_int (color_s));
+  geda_circle_object_modify (obj, scm_to_int(r_s), 0, CIRCLE_RADIUS);
+  o_set_color (obj, scm_to_int (color_s));
 
   o_page_changed (obj);
 
@@ -1371,8 +1356,7 @@ SCM_DEFINE (circle_info, "%circle-info", 1, 0, 0,
 SCM_DEFINE (make_arc, "%make-arc", 0, 0, 0,
             (), "Create a new arc object.")
 {
-  GedaObject *object = geda_arc_object_new (edascm_c_current_toplevel (),
-                                            DEFAULT_COLOR,
+  GedaObject *object = geda_arc_object_new (DEFAULT_COLOR,
                                             0,
                                             0,
                                             1,
@@ -1422,13 +1406,12 @@ SCM_DEFINE (set_arc_x, "%set-arc!", 7, 0, 0,
   SCM_ASSERT (scm_is_integer (end_angle_s),
                                   end_angle_s, SCM_ARG6, s_set_arc_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (arc_s);
-  geda_arc_object_modify (toplevel, obj, scm_to_int(x_s), scm_to_int(y_s), ARC_CENTER);
-  geda_arc_object_modify (toplevel, obj, scm_to_int(r_s), 0, ARC_RADIUS);
-  geda_arc_object_modify (toplevel, obj, scm_to_int(start_angle_s), 0, ARC_START_ANGLE);
-  geda_arc_object_modify (toplevel, obj, scm_to_int(end_angle_s), 0, ARC_SWEEP_ANGLE);
-  o_set_color (toplevel, obj, scm_to_int (color_s));
+  geda_arc_object_modify (obj, scm_to_int(x_s), scm_to_int(y_s), ARC_CENTER);
+  geda_arc_object_modify (obj, scm_to_int(r_s), 0, ARC_RADIUS);
+  geda_arc_object_modify (obj, scm_to_int(start_angle_s), 0, ARC_START_ANGLE);
+  geda_arc_object_modify (obj, scm_to_int(end_angle_s), 0, ARC_SWEEP_ANGLE);
+  o_set_color (obj, scm_to_int (color_s));
 
   o_page_changed (obj);
 
@@ -1483,8 +1466,7 @@ SCM_DEFINE (arc_info, "%arc-info", 1, 0, 0,
 SCM_DEFINE (make_text, "%make-text", 0, 0, 0,
             (), "Create a new text object.")
 {
-  OBJECT *obj = geda_text_object_new (edascm_c_current_toplevel (),
-                                      DEFAULT_COLOR,
+  OBJECT *obj = geda_text_object_new (DEFAULT_COLOR,
                                       0,
                                       0,
                                       LOWER_LEFT,
@@ -1547,7 +1529,6 @@ SCM_DEFINE (set_text_x, "%set-text!", 10, 0, 0,
   SCM_ASSERT (scm_is_symbol (show_s),    show_s,     9, s_set_text_x);
   SCM_ASSERT (scm_is_integer (color_s),  color_s,   10, s_set_text_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (text_s);
 
   /* Alignment. Sadly we can't switch on pointers. :-( */
@@ -1603,7 +1584,7 @@ SCM_DEFINE (set_text_x, "%set-text!", 10, 0, 0,
   }
 
   /* Actually make changes */
-  o_emit_pre_change_notify (toplevel, obj);
+  o_emit_pre_change_notify (obj);
 
   obj->text->x = scm_to_int (x_s);
   obj->text->y = scm_to_int (y_s);
@@ -1614,16 +1595,16 @@ SCM_DEFINE (set_text_x, "%set-text!", 10, 0, 0,
   obj->visibility = visibility;
   obj->show_name_value = show;
 
-  o_emit_change_notify (toplevel, obj);
+  o_emit_change_notify (obj);
 
   char *tmp = scm_to_utf8_string (string_s);
-  o_text_set_string (toplevel, obj, tmp);
+  o_text_set_string (obj, tmp);
   free (tmp);
 
-  o_text_recreate (toplevel, obj);
+  o_text_recreate (obj);
 
   /* Color */
-  o_set_color (toplevel, obj, scm_to_int (color_s));
+  o_set_color (obj, scm_to_int (color_s));
 
   o_page_changed (obj);
 
@@ -1759,9 +1740,8 @@ SCM_DEFINE (object_component, "%object-component", 1, 0, 0,
   SCM_ASSERT (edascm_is_object (obj_s), obj_s,
               SCM_ARG1, s_object_component);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
-  OBJECT *parent = o_get_parent (toplevel, obj);
+  OBJECT *parent = o_get_parent (obj);
 
   if (parent == NULL) return SCM_BOOL_F;
 
@@ -1781,8 +1761,7 @@ SCM_DEFINE (object_component, "%object-component", 1, 0, 0,
 SCM_DEFINE (make_path, "%make-path", 0, 0, 0,
             (), "Create a new path object")
 {
-  OBJECT *obj = geda_path_object_new (edascm_c_current_toplevel (),
-                                      OBJ_PATH, DEFAULT_COLOR, "");
+  OBJECT *obj = geda_path_object_new (OBJ_PATH, DEFAULT_COLOR, "");
 
   SCM result = edascm_from_object (obj);
 
@@ -1912,7 +1891,6 @@ SCM_DEFINE (path_remove_x, "%path-remove!", 2, 0, 0,
               SCM_ARG1, s_path_ref);
   SCM_ASSERT (scm_is_integer (index_s), index_s, SCM_ARG2, s_path_ref);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
   int idx = scm_to_int (index_s);
 
@@ -1922,7 +1900,7 @@ SCM_DEFINE (path_remove_x, "%path-remove!", 2, 0, 0,
 
   }
 
-  o_emit_pre_change_notify (toplevel, obj);
+  o_emit_pre_change_notify (obj);
 
   if (idx + 1 == obj->path->num_sections) {
     /* Section is last in path */
@@ -1937,7 +1915,7 @@ SCM_DEFINE (path_remove_x, "%path-remove!", 2, 0, 0,
     obj->path->num_sections--;
   }
 
-  o_emit_change_notify (toplevel, obj);
+  o_emit_change_notify (obj);
   o_page_changed (obj);
 
   return obj_s;
@@ -1986,7 +1964,6 @@ SCM_DEFINE (path_insert_x, "%path-insert", 3, 6, 0,
   SCM_ASSERT (scm_is_integer (index_s), index_s, SCM_ARG2, s_path_insert_x);
   SCM_ASSERT (scm_is_symbol (type_s), type_s, SCM_ARG3, s_path_insert_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
   PATH *path = obj->path;
   PATH_SECTION section = {(PATH_CODE) 0, 0, 0, 0, 0, 0, 0};
@@ -2031,7 +2008,7 @@ SCM_DEFINE (path_insert_x, "%path-insert", 3, 6, 0,
   }
 
   /* Start making changes */
-  o_emit_pre_change_notify (toplevel, obj);
+  o_emit_pre_change_notify (obj);
 
   /* Make sure there's enough space for the new element */
   if (path->num_sections == path->num_sections_max) {
@@ -2052,7 +2029,7 @@ SCM_DEFINE (path_insert_x, "%path-insert", 3, 6, 0,
   path->num_sections++;
   path->sections[idx] = section;
 
-  o_emit_change_notify (toplevel, obj);
+  o_emit_change_notify (obj);
   o_page_changed (obj);
 
   return obj_s;
@@ -2072,8 +2049,7 @@ SCM_DEFINE (path_insert_x, "%path-insert", 3, 6, 0,
 SCM_DEFINE (make_picture, "%make-picture", 0, 0, 0, (),
             "Create a new picture object")
 {
-  OBJECT *obj = o_picture_new (edascm_c_current_toplevel (),
-                               NULL, 0, NULL, OBJ_PICTURE,
+  OBJECT *obj = o_picture_new (NULL, 0, NULL, OBJ_PICTURE,
                                0, 0, 0, 0, 0, FALSE, TRUE);
   SCM result = edascm_from_object (obj);
 
@@ -2155,7 +2131,6 @@ SCM_DEFINE (set_picture_x, "%set-picture!", 7, 0, 0,
   SCM_ASSERT (scm_is_integer (y2_s), x1_s, SCM_ARG5, s_set_picture_x);
   SCM_ASSERT (scm_is_integer (angle_s), angle_s, SCM_ARG6, s_set_picture_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
 
   /* Angle */
@@ -2174,15 +2149,15 @@ SCM_DEFINE (set_picture_x, "%set-picture!", 7, 0, 0,
                     scm_list_1 (angle_s));
   }
 
-  o_emit_pre_change_notify (toplevel, obj);
+  o_emit_pre_change_notify (obj);
 
   obj->picture->angle = scm_to_int (angle_s);
   obj->picture->mirrored = scm_is_true (mirror_s);
-  o_picture_modify_all (toplevel, obj,
+  o_picture_modify_all (obj,
                         scm_to_int (x1_s), scm_to_int (y1_s),
                         scm_to_int (x2_s), scm_to_int (y2_s));
 
-  o_emit_change_notify (toplevel, obj);
+  o_emit_change_notify (obj);
   return obj_s;
 }
 
@@ -2234,12 +2209,11 @@ SCM_DEFINE (set_picture_data_vector_x, "%set-picture-data/vector!",
 
   gboolean status;
   GError *error = NULL;
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
   gchar *filename = scm_to_utf8_string (filename_s);
   scm_dynwind_unwind_handler (g_free, filename, SCM_F_WIND_EXPLICITLY);
 
-  status = o_picture_set_from_buffer (toplevel, obj, filename,
+  status = o_picture_set_from_buffer (obj, filename,
                                       buf, len, &error);
 
   if (!status) {
@@ -2281,14 +2255,13 @@ SCM_DEFINE (translate_object_x, "%translate-object!", 3, 0, 0,
   SCM_ASSERT (scm_is_integer (dy_s), dy_s,
               SCM_ARG3, s_translate_object_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
   int dx = scm_to_int (dx_s);
   int dy = scm_to_int (dy_s);
 
-  o_emit_pre_change_notify (toplevel, obj);
+  o_emit_pre_change_notify (obj);
   geda_object_translate (obj, dx, dy);
-  o_emit_change_notify (toplevel, obj);
+  o_emit_change_notify (obj);
   o_page_changed (obj);
 
   return obj_s;
@@ -2323,7 +2296,6 @@ SCM_DEFINE (rotate_object_x, "%rotate-object!", 4, 0, 0,
   SCM_ASSERT (scm_is_integer (angle_s), angle_s,
               SCM_ARG4, s_rotate_object_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
   int x = scm_to_int (x_s);
   int y = scm_to_int (y_s);
@@ -2337,9 +2309,9 @@ SCM_DEFINE (rotate_object_x, "%rotate-object!", 4, 0, 0,
   SCM_ASSERT (angle % 90 == 0, angle_s,
               SCM_ARG4, s_rotate_object_x);
 
-  o_emit_pre_change_notify (toplevel, obj);
-  geda_object_rotate (toplevel, x, y, angle, obj);
-  o_emit_change_notify (toplevel, obj);
+  o_emit_pre_change_notify (obj);
+  geda_object_rotate (x, y, angle, obj);
+  o_emit_change_notify (obj);
   o_page_changed (obj);
 
   return obj_s;
@@ -2366,13 +2338,12 @@ SCM_DEFINE (mirror_object_x, "%mirror-object!", 2, 0, 0,
   SCM_ASSERT (scm_is_integer (x_s), x_s,
               SCM_ARG2, s_mirror_object_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
   int x = scm_to_int (x_s);
 
-  o_emit_pre_change_notify (toplevel, obj);
-  geda_object_mirror (toplevel, x, 0, obj);
-  o_emit_change_notify (toplevel, obj);
+  o_emit_pre_change_notify (obj);
+  geda_object_mirror (x, 0, obj);
+  o_emit_change_notify (obj);
   o_page_changed (obj);
 
   return obj_s;
diff --git a/liblepton/src/scheme_page.c b/liblepton/src/scheme_page.c
index a85a4dfc5..a51084cf5 100644
--- a/liblepton/src/scheme_page.c
+++ b/liblepton/src/scheme_page.c
@@ -236,7 +236,6 @@ SCM_DEFINE (page_append_x, "%page-append!", 2, 0, 0,
 
   PAGE *page = edascm_to_page (page_s);
   OBJECT *obj = edascm_to_object (obj_s);
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
 
   /* Check that the object isn't already attached to something. */
   PAGE *curr_page = o_get_page (obj);
@@ -251,9 +250,9 @@ SCM_DEFINE (page_append_x, "%page-append!", 2, 0, 0,
 
   /* Object cleanup now managed by C code. */
   edascm_c_set_gc (obj_s, 0);
-  o_emit_pre_change_notify (toplevel, obj);
-  s_page_append (toplevel, page, obj);
-  o_emit_change_notify (toplevel, obj);
+  o_emit_pre_change_notify (obj);
+  s_page_append (page, obj);
+  o_emit_change_notify (obj);
   page->CHANGED = 1; /* Ugh. */
 
   return page_s;
@@ -281,7 +280,6 @@ SCM_DEFINE (page_remove_x, "%page-remove!", 2, 0, 0,
 
   PAGE *page = edascm_to_page (page_s);
   OBJECT *obj = edascm_to_object (obj_s);
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
 
   /* Check that the object is not attached to something else. */
   PAGE *curr_page = o_get_page (obj);
@@ -308,12 +306,12 @@ SCM_DEFINE (page_remove_x, "%page-remove!", 2, 0, 0,
 
   if (curr_page == NULL) return obj_s;
 
-  o_emit_pre_change_notify (toplevel, obj);
-  s_page_remove (toplevel, page, obj);
+  o_emit_pre_change_notify (obj);
+  s_page_remove (page, obj);
   page->CHANGED = 1; /* Ugh. */
   /* If the object is currently selected, unselect it. */
-  o_selection_remove (toplevel, page->selection_list, obj);
-  o_emit_change_notify (toplevel, obj);
+  o_selection_remove (page->selection_list, obj);
+  o_emit_change_notify (obj);
 
   /* Object cleanup now managed by Guile. */
   edascm_c_set_gc (obj_s, 1);
@@ -438,7 +436,7 @@ SCM_DEFINE (string_to_page, "%string->page", 2, 0, 0,
                  _("Parse error: ~s"), scm_list_1 (error_message), SCM_EOL);
   }
 
-  s_page_append_list (toplevel, page, objects);
+  s_page_append_list (page, objects);
 
   return edascm_from_page (page);
 }
diff --git a/liblepton/src/scheme_smob.c b/liblepton/src/scheme_smob.c
index 7413274f6..5b8140577 100644
--- a/liblepton/src/scheme_smob.c
+++ b/liblepton/src/scheme_smob.c
@@ -298,9 +298,7 @@ smob_free (SCM smob)
                  __FUNCTION__, data);
       break;
     case GEDA_SMOB_OBJECT:
-      /* See edascm_from_object() for an explanation of why OBJECT
-       * smobs store a TOPLEVEL in the second data word */
-      s_delete_object ((TOPLEVEL *) SCM_SMOB_DATA_2 (smob), (OBJECT *) data);
+      s_delete_object ((OBJECT *) data);
       break;
     case GEDA_SMOB_CONFIG:
       /* These are reference counted, so the structure will have
diff --git a/liblepton/tests/test_arc_object.c b/liblepton/tests/test_arc_object.c
index a3e34090c..21fdd8869 100644
--- a/liblepton/tests/test_arc_object.c
+++ b/liblepton/tests/test_arc_object.c
@@ -15,8 +15,7 @@ check_construction ()
     gint start_angle = g_test_rand_int_range (0, 359);
     gint sweep_angle = g_test_rand_int_range (0, 360);
 
-    GedaObject *object0 = geda_arc_object_new (toplevel,
-                                               color,
+    GedaObject *object0 = geda_arc_object_new (color,
                                                center_x,
                                                center_y,
                                                radius,
@@ -33,13 +32,13 @@ check_construction ()
     g_assert_cmpint (start_angle, ==, geda_arc_object_get_start_angle (object0));
     g_assert_cmpint (sweep_angle, ==, geda_arc_object_get_sweep_angle (object0));
 
-    GedaObject *object1 = geda_arc_object_copy (toplevel, object0);
+    GedaObject *object1 = geda_arc_object_copy (object0);
 
     g_assert (object1 != NULL);
     g_assert (object1 != object0);
     g_assert_cmpint (OBJ_ARC, ==, object1->type);
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
 
     g_assert_cmpint (center_x, ==, geda_arc_object_get_center_x (object1));
     g_assert_cmpint (center_y, ==, geda_arc_object_get_center_y (object1));
@@ -48,7 +47,7 @@ check_construction ()
     g_assert_cmpint (start_angle, ==, geda_arc_object_get_start_angle (object1));
     g_assert_cmpint (sweep_angle, ==, geda_arc_object_get_sweep_angle (object1));
 
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
   }
 
   s_toplevel_delete (toplevel);
@@ -68,8 +67,7 @@ check_accessors ()
     gint start_angle = g_test_rand_int_range (0, 359);
     gint sweep_angle = g_test_rand_int_range (0, 360);
 
-    GedaObject *object0 = geda_arc_object_new (toplevel,
-                                               color,
+    GedaObject *object0 = geda_arc_object_new (color,
                                                center_x,
                                                center_y,
                                                radius,
@@ -88,7 +86,7 @@ check_accessors ()
 
     geda_arc_object_set_center_x (object0, center_x);
     geda_arc_object_set_center_y (object0, center_y);
-    o_set_color (toplevel, object0, color);
+    o_set_color (object0, color);
     geda_arc_object_set_radius (object0, radius);
     geda_arc_object_set_start_angle (object0, start_angle);
     geda_arc_object_set_sweep_angle (object0, sweep_angle);
@@ -100,7 +98,7 @@ check_accessors ()
     g_assert_cmpint (start_angle, ==, geda_arc_object_get_start_angle (object0));
     g_assert_cmpint (sweep_angle, ==, geda_arc_object_get_sweep_angle (object0));
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
   }
 
   s_toplevel_delete (toplevel);
@@ -125,8 +123,7 @@ check_serialization ()
     gint start_angle = g_test_rand_int_range (0, 359);
     gint sweep_angle = g_test_rand_int_range (0, 360);
 
-    GedaObject *object0 = geda_arc_object_new (toplevel,
-                                               color,
+    GedaObject *object0 = geda_arc_object_new (color,
                                                center_x,
                                                center_y,
                                                radius,
@@ -136,11 +133,10 @@ check_serialization ()
     g_assert (object0 != NULL);
 
     gchar *buffer0 = geda_arc_object_to_buffer (object0);
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
     g_assert (buffer0 != NULL);
 
-    GedaObject *object1 = o_arc_read (toplevel,
-                                      buffer0,
+    GedaObject *object1 = o_arc_read (buffer0,
                                       version,
                                       FILEFORMAT_VERSION,
                                       NULL);
@@ -155,7 +151,7 @@ check_serialization ()
     g_assert_cmpint (sweep_angle, ==, geda_arc_object_get_sweep_angle (object1));
 
     gchar *buffer1 = geda_arc_object_to_buffer (object1);
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
     g_assert (buffer1 != NULL);
 
     g_assert_cmpstr (buffer0, ==, buffer1);
diff --git a/liblepton/tests/test_bus_object.c b/liblepton/tests/test_bus_object.c
index bc9683527..9b260c758 100644
--- a/liblepton/tests/test_bus_object.c
+++ b/liblepton/tests/test_bus_object.c
@@ -15,8 +15,7 @@ check_construction ()
     gint color = g_test_rand_int_range (0, MAX_COLORS - 1);
     gint ripper = g_test_rand_int_range (-1, 2);
 
-    GedaObject *object0 = geda_bus_object_new (toplevel,
-                                               color,
+    GedaObject *object0 = geda_bus_object_new (color,
                                                x0,
                                                y0,
                                                x1,
@@ -33,13 +32,13 @@ check_construction ()
     g_assert_cmpint (color, ==, geda_object_get_color (object0));
     g_assert_cmpint (ripper, ==, geda_bus_object_get_ripper_direction (object0));
 
-    GedaObject *object1 = geda_bus_object_copy (toplevel, object0);
+    GedaObject *object1 = geda_bus_object_copy (object0);
 
     g_assert (object1 != NULL);
     g_assert (object1 != object0);
     g_assert_cmpint (OBJ_BUS, ==, object1->type);
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
 
     g_assert_cmpint (x0, ==, geda_bus_object_get_x0 (object1));
     g_assert_cmpint (y0, ==, geda_bus_object_get_y0 (object1));
@@ -48,7 +47,7 @@ check_construction ()
     g_assert_cmpint (color, ==, geda_object_get_color (object1));
     g_assert_cmpint (ripper, ==, geda_bus_object_get_ripper_direction (object1));
 
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
   }
 
   s_toplevel_delete (toplevel);
@@ -68,8 +67,7 @@ check_accessors ()
     gint color = g_test_rand_int_range (0, MAX_COLORS - 1);
     gint ripper = g_test_rand_int_range (-1, 2);
 
-    GedaObject *object0 = geda_bus_object_new (toplevel,
-                                               color,
+    GedaObject *object0 = geda_bus_object_new (color,
                                                x0,
                                                y0,
                                                x1,
@@ -90,7 +88,7 @@ check_accessors ()
     geda_bus_object_set_y0 (object0, y0);
     geda_bus_object_set_x1 (object0, x1);
     geda_bus_object_set_y1 (object0, y1);
-    o_set_color (toplevel, object0, color);
+    o_set_color (object0, color);
     geda_bus_object_set_ripper_direction (object0, ripper);
 
     g_assert_cmpint (x0, ==, geda_bus_object_get_x0 (object0));
@@ -100,7 +98,7 @@ check_accessors ()
     g_assert_cmpint (color, ==, geda_object_get_color (object0));
     g_assert_cmpint (ripper, ==, geda_bus_object_get_ripper_direction (object0));
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
   }
 
   s_toplevel_delete (toplevel);
@@ -125,8 +123,7 @@ check_serialization ()
     gint color = g_test_rand_int_range (0, MAX_COLORS - 1);
     gint ripper = g_test_rand_int_range (-1, 2);
 
-    GedaObject *object0 = geda_bus_object_new (toplevel,
-                                               color,
+    GedaObject *object0 = geda_bus_object_new (color,
                                                x0,
                                                y0,
                                                x1,
@@ -136,11 +133,10 @@ check_serialization ()
     g_assert (object0 != NULL);
 
     gchar *buffer0 = geda_bus_object_to_buffer (object0);
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
     g_assert (buffer0 != NULL);
 
-    GedaObject *object1 = o_bus_read (toplevel,
-                                      buffer0,
+    GedaObject *object1 = o_bus_read (buffer0,
                                       version,
                                       FILEFORMAT_VERSION,
                                       NULL);
@@ -155,7 +151,7 @@ check_serialization ()
     g_assert_cmpint (ripper, ==, geda_bus_object_get_ripper_direction (object1));
 
     gchar *buffer1 = geda_bus_object_to_buffer (object1);
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
     g_assert (buffer1 != NULL);
 
     g_assert_cmpstr (buffer0, ==, buffer1);
diff --git a/liblepton/tests/test_circle_object.c b/liblepton/tests/test_circle_object.c
index b81e2fbb2..94d056014 100644
--- a/liblepton/tests/test_circle_object.c
+++ b/liblepton/tests/test_circle_object.c
@@ -13,8 +13,7 @@ check_construction ()
     gint color = g_test_rand_int_range (0, MAX_COLORS - 1);
     gint radius = g_test_rand_int_range (0, G_MAXINT);
 
-    GedaObject *object0 = geda_circle_object_new (toplevel,
-                                                  color,
+    GedaObject *object0 = geda_circle_object_new (color,
                                                   center_x,
                                                   center_y,
                                                   radius);
@@ -27,20 +26,20 @@ check_construction ()
     g_assert_cmpint (color, ==, geda_object_get_color (object0));
     g_assert_cmpint (radius, ==, geda_circle_object_get_radius (object0));
 
-    GedaObject *object1 = geda_circle_object_copy (toplevel, object0);
+    GedaObject *object1 = geda_circle_object_copy (object0);
 
     g_assert (object1 != NULL);
     g_assert (object1 != object0);
     g_assert_cmpint (OBJ_CIRCLE, ==, object1->type);
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
 
     g_assert_cmpint (center_x, ==, geda_circle_object_get_center_x (object1));
     g_assert_cmpint (center_y, ==, geda_circle_object_get_center_y (object1));
     g_assert_cmpint (color, ==, geda_object_get_color (object1));
     g_assert_cmpint (radius, ==, geda_circle_object_get_radius (object1));
 
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
   }
 
   s_toplevel_delete (toplevel);
@@ -58,8 +57,7 @@ check_accessors ()
     gint color = g_test_rand_int_range (0, MAX_COLORS - 1);
     gint radius = g_test_rand_int_range (0, G_MAXINT);
 
-    GedaObject *object0 = geda_circle_object_new (toplevel,
-                                                  color,
+    GedaObject *object0 = geda_circle_object_new (color,
                                                   center_x,
                                                   center_y,
                                                   radius);
@@ -74,7 +72,7 @@ check_accessors ()
 
     geda_circle_object_set_center_x (object0, center_x);
     geda_circle_object_set_center_y (object0, center_y);
-    o_set_color (toplevel, object0, color);
+    o_set_color (object0, color);
     geda_circle_object_set_radius (object0, radius);
 
     g_assert_cmpint (center_x, ==, geda_circle_object_get_center_x (object0));
@@ -82,7 +80,7 @@ check_accessors ()
     g_assert_cmpint (color, ==, geda_object_get_color (object0));
     g_assert_cmpint (radius, ==, geda_circle_object_get_radius (object0));
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
   }
 
   s_toplevel_delete (toplevel);
@@ -105,8 +103,7 @@ check_serialization ()
     gint color = g_test_rand_int_range (0, MAX_COLORS - 1);
     gint radius = g_test_rand_int_range (0, G_MAXINT);
 
-    GedaObject *object0 = geda_circle_object_new (toplevel,
-                                                  color,
+    GedaObject *object0 = geda_circle_object_new (color,
                                                   center_x,
                                                   center_y,
                                                   radius);
@@ -114,11 +111,10 @@ check_serialization ()
     g_assert (object0 != NULL);
 
     gchar *buffer0 = geda_circle_object_to_buffer (object0);
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
     g_assert (buffer0 != NULL);
 
-    GedaObject *object1 = o_circle_read (toplevel,
-                                         buffer0,
+    GedaObject *object1 = o_circle_read (buffer0,
                                          version,
                                          FILEFORMAT_VERSION,
                                          NULL);
@@ -131,7 +127,7 @@ check_serialization ()
     g_assert_cmpint (radius, ==, geda_circle_object_get_radius (object1));
 
     gchar *buffer1 = geda_circle_object_to_buffer (object1);
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
     g_assert (buffer1 != NULL);
 
     g_assert_cmpstr (buffer0, ==, buffer1);
diff --git a/liblepton/tests/test_line_object.c b/liblepton/tests/test_line_object.c
index acf47feb2..1bf6b4ce8 100644
--- a/liblepton/tests/test_line_object.c
+++ b/liblepton/tests/test_line_object.c
@@ -14,8 +14,7 @@ check_construction ()
     gint y1 = g_test_rand_int ();
     gint color = g_test_rand_int_range (0, MAX_COLORS - 1);
 
-    GedaObject *object0 = geda_line_object_new (toplevel,
-                                                color,
+    GedaObject *object0 = geda_line_object_new (color,
                                                 x0,
                                                 y0,
                                                 x1,
@@ -30,13 +29,13 @@ check_construction ()
     g_assert_cmpint (y1, ==, geda_line_object_get_y1 (object0));
     g_assert_cmpint (color, ==, geda_object_get_color (object0));
 
-    GedaObject *object1 = geda_line_object_copy (toplevel, object0);
+    GedaObject *object1 = geda_line_object_copy (object0);
 
     g_assert (object1 != NULL);
     g_assert (object1 != object0);
     g_assert_cmpint (OBJ_LINE, ==, object1->type);
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
 
     g_assert_cmpint (x0, ==, geda_line_object_get_x0 (object1));
     g_assert_cmpint (y0, ==, geda_line_object_get_y0 (object1));
@@ -44,7 +43,7 @@ check_construction ()
     g_assert_cmpint (y1, ==, geda_line_object_get_y1 (object1));
     g_assert_cmpint (color, ==, geda_object_get_color (object1));
 
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
   }
 
   s_toplevel_delete (toplevel);
@@ -63,8 +62,7 @@ check_accessors ()
     gint y1 = g_test_rand_int ();
     gint color = g_test_rand_int_range (0, MAX_COLORS - 1);
 
-    GedaObject *object0 = geda_line_object_new (toplevel,
-                                                color,
+    GedaObject *object0 = geda_line_object_new (color,
                                                 x0,
                                                 y0,
                                                 x1,
@@ -83,7 +81,7 @@ check_accessors ()
     geda_line_object_set_y0 (object0, y0);
     geda_line_object_set_x1 (object0, x1);
     geda_line_object_set_y1 (object0, y1);
-    o_set_color (toplevel, object0, color);
+    o_set_color (object0, color);
 
     g_assert_cmpint (x0, ==, geda_line_object_get_x0 (object0));
     g_assert_cmpint (y0, ==, geda_line_object_get_y0 (object0));
@@ -91,7 +89,7 @@ check_accessors ()
     g_assert_cmpint (y1, ==, geda_line_object_get_y1 (object0));
     g_assert_cmpint (color, ==, geda_object_get_color (object0));
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
   }
 
   s_toplevel_delete (toplevel);
@@ -115,8 +113,7 @@ check_serialization ()
     gint y1 = g_test_rand_int ();
     gint color = g_test_rand_int_range (0, MAX_COLORS - 1);
 
-    GedaObject *object0 = geda_line_object_new (toplevel,
-                                                color,
+    GedaObject *object0 = geda_line_object_new (color,
                                                 x0,
                                                 y0,
                                                 x1,
@@ -125,11 +122,10 @@ check_serialization ()
     g_assert (object0 != NULL);
 
     gchar *buffer0 = geda_line_object_to_buffer (object0);
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
     g_assert (buffer0 != NULL);
 
-    GedaObject *object1 = o_line_read (toplevel,
-                                       buffer0,
+    GedaObject *object1 = o_line_read (buffer0,
                                        version,
                                        FILEFORMAT_VERSION,
                                        NULL);
@@ -143,7 +139,7 @@ check_serialization ()
     g_assert_cmpint (color, ==, geda_object_get_color (object1));
 
     gchar *buffer1 = geda_line_object_to_buffer (object1);
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
     g_assert (buffer1 != NULL);
 
     g_assert_cmpstr (buffer0, ==, buffer1);
diff --git a/liblepton/tests/test_net_object.c b/liblepton/tests/test_net_object.c
index 966aa2f7b..e8d2ce6ff 100644
--- a/liblepton/tests/test_net_object.c
+++ b/liblepton/tests/test_net_object.c
@@ -14,8 +14,7 @@ check_construction ()
     gint y1 = g_test_rand_int ();
     gint color = g_test_rand_int_range (0, MAX_COLORS - 1);
 
-    GedaObject *object0 = geda_net_object_new (toplevel,
-                                               OBJ_NET,
+    GedaObject *object0 = geda_net_object_new (OBJ_NET,
                                                color,
                                                x0,
                                                y0,
@@ -31,13 +30,13 @@ check_construction ()
     g_assert_cmpint (y1, ==, geda_net_object_get_y1 (object0));
     g_assert_cmpint (color, ==, geda_object_get_color (object0));
 
-    GedaObject *object1 = geda_net_object_copy (toplevel, object0);
+    GedaObject *object1 = geda_net_object_copy (object0);
 
     g_assert (object1 != NULL);
     g_assert (object1 != object0);
     g_assert_cmpint (OBJ_NET, ==, object1->type);
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
 
     g_assert_cmpint (x0, ==, geda_net_object_get_x0 (object1));
     g_assert_cmpint (y0, ==, geda_net_object_get_y0 (object1));
@@ -45,7 +44,7 @@ check_construction ()
     g_assert_cmpint (y1, ==, geda_net_object_get_y1 (object1));
     g_assert_cmpint (color, ==, geda_object_get_color (object1));
 
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
   }
 
   s_toplevel_delete (toplevel);
@@ -64,8 +63,7 @@ check_accessors ()
     gint y1 = g_test_rand_int ();
     gint color = g_test_rand_int_range (0, MAX_COLORS - 1);
 
-    GedaObject *object0 = geda_net_object_new (toplevel,
-                                               OBJ_NET,
+    GedaObject *object0 = geda_net_object_new (OBJ_NET,
                                                color,
                                                x0,
                                                y0,
@@ -85,7 +83,7 @@ check_accessors ()
     geda_net_object_set_y0 (object0, y0);
     geda_net_object_set_x1 (object0, x1);
     geda_net_object_set_y1 (object0, y1);
-    o_set_color (toplevel, object0, color);
+    o_set_color (object0, color);
 
     g_assert_cmpint (x0, ==, geda_net_object_get_x0 (object0));
     g_assert_cmpint (y0, ==, geda_net_object_get_y0 (object0));
@@ -93,7 +91,7 @@ check_accessors ()
     g_assert_cmpint (y1, ==, geda_net_object_get_y1 (object0));
     g_assert_cmpint (color, ==, geda_object_get_color (object0));
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
   }
 
   s_toplevel_delete (toplevel);
@@ -117,8 +115,7 @@ check_serialization ()
     gint y1 = g_test_rand_int ();
     gint color = g_test_rand_int_range (0, MAX_COLORS - 1);
 
-    GedaObject *object0 = geda_net_object_new (toplevel,
-                                               OBJ_NET,
+    GedaObject *object0 = geda_net_object_new (OBJ_NET,
                                                color,
                                                x0,
                                                y0,
@@ -128,11 +125,10 @@ check_serialization ()
     g_assert (object0 != NULL);
 
     gchar *buffer0 = geda_net_object_to_buffer (object0);
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
     g_assert (buffer0 != NULL);
 
-    GedaObject *object1 = o_net_read (toplevel,
-                                      buffer0,
+    GedaObject *object1 = o_net_read (buffer0,
                                       version,
                                       FILEFORMAT_VERSION,
                                       NULL);
@@ -146,7 +142,7 @@ check_serialization ()
     g_assert_cmpint (color, ==, geda_object_get_color (object1));
 
     gchar *buffer1 = geda_net_object_to_buffer (object1);
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
     g_assert (buffer1 != NULL);
 
     g_assert_cmpstr (buffer0, ==, buffer1);
diff --git a/liblepton/tests/test_pin_object.c b/liblepton/tests/test_pin_object.c
index 332fcba85..39a91258f 100644
--- a/liblepton/tests/test_pin_object.c
+++ b/liblepton/tests/test_pin_object.c
@@ -16,8 +16,7 @@ check_construction ()
     gint type = g_test_rand_int_range (0, 2);
     gint which = g_test_rand_int_range (0, 2);
 
-    GedaObject *object0 = geda_pin_object_new (toplevel,
-                                               color,
+    GedaObject *object0 = geda_pin_object_new (color,
                                                x0,
                                                y0,
                                                x1,
@@ -34,13 +33,13 @@ check_construction ()
     g_assert_cmpint (y1, ==, geda_pin_object_get_y1 (object0));
     g_assert_cmpint (color, ==, geda_object_get_color (object0));
 
-    GedaObject *object1 = geda_pin_object_copy (toplevel, object0);
+    GedaObject *object1 = geda_pin_object_copy (object0);
 
     g_assert (object1 != NULL);
     g_assert (object1 != object0);
     g_assert_cmpint (OBJ_PIN, ==, object1->type);
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
 
     g_assert_cmpint (x0, ==, geda_pin_object_get_x0 (object1));
     g_assert_cmpint (y0, ==, geda_pin_object_get_y0 (object1));
@@ -48,7 +47,7 @@ check_construction ()
     g_assert_cmpint (y1, ==, geda_pin_object_get_y1 (object1));
     g_assert_cmpint (color, ==, geda_object_get_color (object1));
 
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
   }
 
   s_toplevel_delete (toplevel);
@@ -69,8 +68,7 @@ check_accessors ()
     gint type = g_test_rand_int_range (0, 2);
     gint which = g_test_rand_int_range (0, 2);
 
-    GedaObject *object0 = geda_pin_object_new (toplevel,
-                                               color,
+    GedaObject *object0 = geda_pin_object_new (color,
                                                x0,
                                                y0,
                                                x1,
@@ -91,7 +89,7 @@ check_accessors ()
     geda_pin_object_set_y0 (object0, y0);
     geda_pin_object_set_x1 (object0, x1);
     geda_pin_object_set_y1 (object0, y1);
-    o_set_color (toplevel, object0, color);
+    o_set_color (object0, color);
 
     g_assert_cmpint (x0, ==, geda_pin_object_get_x0 (object0));
     g_assert_cmpint (y0, ==, geda_pin_object_get_y0 (object0));
@@ -99,7 +97,7 @@ check_accessors ()
     g_assert_cmpint (y1, ==, geda_pin_object_get_y1 (object0));
     g_assert_cmpint (color, ==, geda_object_get_color (object0));
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
   }
 
   s_toplevel_delete (toplevel);
@@ -125,8 +123,7 @@ check_serialization ()
     gint type = g_test_rand_int_range (0, 2);
     gint which = g_test_rand_int_range (0, 2);
 
-    GedaObject *object0 = geda_pin_object_new (toplevel,
-                                               color,
+    GedaObject *object0 = geda_pin_object_new (color,
                                                x0,
                                                y0,
                                                x1,
@@ -137,11 +134,10 @@ check_serialization ()
     g_assert (object0 != NULL);
 
     gchar *buffer0 = geda_pin_object_to_buffer (object0);
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
     g_assert (buffer0 != NULL);
 
-    GedaObject *object1 = o_pin_read (toplevel,
-                                      buffer0,
+    GedaObject *object1 = o_pin_read (buffer0,
                                       version,
                                       FILEFORMAT_VERSION,
                                       NULL);
@@ -155,7 +151,7 @@ check_serialization ()
     g_assert_cmpint (color, ==, geda_object_get_color (object1));
 
     gchar *buffer1 = geda_pin_object_to_buffer (object1);
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
     g_assert (buffer1 != NULL);
 
     g_assert_cmpstr (buffer0, ==, buffer1);
diff --git a/liblepton/tests/test_text_object.c b/liblepton/tests/test_text_object.c
index f2e1a3bae..67bd25550 100644
--- a/liblepton/tests/test_text_object.c
+++ b/liblepton/tests/test_text_object.c
@@ -32,8 +32,7 @@ check_construction ()
     const gchar *string = strings[g_test_rand_int_range (0, STRINGS_COUNT)];
     gboolean visible = g_test_rand_bit ();
 
-    GedaObject *object0 = geda_text_object_new (toplevel,
-                                                color,
+    GedaObject *object0 = geda_text_object_new (color,
                                                 x,
                                                 y,
                                                 alignment,
@@ -55,13 +54,13 @@ check_construction ()
     g_assert_cmpint (visible, ==, geda_object_get_visible (object0));
     g_assert_cmpstr (string, ==, geda_text_object_get_string (object0));
 
-    GedaObject *object1 = geda_text_object_copy (toplevel, object0);
+    GedaObject *object1 = geda_text_object_copy (object0);
 
     g_assert (object1 != NULL);
     g_assert (object1 != object0);
     g_assert_cmpint (OBJ_TEXT, ==, object1->type);
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
 
     g_assert_cmpint (x, ==, geda_text_object_get_x (object1));
     g_assert_cmpint (y, ==, geda_text_object_get_y (object1));
@@ -72,7 +71,7 @@ check_construction ()
     g_assert_cmpint (visible, ==, geda_object_get_visible (object1));
     g_assert_cmpstr (string, ==, geda_text_object_get_string (object1));
 
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
   }
 
   s_toplevel_delete (toplevel);
@@ -95,8 +94,7 @@ check_accessors ()
     const gchar *string = strings[g_test_rand_int_range (0, STRINGS_COUNT)];
     gboolean visible = g_test_rand_bit ();
 
-    GedaObject *object0 = geda_text_object_new (toplevel,
-                                                color,
+    GedaObject *object0 = geda_text_object_new (color,
                                                 x,
                                                 y,
                                                 alignment,
@@ -124,9 +122,9 @@ check_accessors ()
     geda_text_object_set_alignment (object0, alignment);
     geda_text_object_set_angle (object0, angle);
     geda_text_object_set_size (object0, size);
-    o_set_color (toplevel, object0, color);
-    o_set_visibility (toplevel, object0, visible);
-    o_text_set_string (toplevel, object0, string);
+    o_set_color (object0, color);
+    o_set_visibility (object0, visible);
+    o_text_set_string (object0, string);
 
     g_assert_cmpint (x, ==, geda_text_object_get_x (object0));
     g_assert_cmpint (y, ==, geda_text_object_get_y (object0));
@@ -143,7 +141,7 @@ check_accessors ()
     g_assert_cmpint (x, ==, temp_x);
     g_assert_cmpint (y, ==, temp_y);
 
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
   }
 
   s_toplevel_delete (toplevel);
@@ -171,8 +169,7 @@ check_serialization ()
     const gchar *string = strings[g_test_rand_int_range (0, STRINGS_COUNT)];
     gboolean visible = g_test_rand_bit ();
 
-    GedaObject *object0 = geda_text_object_new (toplevel,
-                                                color,
+    GedaObject *object0 = geda_text_object_new (color,
                                                 x,
                                                 y,
                                                 alignment,
@@ -185,19 +182,18 @@ check_serialization ()
     g_assert (object0 != NULL);
 
     gchar *buffer0 = geda_text_object_to_buffer (object0);
-    s_delete_object (toplevel, object0);
+    s_delete_object (object0);
     g_assert (buffer0 != NULL);
 
     TextBuffer *tb = s_textbuffer_new (buffer0, -1,
                                        "test_text_object.c::check_serialization()");
     const gchar *line = s_textbuffer_next_line (tb);
 
-    GedaObject *object1 = o_text_read (toplevel,
-                                      line,
-                                      tb,
-                                      version,
-                                      FILEFORMAT_VERSION,
-                                      NULL);
+    GedaObject *object1 = o_text_read (line,
+                                       tb,
+                                       version,
+                                       FILEFORMAT_VERSION,
+                                       NULL);
 
     g_assert (object1 != NULL);
     s_textbuffer_free (tb);
@@ -212,7 +208,7 @@ check_serialization ()
     g_assert_cmpstr (string, ==, geda_text_object_get_string (object1));
 
     gchar *buffer1 = geda_text_object_to_buffer (object1);
-    s_delete_object (toplevel, object1);
+    s_delete_object (object1);
     g_assert (buffer1 != NULL);
 
     g_assert_cmpstr (buffer0, ==, buffer1);
diff --git a/schematic/src/g_select.c b/schematic/src/g_select.c
index b393f95ab..bdff8cebb 100644
--- a/schematic/src/g_select.c
+++ b/schematic/src/g_select.c
@@ -70,7 +70,6 @@ SCM_DEFINE (select_object_x, "%select-object!", 1, 0, 0,
   SCM_ASSERT (edascm_is_object (obj_s), obj_s,
               SCM_ARG1, s_select_object_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
   PAGE *page = o_get_page (obj);
   if ((page == NULL) || (obj->parent != NULL)) {
@@ -81,7 +80,7 @@ SCM_DEFINE (select_object_x, "%select-object!", 1, 0, 0,
   }
 
   if (!obj->selected) {
-    o_selection_add (toplevel, page->selection_list, obj);
+    o_selection_add (page->selection_list, obj);
   }
 
   return obj_s;
@@ -107,7 +106,6 @@ SCM_DEFINE (deselect_object_x, "%deselect-object!", 1, 0, 0,
   SCM_ASSERT (edascm_is_object (obj_s), obj_s,
               SCM_ARG1, s_deselect_object_x);
 
-  TOPLEVEL *toplevel = edascm_c_current_toplevel ();
   OBJECT *obj = edascm_to_object (obj_s);
   PAGE *page = o_get_page (obj);
   if ((page == NULL) || (obj->parent != NULL)) {
@@ -118,7 +116,7 @@ SCM_DEFINE (deselect_object_x, "%deselect-object!", 1, 0, 0,
   }
 
   if (obj->selected) {
-    o_selection_remove (toplevel, page->selection_list, obj);
+    o_selection_remove (page->selection_list, obj);
   }
 
   return obj_s;
diff --git a/schematic/src/gschem_arc_dialog.c b/schematic/src/gschem_arc_dialog.c
index a8ec9654a..fe275b8e2 100644
--- a/schematic/src/gschem_arc_dialog.c
+++ b/schematic/src/gschem_arc_dialog.c
@@ -68,9 +68,9 @@ void arc_angle_dialog_response(GtkWidget *w, gint response,
     arc_object = (OBJECT*) g_object_get_data(G_OBJECT(w_current->aawindow),"arc_object");
 
     if (arc_object != NULL) {
-      geda_arc_object_modify (w_current->toplevel, arc_object, radius, 0, ARC_RADIUS);
-      geda_arc_object_modify (w_current->toplevel, arc_object, start_angle, 0, ARC_START_ANGLE);
-      geda_arc_object_modify (w_current->toplevel, arc_object, sweep_angle, 0, ARC_SWEEP_ANGLE);
+      geda_arc_object_modify (arc_object, radius, 0, ARC_RADIUS);
+      geda_arc_object_modify (arc_object, start_angle, 0, ARC_START_ANGLE);
+      geda_arc_object_modify (arc_object, sweep_angle, 0, ARC_SWEEP_ANGLE);
     } else {
       o_arc_end4(w_current, radius, start_angle, sweep_angle);
     }
diff --git a/schematic/src/gschem_find_text_state.c b/schematic/src/gschem_find_text_state.c
index 8d665e86e..09b784404 100644
--- a/schematic/src/gschem_find_text_state.c
+++ b/schematic/src/gschem_find_text_state.c
@@ -424,7 +424,7 @@ find_objects_using_pattern (GSList *pages, const char *text)
         continue;
       }
 
-      if (!(o_is_visible (page->toplevel, object) || page->toplevel->show_hidden_text)) {
+      if (!(o_is_visible (object) || page->toplevel->show_hidden_text)) {
         continue;
       }
 
@@ -501,7 +501,7 @@ find_objects_using_regex (GSList *pages, const char *text, GError **error)
         continue;
       }
 
-      if (!(o_is_visible (page->toplevel, object) || page->toplevel->show_hidden_text)) {
+      if (!(o_is_visible (object) || page->toplevel->show_hidden_text)) {
         continue;
       }
 
@@ -566,7 +566,7 @@ find_objects_using_substring (GSList *pages, const char *text)
         continue;
       }
 
-      if (!(o_is_visible (page->toplevel, object) || page->toplevel->show_hidden_text)) {
+      if (!(o_is_visible (object) || page->toplevel->show_hidden_text)) {
         continue;
       }
 
diff --git a/schematic/src/gschem_preview.c b/schematic/src/gschem_preview.c
index 8c6aeb951..3fd831411 100644
--- a/schematic/src/gschem_preview.c
+++ b/schematic/src/gschem_preview.c
@@ -176,7 +176,7 @@ preview_update (GschemPreview *preview)
   TOPLEVEL *preview_toplevel = preview_page->toplevel;
 
   /* delete old preview */
-  s_page_delete_objects (preview_toplevel, preview_page);
+  s_page_delete_objects (preview_page);
 
   if (preview->active) {
     g_assert ((preview->filename == NULL) || (preview->buffer == NULL));
@@ -195,13 +195,11 @@ preview_update (GschemPreview *preview)
                                        _("Preview Buffer"), &err);
 
       if (err == NULL) {
-        s_page_append_list (preview_toplevel, preview_page,
-                            objects);
+        s_page_append_list (preview_page, objects);
       }
       else {
-        s_page_append (preview_toplevel, preview_page,
-                       geda_text_object_new (preview_toplevel,
-                                             2,
+        s_page_append (preview_page,
+                       geda_text_object_new (2,
                                              100,
                                              100,
                                              LOWER_MIDDLE,
diff --git a/schematic/src/gschem_selection_adapter.c b/schematic/src/gschem_selection_adapter.c
index b78687b93..747e4508c 100644
--- a/schematic/src/gschem_selection_adapter.c
+++ b/schematic/src/gschem_selection_adapter.c
@@ -1021,8 +1021,7 @@ gschem_selection_adapter_set_fill_angle1 (GschemSelectionAdapter *adapter, int a
                                  &temp_angle2);
 
     if (success) {
-      o_set_fill_options (adapter->toplevel,
-                          object,
+      o_set_fill_options (object,
                           temp_fill_type,
                           temp_width,
                           temp_pitch1,
@@ -1081,8 +1080,7 @@ gschem_selection_adapter_set_fill_angle2 (GschemSelectionAdapter *adapter, int a
                                  &temp_angle2);
 
     if (success) {
-      o_set_fill_options (adapter->toplevel,
-                          object,
+      o_set_fill_options (object,
                           temp_fill_type,
                           temp_width,
                           temp_pitch1,
@@ -1143,8 +1141,7 @@ gschem_selection_adapter_set_fill_pitch1 (GschemSelectionAdapter *adapter, int p
                                  &temp_angle2);
 
     if (success) {
-      o_set_fill_options (adapter->toplevel,
-                          object,
+      o_set_fill_options (object,
                           temp_fill_type,
                           temp_width,
                           pitch,
@@ -1203,8 +1200,7 @@ gschem_selection_adapter_set_fill_pitch2 (GschemSelectionAdapter *adapter, int p
                                  &temp_angle2);
 
     if (success) {
-      o_set_fill_options (adapter->toplevel,
-                          object,
+      o_set_fill_options (object,
                           temp_fill_type,
                           temp_width,
                           temp_pitch1,
@@ -1265,8 +1261,7 @@ gschem_selection_adapter_set_fill_type (GschemSelectionAdapter *adapter, int fil
                                  &temp_angle2);
 
     if (success) {
-      o_set_fill_options (adapter->toplevel,
-                          object,
+      o_set_fill_options (object,
                           (OBJECT_FILLING) fill_type,
                           temp_width,
                           temp_pitch1,
@@ -1331,8 +1326,7 @@ gschem_selection_adapter_set_fill_width (GschemSelectionAdapter *adapter, int fi
                                  &temp_angle2);
 
     if (success) {
-      o_set_fill_options (adapter->toplevel,
-                          object,
+      o_set_fill_options (object,
                           temp_fill_type,
                           fill_width,
                           temp_pitch1,
@@ -1390,8 +1384,7 @@ gschem_selection_adapter_set_line_type (GschemSelectionAdapter *adapter, int lin
                                   &temp_dash_space);
 
     if (success) {
-      o_set_line_options (adapter->toplevel,
-                          object,
+      o_set_line_options (object,
                           temp_cap_style,
                           (OBJECT_TYPE) line_type,
                           temp_line_width,
@@ -1450,8 +1443,7 @@ gschem_selection_adapter_set_line_width (GschemSelectionAdapter *adapter, int li
                                   &temp_dash_space);
 
     if (success) {
-      o_set_line_options (adapter->toplevel,
-                          object,
+      o_set_line_options (object,
                           temp_cap_style,
                           temp_line_type,
                           line_width,
@@ -1508,8 +1500,7 @@ gschem_selection_adapter_set_dash_length (GschemSelectionAdapter *adapter, int d
                                   &temp_dash_space);
 
     if (success) {
-      o_set_line_options (adapter->toplevel,
-                          object,
+      o_set_line_options (object,
                           temp_cap_style,
                           temp_line_type,
                           temp_line_width,
@@ -1566,8 +1557,7 @@ gschem_selection_adapter_set_dash_space (GschemSelectionAdapter *adapter, int da
                                   &temp_dash_space);
 
     if (success) {
-      o_set_line_options (adapter->toplevel,
-                          object,
+      o_set_line_options (object,
                           temp_cap_style,
                           temp_line_type,
                           temp_line_width,
@@ -1624,8 +1614,7 @@ gschem_selection_adapter_set_cap_style (GschemSelectionAdapter *adapter, int cap
                                   &temp_dash_space);
 
     if (success) {
-      o_set_line_options (adapter->toplevel,
-                          object,
+      o_set_line_options (object,
                           (OBJECT_END) cap_style,
                           temp_line_type,
                           temp_line_width,
@@ -1656,8 +1645,7 @@ gschem_selection_adapter_set_object_color (GschemSelectionAdapter *adapter, int
   g_return_if_fail (color < MAX_COLORS);
 
   geda_object_list_set_color (geda_list_get_glist (adapter->selection),
-                              color,
-                              adapter->toplevel);
+                              color);
 
   g_object_notify (G_OBJECT (adapter), "object-color");
   g_object_notify (G_OBJECT (adapter), "text-color");
@@ -1686,8 +1674,8 @@ gschem_selection_adapter_set_pin_type (GschemSelectionAdapter *adapter, int type
     OBJECT *object = (OBJECT*) iter->data;
 
     if (object->type == OBJ_PIN && object->pin_type != type) {
-      s_conn_remove_object_connections (adapter->toplevel, object);
-      geda_pin_object_set_type (adapter->toplevel, object, type);
+      s_conn_remove_object_connections (object);
+      geda_pin_object_set_type (object, type);
       s_conn_update_object (object->page, object);
     }
 
@@ -1768,7 +1756,7 @@ gschem_selection_adapter_set_text_alignment (GschemSelectionAdapter *adapter, in
 
     if (object->type == OBJ_TEXT) {
       geda_text_object_set_alignment (object, alignment);
-      o_text_recreate(adapter->toplevel, object);
+      o_text_recreate (object);
     }
 
     iter = g_list_next (iter);
@@ -1801,7 +1789,7 @@ gschem_selection_adapter_set_text_color (GschemSelectionAdapter *adapter, int co
     OBJECT *object = (OBJECT*) iter->data;
 
     if (object->type == OBJ_TEXT) {
-      o_set_color (adapter->toplevel, object, color);
+      o_set_color (object, color);
     }
 
     iter = g_list_next (iter);
@@ -1836,7 +1824,7 @@ gschem_selection_adapter_set_text_rotation (GschemSelectionAdapter *adapter, int
 
     if (object->type == OBJ_TEXT) {
       geda_text_object_set_angle (object, angle);
-      o_text_recreate(adapter->toplevel, object);
+      o_text_recreate (object);
     }
 
     iter = g_list_next (iter);
@@ -1870,7 +1858,7 @@ gschem_selection_adapter_set_text_size (GschemSelectionAdapter *adapter, int siz
 
     if (object->type == OBJ_TEXT) {
       geda_text_object_set_size (object, size);
-      o_text_recreate(adapter->toplevel, object);
+      o_text_recreate (object);
     }
 
     iter = g_list_next (iter);
@@ -1905,14 +1893,14 @@ gschem_selection_adapter_set_text_string (GschemSelectionAdapter *adapter, const
     OBJECT *object = (OBJECT*) iter->data;
 
     if (object->type == OBJ_TEXT) {
-      o_text_set_string (adapter->toplevel, object, string);
+      o_text_set_string (object, string);
 
       /* handle slot= attribute, it's a special case */
       if (object->attached_to != NULL && g_ascii_strncasecmp (string, "slot=", 5) == 0) {
         o_slot_end (w_current, object->attached_to, string);
       }
 
-      o_text_recreate (adapter->toplevel, object);
+      o_text_recreate (object);
     }
 
     iter = g_list_next (iter);
diff --git a/schematic/src/i_callbacks.c b/schematic/src/i_callbacks.c
index 16363c665..aea5cfb76 100644
--- a/schematic/src/i_callbacks.c
+++ b/schematic/src/i_callbacks.c
@@ -2722,7 +2722,7 @@ DEFINE_I_CALLBACK(cancel)
    * action, the list (refering to objects on the page) would
    * already have been cleared in o_move_cancel(), so this is OK. */
   if (toplevel->page_current != NULL) {
-    geda_object_list_delete (toplevel, toplevel->page_current->place_list);
+    geda_object_list_delete (toplevel->page_current->place_list);
     toplevel->page_current->place_list = NULL;
   }
 
diff --git a/schematic/src/o_arc.c b/schematic/src/o_arc.c
index 51d630b06..1530ea588 100644
--- a/schematic/src/o_arc.c
+++ b/schematic/src/o_arc.c
@@ -136,21 +136,17 @@ void o_arc_end4(GschemToplevel *w_current, int radius,
   PAGE *page = gschem_page_view_get_page (page_view);
   g_return_if_fail (page != NULL);
 
-  TOPLEVEL *toplevel = page->toplevel;
-  g_return_if_fail (toplevel != NULL);
-
   OBJECT *new_obj;
 
   /* create, initialize and link the new arc object */
-  new_obj = geda_arc_object_new (toplevel,
-                                 GRAPHIC_COLOR,
+  new_obj = geda_arc_object_new (GRAPHIC_COLOR,
                                  w_current->first_wx,
                                  w_current->first_wy,
                                  radius,
                                  start_angle,
                                  sweep_angle);
 
-  s_page_append (toplevel, page, new_obj);
+  s_page_append (page, new_obj);
 
   w_current->first_wx  = -1;
   w_current->first_wy  = -1;
diff --git a/schematic/src/o_attrib.c b/schematic/src/o_attrib.c
index 528c273db..7bc62891c 100644
--- a/schematic/src/o_attrib.c
+++ b/schematic/src/o_attrib.c
@@ -66,7 +66,7 @@ void o_attrib_add_selected(GschemToplevel *w_current, SELECTION *selection,
 
     /* make sure object isn't selected already */
     if (!a_current->selected) {
-      o_selection_add (w_current->toplevel, selection, a_current);
+      o_selection_add (selection, a_current);
       selected_objects = g_list_prepend (selected_objects, a_current);
     }
   }
@@ -107,8 +107,8 @@ void o_attrib_deselect_invisible (GschemToplevel *w_current,
        a_iter = g_list_next (a_iter)) {
     a_current = (OBJECT*) a_iter->data;
 
-    if (a_current->selected && !o_is_visible(w_current->toplevel, a_current)) {
-      o_selection_remove (w_current->toplevel, selection, a_current);
+    if (a_current->selected && !o_is_visible (a_current)) {
+      o_selection_remove (selection, a_current);
     }
   }
 }
@@ -141,8 +141,8 @@ void o_attrib_select_invisible (GschemToplevel *w_current,
        a_iter = g_list_next (a_iter)) {
     a_current = (OBJECT*) a_iter->data;
 
-    if (!a_current->selected && !o_is_visible(w_current->toplevel, a_current)) {
-      o_selection_add (w_current->toplevel, selection, a_current);
+    if (!a_current->selected && !o_is_visible (a_current)) {
+      o_selection_add (selection, a_current);
     }
   }
 }
@@ -162,13 +162,13 @@ void o_attrib_toggle_visibility(GschemToplevel *w_current, OBJECT *object)
 
   g_return_if_fail (object != NULL && object->type == OBJ_TEXT);
 
-  if (o_is_visible (toplevel, object)) {
+  if (o_is_visible (object)) {
     /* only erase if we are not showing hidden text */
     if (!toplevel->show_hidden_text) {
       o_invalidate (w_current, object);
     }
 
-    o_set_visibility (toplevel, object, INVISIBLE);
+    o_set_visibility (object, INVISIBLE);
 
     if (toplevel->show_hidden_text) {
       /* draw text so that little I is drawn */
@@ -182,8 +182,8 @@ void o_attrib_toggle_visibility(GschemToplevel *w_current, OBJECT *object)
       o_invalidate (w_current, object);
     }
 
-    o_set_visibility (toplevel, object, VISIBLE);
-    o_text_recreate(toplevel, object);
+    o_set_visibility (object, VISIBLE);
+    o_text_recreate (object);
   }
 
   gschem_toplevel_page_content_changed (w_current, toplevel->page_current);
@@ -208,7 +208,7 @@ void o_attrib_toggle_show_name_value(GschemToplevel *w_current,
 
   o_invalidate (w_current, object);
   object->show_name_value = show_name_value;
-  o_text_recreate(toplevel, object);
+  o_text_recreate (object);
 
   gschem_toplevel_page_content_changed (w_current, toplevel->page_current);
 }
@@ -352,8 +352,7 @@ OBJECT *o_attrib_add_attrib(GschemToplevel *w_current,
   }
 
   /* first create text item */
-  new_obj = geda_text_object_new (toplevel,
-                                  color,
+  new_obj = geda_text_object_new (color,
                                   world_x,
                                   world_y,
                                   align,
@@ -362,15 +361,15 @@ OBJECT *o_attrib_add_attrib(GschemToplevel *w_current,
                                   w_current->text_size, /* current text size */
                                   visibility,
                                   show_name_value);
-  s_page_append (toplevel, toplevel->page_current, new_obj);
+  s_page_append (toplevel->page_current, new_obj);
 
   /* now attach the attribute to the object (if o_current is not NULL) */
   /* remember that o_current contains the object to get the attribute */
   if (o_current) {
-    o_attrib_attach (toplevel, new_obj, o_current, FALSE);
+    o_attrib_attach (new_obj, o_current, FALSE);
   }
 
-  o_selection_add (toplevel, toplevel->page_current->selection_list, new_obj);
+  o_selection_add (toplevel->page_current->selection_list, new_obj);
 
   /* handle slot= attribute, it's a special case */
   if (o_current != NULL &&
diff --git a/schematic/src/o_basic.c b/schematic/src/o_basic.c
index d3466a040..2d609196b 100644
--- a/schematic/src/o_basic.c
+++ b/schematic/src/o_basic.c
@@ -366,7 +366,7 @@ int o_redraw_cleanstates(GschemToplevel *w_current)
       /* Free the place list and its contents. If we were in a move
        * action, the list (refering to objects on the page) would
        * already have been cleared in o_move_cancel(), so this is OK. */
-      geda_object_list_delete (toplevel, toplevel->page_current->place_list);
+      geda_object_list_delete (toplevel->page_current->place_list);
       toplevel->page_current->place_list = NULL;
 
       i_action_stop (w_current);
diff --git a/schematic/src/o_box.c b/schematic/src/o_box.c
index 31582eabe..3b67348ad 100644
--- a/schematic/src/o_box.c
+++ b/schematic/src/o_box.c
@@ -107,9 +107,6 @@ void o_box_end(GschemToplevel *w_current, int w_x, int w_y)
   PAGE *page = gschem_page_view_get_page (page_view);
   g_return_if_fail (page != NULL);
 
-  TOPLEVEL *toplevel = page->toplevel;
-  g_return_if_fail (toplevel != NULL);
-
   int box_width, box_height;
   int box_left, box_top;
 
@@ -137,10 +134,10 @@ void o_box_end(GschemToplevel *w_current, int w_x, int w_y)
   } else {
 
     /* create the object */
-    new_obj = geda_box_object_new (toplevel, OBJ_BOX, GRAPHIC_COLOR,
+    new_obj = geda_box_object_new (OBJ_BOX, GRAPHIC_COLOR,
                                    box_left, box_top,
                                    box_left + box_width, box_top - box_height);
-    s_page_append (toplevel, page, new_obj);
+    s_page_append (page, new_obj);
 
 #if DEBUG
   printf("coords: %d %d %d %d\n", box_left, box_top, box_width, box_height);
diff --git a/schematic/src/o_buffer.c b/schematic/src/o_buffer.c
index cdb6bf6b1..a50d81eac 100644
--- a/schematic/src/o_buffer.c
+++ b/schematic/src/o_buffer.c
@@ -34,17 +34,15 @@ static void
 clipboard_to_buffer(GschemToplevel *w_current, int buf_num)
 {
   GList *object_list;
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
 
   g_return_if_fail (w_current != NULL);
-  g_return_if_fail (toplevel != NULL);
   g_return_if_fail (buf_num >= 0);
   g_return_if_fail (buf_num < MAX_BUFFERS);
 
   object_list = x_clipboard_get (w_current);
 
   if (object_buffer[buf_num] != NULL) {
-    geda_object_list_delete (toplevel, object_buffer[buf_num]);
+    geda_object_list_delete (object_buffer[buf_num]);
   }
 
   object_buffer[buf_num] = object_list;
@@ -70,12 +68,11 @@ selection_to_buffer(GschemToplevel *w_current, int buf_num)
   s_current = geda_list_get_glist (toplevel->page_current->selection_list);
 
   if (object_buffer[buf_num] != NULL) {
-    geda_object_list_delete (toplevel, object_buffer[buf_num]);
+    geda_object_list_delete (object_buffer[buf_num]);
     object_buffer[buf_num] = NULL;
   }
 
-  object_buffer[buf_num] = o_glist_copy_all (toplevel,
-                                             s_current,
+  object_buffer[buf_num] = o_glist_copy_all (s_current,
                                              object_buffer[buf_num]);
 }
 
@@ -164,11 +161,11 @@ o_buffer_paste_start(GschemToplevel *w_current, int w_x, int w_y, int buf_num)
   }
 
   /* remove the old place list if it exists */
-  geda_object_list_delete (toplevel, toplevel->page_current->place_list);
+  geda_object_list_delete (toplevel->page_current->place_list);
   toplevel->page_current->place_list = NULL;
 
   toplevel->page_current->place_list =
-    o_glist_copy_all (toplevel, object_buffer[buf_num],
+    o_glist_copy_all (object_buffer[buf_num],
                       toplevel->page_current->place_list);
 
   if (!world_get_object_glist_bounds (toplevel,
@@ -231,12 +228,11 @@ void o_buffer_init(void)
  */
 void o_buffer_free(GschemToplevel *w_current)
 {
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
   int i;
 
   for (i = 0 ; i < MAX_BUFFERS; i++) {
     if (object_buffer[i]) {
-      geda_object_list_delete (toplevel, object_buffer[i]);
+      geda_object_list_delete (object_buffer[i]);
       object_buffer[i] = NULL;
     }
   }
diff --git a/schematic/src/o_bus.c b/schematic/src/o_bus.c
index ecf3643c5..730925510 100644
--- a/schematic/src/o_bus.c
+++ b/schematic/src/o_bus.c
@@ -82,14 +82,13 @@ void o_bus_end(GschemToplevel *w_current, int w_x, int w_y)
   if ( (w_current->first_wx != w_current->second_wx) ||
        (w_current->first_wy != w_current->second_wy) ) {
 
-    new_obj = geda_bus_object_new (toplevel,
-                                   BUS_COLOR,
+    new_obj = geda_bus_object_new (BUS_COLOR,
                                    w_current->first_wx,
                                    w_current->first_wy,
                                    w_current->second_wx,
                                    w_current->second_wy,
                                    0);
-    s_page_append (toplevel, page, new_obj);
+    s_page_append (page, new_obj);
 
     /* connect the new bus to the other busses */
     prev_conn_objects = s_conn_return_others (prev_conn_objects, new_obj);
diff --git a/schematic/src/o_circle.c b/schematic/src/o_circle.c
index 4ecc39b47..f17c4b966 100644
--- a/schematic/src/o_circle.c
+++ b/schematic/src/o_circle.c
@@ -102,9 +102,6 @@ void o_circle_end(GschemToplevel *w_current, int w_x, int w_y)
   PAGE *page = gschem_page_view_get_page (page_view);
   g_return_if_fail (page != NULL);
 
-  TOPLEVEL *toplevel = page->toplevel;
-  g_return_if_fail (toplevel != NULL);
-
   /* erase the temporary circle */
   /* o_circle_invalidate_rubber (w_current); */
   w_current->rubber_visible = 0;
@@ -116,13 +113,12 @@ void o_circle_end(GschemToplevel *w_current, int w_x, int w_y)
   }
 
   /* create the object */
-  new_obj = geda_circle_object_new (toplevel,
-                                    GRAPHIC_COLOR,
+  new_obj = geda_circle_object_new (GRAPHIC_COLOR,
                                     w_current->first_wx,
                                     w_current->first_wy,
                                     w_current->distance);
 
-  s_page_append (toplevel, page, new_obj);
+  s_page_append (page, new_obj);
 
   /* Call add-objects-hook */
   g_run_hook_object (w_current, "%add-objects-hook", new_obj);
diff --git a/schematic/src/o_component.c b/schematic/src/o_component.c
index b8faea81c..9507a3145 100644
--- a/schematic/src/o_component.c
+++ b/schematic/src/o_component.c
@@ -47,7 +47,7 @@ o_component_prepare_place (GschemToplevel *w_current,
   i_action_start (w_current);
 
   /* remove the old place list if it exists */
-  geda_object_list_delete (toplevel, toplevel->page_current->place_list);
+  geda_object_list_delete (toplevel->page_current->place_list);
   toplevel->page_current->place_list = NULL;
 
   /* Insert the new object into the buffer at world coordinates (0,0).
@@ -93,7 +93,7 @@ o_component_prepare_place (GschemToplevel *w_current,
     if (new_object->type == OBJ_PLACEHOLDER) {
       /* If created object is a placeholder, the loading failed and we end the insert action */
 
-      s_delete_object(toplevel, new_object);
+      s_delete_object (new_object);
       i_set_state (w_current, SELECT);
       i_action_stop (w_current);
       return;
@@ -102,7 +102,7 @@ o_component_prepare_place (GschemToplevel *w_current,
 
       toplevel->page_current->place_list =
           g_list_concat (toplevel->page_current->place_list,
-                         o_component_promote_attribs (toplevel, new_object));
+                         o_component_promote_attribs (new_object));
       toplevel->page_current->place_list =
           g_list_append (toplevel->page_current->place_list, new_object);
 
@@ -191,7 +191,7 @@ o_component_translate_all (GschemToplevel *w_current, int offset)
   for (iter = s_page_objects (toplevel->page_current);
        iter != NULL; iter = g_list_next (iter)) {
     o_current = (OBJECT*) iter->data;
-    s_conn_remove_object_connections (toplevel, o_current);
+    s_conn_remove_object_connections (o_current);
   }
 
   if (offset == 0) {
diff --git a/schematic/src/o_copy.c b/schematic/src/o_copy.c
index ecd53c341..17f3bee3a 100644
--- a/schematic/src/o_copy.c
+++ b/schematic/src/o_copy.c
@@ -51,12 +51,11 @@ void o_copy_start(GschemToplevel *w_current, int w_x, int w_y)
   s_current = geda_list_get_glist (page->selection_list);
 
   if (page->place_list != NULL) {
-    geda_object_list_delete  (page->toplevel, page->place_list);
+    geda_object_list_delete (page->place_list);
     page->place_list = NULL;
   }
 
-  page->place_list = o_glist_copy_all (page->toplevel,
-                                       s_current,
+  page->place_list = o_glist_copy_all (s_current,
                                        page->place_list);
 
   g_run_hook_object_list (w_current,
diff --git a/schematic/src/o_delete.c b/schematic/src/o_delete.c
index 3d9b278ab..18b30a3a7 100644
--- a/schematic/src/o_delete.c
+++ b/schematic/src/o_delete.c
@@ -36,10 +36,10 @@ void o_delete (GschemToplevel *w_current, OBJECT *object)
 
   g_return_if_fail (object != NULL);
 
-  o_selection_remove (toplevel, toplevel->page_current->selection_list, object);
-  s_page_remove (toplevel, toplevel->page_current, object);
+  o_selection_remove (toplevel->page_current->selection_list, object);
+  s_page_remove (toplevel->page_current, object);
   g_run_hook_object (w_current, "%remove-objects-hook", object);
-  s_delete_object (toplevel, object);
+  s_delete_object (object);
 
   gschem_toplevel_page_content_changed (w_current, toplevel->page_current);
 }
@@ -111,8 +111,8 @@ void o_delete_selected (GschemToplevel *w_current)
 
   for (iter = to_remove; iter != NULL; iter = g_list_next (iter)) {
     obj = (OBJECT *) iter->data;
-    o_selection_remove (toplevel, selection, obj);
-    s_page_remove (toplevel, toplevel->page_current, obj);
+    o_selection_remove (selection, obj);
+    s_page_remove (toplevel->page_current, obj);
   }
 
   g_run_hook_object_list (w_current, "%remove-objects-hook", to_remove);
@@ -129,7 +129,7 @@ void o_delete_selected (GschemToplevel *w_current)
 
   for (iter = to_remove; iter != NULL; iter = g_list_next (iter)) {
     obj = (OBJECT *) iter->data;
-    s_delete_object (toplevel, obj);
+    s_delete_object (obj);
   }
 
   g_list_free (to_remove);
diff --git a/schematic/src/o_find.c b/schematic/src/o_find.c
index d95ea23a7..0b357a332 100644
--- a/schematic/src/o_find.c
+++ b/schematic/src/o_find.c
@@ -51,7 +51,7 @@ is_object_hit (GschemToplevel *w_current, OBJECT *object,
 
   /* We can't hit invisible (text) objects unless show_hidden_text is active.
    */
-  if (!o_is_visible (w_current->toplevel, object) &&
+  if (!o_is_visible (object) &&
       !w_current->toplevel->show_hidden_text)
     return FALSE;
 
diff --git a/schematic/src/o_grips.c b/schematic/src/o_grips.c
index c93cdd0dd..ed3a8611b 100644
--- a/schematic/src/o_grips.c
+++ b/schematic/src/o_grips.c
@@ -731,10 +731,9 @@ static void o_grips_start_path(GschemToplevel *w_current, OBJECT *o_current,
 static void o_grips_start_picture(GschemToplevel *w_current, OBJECT *o_current,
                                   int x, int y, int whichone)
 {
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
   w_current->last_drawb_mode = LAST_DRAWB_MODE_NONE;
 
-  w_current->current_pixbuf = o_picture_get_pixbuf (toplevel, o_current);
+  w_current->current_pixbuf = o_picture_get_pixbuf (o_current);
   w_current->pixbuf_filename =
     g_strdup (o_picture_get_filename (o_current));
   w_current->pixbuf_wh_ratio = o_picture_get_ratio (o_current);
@@ -1016,7 +1015,6 @@ void o_grips_cancel(GschemToplevel *w_current)
 static void o_grips_end_arc(GschemToplevel *w_current, OBJECT *o_current,
                             int whichone)
 {
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
   int arg1, arg2;
 
   /* erase the temporary arc */
@@ -1050,7 +1048,7 @@ static void o_grips_end_arc(GschemToplevel *w_current, OBJECT *o_current,
   }
 
   /* modify the arc with the parameters determined above */
-  geda_arc_object_modify (toplevel, o_current, arg1, arg2, whichone);
+  geda_arc_object_modify (o_current, arg1, arg2, whichone);
 }
 
 /*! \todo Finish function documentation!!!
@@ -1064,7 +1062,6 @@ static void o_grips_end_arc(GschemToplevel *w_current, OBJECT *o_current,
 static void o_grips_end_box(GschemToplevel *w_current, OBJECT *o_current,
                             int whichone)
 {
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
   int box_width, box_height;
 
   box_width  = GET_BOX_WIDTH (w_current);
@@ -1079,7 +1076,7 @@ static void o_grips_end_box(GschemToplevel *w_current, OBJECT *o_current,
     return;
   }
 
-  geda_box_object_modify (toplevel, o_current, w_current->second_wx, w_current->second_wy, whichone);
+  geda_box_object_modify (o_current, w_current->second_wx, w_current->second_wy, whichone);
 }
 
 /*! \todo Finish function documentation!!!
@@ -1093,8 +1090,10 @@ static void o_grips_end_box(GschemToplevel *w_current, OBJECT *o_current,
 static void o_grips_end_path(GschemToplevel *w_current, OBJECT *o_current,
                              int whichone)
 {
-  geda_path_object_modify (w_current->toplevel, o_current,
-                           w_current->second_wx, w_current->second_wy, whichone);
+  geda_path_object_modify (o_current,
+                           w_current->second_wx,
+                           w_current->second_wy,
+                           whichone);
 }
 
 /*! \todo Finish function documentation!!!
@@ -1108,9 +1107,7 @@ static void o_grips_end_path(GschemToplevel *w_current, OBJECT *o_current,
 static void o_grips_end_picture(GschemToplevel *w_current, OBJECT *o_current,
                                 int whichone)
 {
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
-
-  /* don't allow zero width/height picturees
+  /* don't allow zero width/height pictures
    * this ends the picture drawing behavior
    * we want this? hack */
   if ((GET_PICTURE_WIDTH(w_current) == 0) || (GET_PICTURE_HEIGHT(w_current) == 0)) {
@@ -1119,8 +1116,8 @@ static void o_grips_end_picture(GschemToplevel *w_current, OBJECT *o_current,
     return;
   }
 
-  o_picture_modify(toplevel, o_current,
-		   w_current->second_wx, w_current->second_wy, whichone);
+  o_picture_modify (o_current,
+                    w_current->second_wx, w_current->second_wy, whichone);
 
   g_object_unref (w_current->current_pixbuf);
   w_current->current_pixbuf = NULL;
@@ -1147,8 +1144,6 @@ static void o_grips_end_picture(GschemToplevel *w_current, OBJECT *o_current,
 static void o_grips_end_circle(GschemToplevel *w_current, OBJECT *o_current,
                                int whichone)
 {
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
-
   /* don't allow zero radius circles
    * this ends the circle drawing behavior
    * we want this? hack */
@@ -1159,7 +1154,7 @@ static void o_grips_end_circle(GschemToplevel *w_current, OBJECT *o_current,
   }
 
   /* modify the radius of the circle */
-  geda_circle_object_modify (toplevel, o_current, w_current->distance, -1, CIRCLE_RADIUS);
+  geda_circle_object_modify (o_current, w_current->distance, -1, CIRCLE_RADIUS);
 }
 
 /*! \brief End process of modifying line object with grip.
@@ -1181,8 +1176,6 @@ static void o_grips_end_circle(GschemToplevel *w_current, OBJECT *o_current,
 static void o_grips_end_line(GschemToplevel *w_current, OBJECT *o_current,
                              int whichone)
 {
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
-
   /* don't allow zero length nets / lines / pins
    * this ends the net drawing behavior
    * we want this? hack */
@@ -1194,8 +1187,8 @@ static void o_grips_end_line(GschemToplevel *w_current, OBJECT *o_current,
   }
 
   /* modify the right line end according to whichone */
-  geda_line_object_modify(toplevel, o_current,
-                          w_current->second_wx, w_current->second_wy, whichone);
+  geda_line_object_modify (o_current,
+                           w_current->second_wx, w_current->second_wy, whichone);
 }
 
 
@@ -1218,7 +1211,6 @@ static void o_grips_end_line(GschemToplevel *w_current, OBJECT *o_current,
 static void o_grips_end_net(GschemToplevel *w_current, OBJECT *o_current,
                             int whichone)
 {
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
   GList *connected_objects;
 
   /* don't allow zero length net
@@ -1230,8 +1222,8 @@ static void o_grips_end_net(GschemToplevel *w_current, OBJECT *o_current,
     return;
   }
 
-  s_conn_remove_object_connections (toplevel, o_current);
-  geda_net_object_modify (toplevel, o_current, w_current->second_wx,
+  s_conn_remove_object_connections (o_current);
+  geda_net_object_modify (o_current, w_current->second_wx,
                           w_current->second_wy, w_current->which_grip);
   s_conn_update_object (o_current->page, o_current);
 
@@ -1260,8 +1252,6 @@ static void o_grips_end_net(GschemToplevel *w_current, OBJECT *o_current,
 static void o_grips_end_pin(GschemToplevel *w_current, OBJECT *o_current,
                             int whichone)
 {
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
-
   /* don't allow zero length pin
    * this ends the pin changing behavior
    * we want this? hack */
@@ -1271,9 +1261,11 @@ static void o_grips_end_pin(GschemToplevel *w_current, OBJECT *o_current,
     return;
   }
 
-  s_conn_remove_object_connections (toplevel, o_current);
-  geda_pin_object_modify (toplevel, o_current, w_current->second_wx,
-                          w_current->second_wy, w_current->which_grip);
+  s_conn_remove_object_connections (o_current);
+  geda_pin_object_modify (o_current,
+                          w_current->second_wx,
+                          w_current->second_wy,
+                          w_current->which_grip);
   s_conn_update_object (o_current->page, o_current);
 }
 
@@ -1296,8 +1288,6 @@ static void o_grips_end_pin(GschemToplevel *w_current, OBJECT *o_current,
 static void o_grips_end_bus(GschemToplevel *w_current, OBJECT *o_current,
                             int whichone)
 {
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
-
   /* don't allow zero length bus
    * this ends the bus changing behavior
    * we want this? hack */
@@ -1307,8 +1297,8 @@ static void o_grips_end_bus(GschemToplevel *w_current, OBJECT *o_current,
     return;
   }
 
-  s_conn_remove_object_connections (toplevel, o_current);
-  geda_bus_object_modify (toplevel, o_current, w_current->second_wx,
+  s_conn_remove_object_connections (o_current);
+  geda_bus_object_modify (o_current, w_current->second_wx,
                           w_current->second_wy, w_current->which_grip);
   s_conn_update_object (o_current->page, o_current);
 }
diff --git a/schematic/src/o_line.c b/schematic/src/o_line.c
index 4f920279d..d96fe92d4 100644
--- a/schematic/src/o_line.c
+++ b/schematic/src/o_line.c
@@ -94,9 +94,6 @@ void o_line_end(GschemToplevel *w_current, int w_x, int w_y)
   PAGE *page = gschem_page_view_get_page (page_view);
   g_return_if_fail (page != NULL);
 
-  TOPLEVEL *toplevel = page->toplevel;
-  g_return_if_fail (toplevel != NULL);
-
   /* Don't bother.. the real object is invalidated, its in the same place */
   /* o_line_invalidate_rubber (w_current); */
   w_current->rubber_visible = 0;
@@ -106,14 +103,13 @@ void o_line_end(GschemToplevel *w_current, int w_x, int w_y)
        (w_current->first_wy != w_current->second_wy) ) {
 
     /* create the line object and draw it */
-    new_obj = geda_line_object_new (toplevel,
-                                    GRAPHIC_COLOR,
+    new_obj = geda_line_object_new (GRAPHIC_COLOR,
                                     w_current->first_wx,
                                     w_current->first_wy,
                                     w_current->second_wx,
                                     w_current->second_wy);
 
-    s_page_append (toplevel, page, new_obj);
+    s_page_append (page, new_obj);
 
     /* Call add-objects-hook */
     g_run_hook_object (w_current, "%add-objects-hook", new_obj);
diff --git a/schematic/src/o_misc.c b/schematic/src/o_misc.c
index b1bf7377a..eb76371d5 100644
--- a/schematic/src/o_misc.c
+++ b/schematic/src/o_misc.c
@@ -222,10 +222,10 @@ void o_rotate_world_update(GschemToplevel *w_current,
   for (o_iter = list; o_iter != NULL; o_iter = g_list_next (o_iter)) {
     o_current = (OBJECT*) o_iter->data;
 
-    s_conn_remove_object_connections (toplevel, o_current);
+    s_conn_remove_object_connections (o_current);
   }
 
-  geda_object_list_rotate ( list, centerx, centery, angle, toplevel );
+  geda_object_list_rotate (list, centerx, centery, angle);
 
   /* Find connected objects, adding each object in turn back to the
    * connection list. We only _really_ want those objects connected
@@ -280,10 +280,10 @@ void o_mirror_world_update(GschemToplevel *w_current, int centerx, int centery,
   for (o_iter = list; o_iter != NULL; o_iter = g_list_next (o_iter)) {
     o_current = (OBJECT*) o_iter->data;
 
-    s_conn_remove_object_connections (toplevel, o_current);
+    s_conn_remove_object_connections (o_current);
   }
 
-  geda_object_list_mirror ( list, centerx, centery, toplevel );
+  geda_object_list_mirror (list, centerx, centery);
 
   /* Find connected objects, adding each object in turn back to the
    * connection list. We only _really_ want those objects connected
@@ -316,17 +316,16 @@ void o_mirror_world_update(GschemToplevel *w_current, int centerx, int centery,
 void o_edit_show_hidden_lowlevel (GschemToplevel *w_current,
                                   const GList *o_list)
 {
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
   OBJECT *o_current;
   const GList *iter;
 
   iter = o_list;
   while (iter != NULL) {
     o_current = (OBJECT *)iter->data;
-    if (o_current->type == OBJ_TEXT && !o_is_visible (toplevel, o_current)) {
+    if (o_current->type == OBJ_TEXT && !o_is_visible (o_current)) {
 
       /* don't toggle the visibility flag */
-      o_text_recreate (toplevel, o_current);
+      o_text_recreate (o_current);
     }
 
     if (o_current->type == OBJ_COMPONENT || o_current->type == OBJ_PLACEHOLDER) {
@@ -383,9 +382,9 @@ void o_edit_hide_specific_text (GschemToplevel *w_current,
     if (o_current->type == OBJ_TEXT) {
       const gchar *str = geda_text_object_get_string (o_current);
       if (!strncmp (stext, str, strlen (stext))) {
-        if (o_is_visible (toplevel, o_current)) {
-          o_set_visibility (toplevel, o_current, INVISIBLE);
-          o_text_recreate(toplevel, o_current);
+        if (o_is_visible (o_current)) {
+          o_set_visibility (o_current, INVISIBLE);
+          o_text_recreate (o_current);
 
           gschem_toplevel_page_content_changed (w_current, toplevel->page_current);
         }
@@ -417,9 +416,9 @@ void o_edit_show_specific_text (GschemToplevel *w_current,
     if (o_current->type == OBJ_TEXT) {
       const gchar *str = geda_text_object_get_string (o_current);
       if (!strncmp (stext, str, strlen (stext))) {
-        if (!o_is_visible (toplevel, o_current)) {
-          o_set_visibility (toplevel, o_current, VISIBLE);
-          o_text_recreate(toplevel, o_current);
+        if (!o_is_visible (o_current)) {
+          o_set_visibility (o_current, VISIBLE);
+          o_text_recreate (o_current);
 
           gschem_toplevel_page_content_changed (w_current, toplevel->page_current);
         }
@@ -473,7 +472,7 @@ o_update_component (GschemToplevel *w_current, OBJECT *o_current)
   }
 
   /* Unselect the old object. */
-  o_selection_remove (toplevel, page->selection_list, o_current);
+  o_selection_remove (page->selection_list, o_current);
 
   /* Create new object and set embedded */
   o_new = o_component_new (toplevel, OBJ_COMPONENT, DEFAULT_COLOR,
@@ -487,7 +486,7 @@ o_update_component (GschemToplevel *w_current, OBJECT *o_current)
     o_embed (o_new);
   }
 
-  new_attribs = o_component_promote_attribs (toplevel, o_new);
+  new_attribs = o_component_promote_attribs (o_new);
 
   /* Cull any attributes from new COMPONENT that are already attached to
    * old COMPONENT. Note that the new_attribs list is kept consistent by
@@ -506,8 +505,8 @@ o_update_component (GschemToplevel *w_current, OBJECT *o_current)
 
     value = o_attrib_search_attached_attribs_by_name (o_current, name, 0);
     if (value != NULL) {
-      o_attrib_remove (toplevel, &o_new->attribs, attr_new);
-      s_delete_object (toplevel, attr_new);
+      o_attrib_remove (&o_new->attribs, attr_new);
+      s_delete_object (attr_new);
       iter->data = NULL;
     }
 
@@ -518,22 +517,22 @@ o_update_component (GschemToplevel *w_current, OBJECT *o_current)
 
   /* Detach attributes from old OBJECT and attach to new OBJECT */
   old_attribs = g_list_copy (o_current->attribs);
-  o_attrib_detach_all (toplevel, o_current);
-  o_attrib_attach_list (toplevel, old_attribs, o_new, 1);
+  o_attrib_detach_all (o_current);
+  o_attrib_attach_list (old_attribs, o_new, 1);
   g_list_free (old_attribs);
 
   /* Add new attributes to page */
-  s_page_append_list (toplevel, page, new_attribs);
+  s_page_append_list (page, new_attribs);
 
   /* Update pinnumbers for current slot */
-  s_slot_update_object (toplevel, o_new);
+  s_slot_update_object (o_new);
 
   /* Replace old OBJECT with new OBJECT */
-  s_page_replace (toplevel, page, o_current, o_new);
-  s_delete_object (toplevel, o_current);
+  s_page_replace (page, o_current, o_new);
+  s_delete_object (o_current);
 
   /* Select new OBJECT */
-  o_selection_add (toplevel, page->selection_list, o_new);
+  o_selection_add (page->selection_list, o_new);
 
   /* mark the page as modified */
   gschem_toplevel_page_content_changed (w_current, toplevel->page_current);
@@ -634,8 +633,7 @@ void o_autosave_backups(GschemToplevel *w_current)
           umask(saved_umask);
         }
 
-        if (o_save (toplevel,
-                    s_page_objects (toplevel->page_current),
+        if (o_save (s_page_objects (toplevel->page_current),
                     backup_filename, NULL)) {
 
           p_current->ops_since_last_backup = 0;
diff --git a/schematic/src/o_move.c b/schematic/src/o_move.c
index 1f24f23c4..6e78a181e 100644
--- a/schematic/src/o_move.c
+++ b/schematic/src/o_move.c
@@ -118,7 +118,7 @@ void o_move_end_lowlevel (GschemToplevel *w_current,
     case (OBJ_NET):
     case (OBJ_BUS):
     case (OBJ_PIN):
-      s_conn_remove_object_connections (page->toplevel, object);
+      s_conn_remove_object_connections (object);
       geda_object_translate (object, diff_x, diff_y);
       s_conn_update_object (page, object);
       break;
@@ -575,10 +575,10 @@ void o_move_check_endpoint(GschemToplevel *w_current, OBJECT * object)
 
       OBJECT *new_net;
       /* other object is a pin, insert a net */
-      new_net = geda_net_object_new (page->toplevel, OBJ_NET, NET_COLOR,
+      new_net = geda_net_object_new (OBJ_NET, NET_COLOR,
                                      c_current->x, c_current->y,
                                      c_current->x, c_current->y);
-      s_page_append (page->toplevel, page, new_net);
+      s_page_append (page, new_net);
       /* This new net object is only picked up for stretching later,
        * somewhat of a kludge. If the move operation is cancelled, these
        * new 0 length nets are removed by the "undo" operation invoked.
@@ -708,7 +708,7 @@ void o_move_end_rubberband (GschemToplevel *w_current,
         object->type == OBJ_BUS) {
 
       /* remove the object's connections */
-      s_conn_remove_object_connections (page->toplevel, object);
+      s_conn_remove_object_connections (object);
 
       object->line->x[whichone] += w_dx;
       object->line->y[whichone] += w_dy;
diff --git a/schematic/src/o_net.c b/schematic/src/o_net.c
index 55536a974..8d76ea560 100644
--- a/schematic/src/o_net.c
+++ b/schematic/src/o_net.c
@@ -511,10 +511,10 @@ void o_net_end(GschemToplevel *w_current, int w_x, int w_y)
 
   if (!primary_zero_length ) {
   /* create primary net */
-      new_net = geda_net_object_new (page->toplevel, OBJ_NET, NET_COLOR,
+      new_net = geda_net_object_new (OBJ_NET, NET_COLOR,
                                      w_current->first_wx, w_current->first_wy,
                                      w_current->second_wx, w_current->second_wy);
-      s_page_append (page->toplevel, page, new_net);
+      s_page_append (page, new_net);
 
       added_objects = g_list_prepend (added_objects, new_net);
 
@@ -546,10 +546,10 @@ void o_net_end(GschemToplevel *w_current, int w_x, int w_y)
   if (!secondary_zero_length && !found_primary_connection) {
 
       /* Add secondary net */
-      new_net = geda_net_object_new (page->toplevel, OBJ_NET, NET_COLOR,
+      new_net = geda_net_object_new (OBJ_NET, NET_COLOR,
                                      w_current->second_wx, w_current->second_wy,
                                      w_current->third_wx, w_current->third_wy);
-      s_page_append (page->toplevel, page, new_net);
+      s_page_append (page, new_net);
 
       added_objects = g_list_prepend (added_objects, new_net);
 
@@ -1034,7 +1034,7 @@ int o_net_add_busrippers(GschemToplevel *w_current, OBJECT *net_obj,
   }
 
   if (made_changes) {
-    s_conn_remove_object_connections (page->toplevel, net_obj);
+    s_conn_remove_object_connections (net_obj);
 
     if (w_current->bus_ripper_type == COMP_BUS_RIPPER) {
       GList *symlist =
@@ -1047,10 +1047,10 @@ int o_net_add_busrippers(GschemToplevel *w_current, OBJECT *net_obj,
 
     for (i = 0; i < ripper_count; i++) {
       if (w_current->bus_ripper_type == NET_BUS_RIPPER) {
-        new_obj = geda_net_object_new (page->toplevel, OBJ_NET, NET_COLOR,
+        new_obj = geda_net_object_new (OBJ_NET, NET_COLOR,
                                        rippers[i].x[0], rippers[i].y[0],
                                        rippers[i].x[1], rippers[i].y[1]);
-        s_page_append (page->toplevel, page, new_obj);
+        s_page_append (page, new_obj);
       } else {
 
         if (rippersym != NULL) {
@@ -1059,9 +1059,9 @@ int o_net_add_busrippers(GschemToplevel *w_current, OBJECT *net_obj,
                                      component_angle, 0,
                                      rippersym,
                                      w_current->bus_ripper_symname, 1);
-          s_page_append_list (page->toplevel, page,
-                              o_component_promote_attribs (page->toplevel, new_obj));
-          s_page_append (page->toplevel, page, new_obj);
+          s_page_append_list (page,
+                              o_component_promote_attribs (new_obj));
+          s_page_append (page, new_obj);
         } else {
           s_log_message(_("Bus ripper symbol [%1$s] was not found in any component library"),
                         w_current->bus_ripper_symname);
diff --git a/schematic/src/o_path.c b/schematic/src/o_path.c
index 48733f62e..041d1fb32 100644
--- a/schematic/src/o_path.c
+++ b/schematic/src/o_path.c
@@ -449,7 +449,6 @@ o_path_end(GschemToplevel *w_current, int w_x, int w_y)
 
   g_assert (w_current);
   g_assert (w_current->inside_action != 0);
-  g_assert (w_current->toplevel);
   g_assert (w_current->temp_path != NULL);
   g_assert (w_current->temp_path->sections != NULL);
 
@@ -459,9 +458,6 @@ o_path_end(GschemToplevel *w_current, int w_x, int w_y)
   PAGE *page = gschem_page_view_get_page (page_view);
   g_return_if_fail (page != NULL);
 
-  TOPLEVEL *toplevel = page->toplevel;
-  g_return_if_fail (toplevel != NULL);
-
   o_path_invalidate_rubber (w_current);
 
   x1 = w_current->first_wx;
@@ -497,7 +493,7 @@ o_path_end(GschemToplevel *w_current, int w_x, int w_y)
 
   if (end_path || close_path) {
     /* Add object to page and clean up path drawing state */
-    OBJECT *obj = geda_path_object_new_take_path (toplevel, OBJ_PATH,
+    OBJECT *obj = geda_path_object_new_take_path (OBJ_PATH,
                                                   GRAPHIC_COLOR, p);
     w_current->temp_path = NULL;
     w_current->first_wx = -1;
@@ -507,7 +503,7 @@ o_path_end(GschemToplevel *w_current, int w_x, int w_y)
     w_current->third_wx = -1;
     w_current->third_wy = -1;
 
-    s_page_append (toplevel, page, obj);
+    s_page_append (page, obj);
     g_run_hook_object (w_current, "%add-objects-hook", obj);
     gschem_toplevel_page_content_changed (w_current, page);
     o_undo_savestate (w_current, page, UNDO_ALL);
diff --git a/schematic/src/o_picture.c b/schematic/src/o_picture.c
index 71bfd5456..97ed4d883 100644
--- a/schematic/src/o_picture.c
+++ b/schematic/src/o_picture.c
@@ -102,14 +102,13 @@ void o_picture_end(GschemToplevel *w_current, int w_x, int w_y)
   if ((picture_width != 0) && (picture_height != 0)) {
 
     /* create the object */
-    new_obj = o_picture_new(toplevel,
-                            NULL, 0, w_current->pixbuf_filename,
-                            OBJ_PICTURE,
-                            picture_left, picture_top,
-                            picture_left + picture_width,
-                            picture_top - picture_height,
-                            0, FALSE, FALSE);
-    s_page_append (toplevel, toplevel->page_current, new_obj);
+    new_obj = o_picture_new (NULL, 0, w_current->pixbuf_filename,
+                             OBJ_PICTURE,
+                             picture_left, picture_top,
+                             picture_left + picture_width,
+                             picture_top - picture_height,
+                             0, FALSE, FALSE);
+    s_page_append (toplevel->page_current, new_obj);
 
     /* Run %add-objects-hook */
     g_run_hook_object (w_current, "%add-objects-hook", new_obj);
@@ -315,7 +314,7 @@ o_picture_exchange (GschemToplevel *w_current,
       /* Erase previous picture */
       o_invalidate (w_current, object);
 
-      status = o_picture_set_from_file (toplevel, object, filename, error);
+      status = o_picture_set_from_file (object, filename, error);
       if (!status) return FALSE;
 
       /* Draw new picture */
diff --git a/schematic/src/o_pin.c b/schematic/src/o_pin.c
index ec3351c90..2ed071208 100644
--- a/schematic/src/o_pin.c
+++ b/schematic/src/o_pin.c
@@ -53,9 +53,6 @@ void o_pin_end(GschemToplevel *w_current, int x, int y)
   PAGE *page = gschem_page_view_get_page (page_view);
   g_return_if_fail (page != NULL);
 
-  TOPLEVEL *toplevel = page->toplevel;
-  g_return_if_fail (toplevel != NULL);
-
   /* undraw rubber line */
   /* o_pin_invalidate_rubber (w_current); */
   w_current->rubber_visible = 0;
@@ -66,15 +63,14 @@ void o_pin_end(GschemToplevel *w_current, int x, int y)
     return;
   }
 
-  new_obj = geda_pin_object_new (toplevel,
-                                 PIN_COLOR,
+  new_obj = geda_pin_object_new (PIN_COLOR,
                                  w_current->first_wx,
                                  w_current->first_wy,
                                  w_current->second_wx,
                                  w_current->second_wy,
                                  PIN_TYPE_NET,
                                  0);
-  s_page_append (toplevel, page, new_obj);
+  s_page_append (page, new_obj);
 
   /* Call add-objects-hook */
   g_run_hook_object (w_current, "%add-objects-hook", new_obj);
diff --git a/schematic/src/o_place.c b/schematic/src/o_place.c
index f8b9b4874..5c61628eb 100644
--- a/schematic/src/o_place.c
+++ b/schematic/src/o_place.c
@@ -94,8 +94,7 @@ void o_place_end (GschemToplevel *w_current,
 
   if (continue_placing) {
     /* Make a copy of the place list if we want to keep it afterwards */
-    temp_dest_list = o_glist_copy_all (page->toplevel,
-                                       page->place_list,
+    temp_dest_list = o_glist_copy_all (page->place_list,
                                        temp_dest_list);
   } else {
     /* Otherwise just take it */
@@ -110,7 +109,7 @@ void o_place_end (GschemToplevel *w_current,
   for (iter = temp_dest_list; iter != NULL; iter = g_list_next (iter)) {
     o_current = (OBJECT*) iter->data;
 
-    s_page_append (page->toplevel, page, o_current);
+    s_page_append (page, o_current);
 
     /* Update object connectivity */
     s_conn_update_object (page, o_current);
@@ -363,8 +362,7 @@ void o_place_rotate (GschemToplevel *w_current)
   geda_object_list_rotate (page->place_list,
                            w_current->first_wx,
                            w_current->first_wy,
-                           90,
-                           page->toplevel);
+                           90);
 
   /* Run rotate-objects-hook */
   g_run_hook_object_list (w_current, "%rotate-objects-hook", page->place_list);
@@ -394,8 +392,7 @@ void o_place_mirror (GschemToplevel *w_current)
 
   geda_object_list_mirror (page->place_list,
                            w_current->first_wx,
-                           w_current->first_wy,
-                           page->toplevel);
+                           w_current->first_wy);
 
   /* Run mirror-objects-hook */
   g_run_hook_object_list (w_current, "%mirror-objects-hook", page->place_list);
diff --git a/schematic/src/o_select.c b/schematic/src/o_select.c
index 61fb4dbac..9450b8a93 100644
--- a/schematic/src/o_select.c
+++ b/schematic/src/o_select.c
@@ -193,8 +193,7 @@ void o_select_object(GschemToplevel *w_current, OBJECT *o_current,
 
       /* object not select, add it to the selection list */
       o_select_run_hooks( w_current, o_current, 1 );
-      o_selection_add (toplevel,
-                       toplevel->page_current->selection_list, o_current);
+      o_selection_add (toplevel->page_current->selection_list, o_current);
 
       break;
 
@@ -209,8 +208,8 @@ void o_select_object(GschemToplevel *w_current, OBJECT *o_current,
           /* result: remove object from selection */
           if (type != MULTIPLE) {
             o_select_run_hooks( w_current, o_current, 0 );
-            o_selection_remove (toplevel, toplevel->page_current->
-                                            selection_list, o_current);
+            o_selection_remove (toplevel->page_current->selection_list,
+                                o_current);
             removing_obj = 1;
           }
 
@@ -227,8 +226,7 @@ void o_select_object(GschemToplevel *w_current, OBJECT *o_current,
             o_select_unselect_all (w_current);
 
             o_select_run_hooks( w_current, o_current, 1 );
-            o_selection_add (toplevel,
-                             toplevel->page_current->selection_list, o_current);
+            o_selection_add (toplevel->page_current->selection_list, o_current);
           }
 
           /* condition: doing single object add */
@@ -239,14 +237,14 @@ void o_select_object(GschemToplevel *w_current, OBJECT *o_current,
             o_select_unselect_all (w_current);
 
             o_select_run_hooks (w_current, o_current, 1);
-            o_selection_add (toplevel, toplevel->page_current->
-                                         selection_list, o_current);
+            o_selection_add (toplevel->page_current->selection_list,
+                             o_current);
           }
 
           if (CONTROLKEY) {
             o_select_run_hooks(w_current, o_current, 0);
-            o_selection_remove (toplevel, toplevel->page_current->
-                                            selection_list, o_current);
+            o_selection_remove (toplevel->page_current->selection_list,
+                                o_current);
             removing_obj = 1;
           }
 
@@ -400,7 +398,7 @@ void o_select_box_search(GschemToplevel *w_current)
   while (iter != NULL) {
     o_current = (OBJECT*) iter->data;
     /* only select visible objects */
-    if (o_is_visible (toplevel, o_current) || toplevel->show_hidden_text) {
+    if (o_is_visible (o_current) || toplevel->show_hidden_text) {
       int cleft, ctop, cright, cbottom;
 
       if ( geda_object_calculate_visible_bounds(toplevel, o_current,
@@ -570,7 +568,7 @@ void o_select_unselect_all(GschemToplevel *w_current)
 
   removed = g_list_copy (geda_list_get_glist (selection));
   for (iter = removed; iter != NULL; iter = g_list_next (iter)) {
-    o_selection_remove (toplevel, selection, (OBJECT *) iter->data);
+    o_selection_remove (selection, (OBJECT *) iter->data);
   }
 
   /* Call hooks */
@@ -602,7 +600,7 @@ o_select_visible_unlocked (GschemToplevel *w_current)
     OBJECT *obj = (OBJECT *) iter->data;
 
     /* Skip invisible objects. */
-    if (!o_is_visible (toplevel, obj) && !toplevel->show_hidden_text)
+    if (!o_is_visible (obj) && !toplevel->show_hidden_text)
       continue;
 
     /* Skip locked objects. */
@@ -614,7 +612,7 @@ o_select_visible_unlocked (GschemToplevel *w_current)
      * w_current->SHIFTKEY and w_current->CONTROLKEY, which may well
      * be set if this function is called via a keystroke
      * (e.g. Ctrl-A). */
-    o_selection_add (toplevel, selection, obj);
+    o_selection_add (selection, obj);
 
     /* Add any attributes of object to selection as well. */
     o_attrib_add_selected (w_current, selection, obj);
@@ -640,7 +638,7 @@ o_select_move_to_place_list(GschemToplevel *w_current)
   GList *selection_copy;
 
   /* remove the old place list if it exists */
-  geda_object_list_delete (toplevel, toplevel->page_current->place_list);
+  geda_object_list_delete (toplevel->page_current->place_list);
   toplevel->page_current->place_list = NULL;
 
   selection = geda_list_get_glist( toplevel->page_current->selection_list );
diff --git a/schematic/src/o_slot.c b/schematic/src/o_slot.c
index 12fb64592..e0ea4b213 100644
--- a/schematic/src/o_slot.c
+++ b/schematic/src/o_slot.c
@@ -113,12 +113,11 @@ void o_slot_end(GschemToplevel *w_current, OBJECT *object, const char *string)
   g_free (slot_value);
 
   if (o_slot != NULL && !o_attrib_is_inherited (o_slot)) {
-    o_text_set_string (toplevel, o_slot, string);
+    o_text_set_string (o_slot, string);
   } else {
     /* here you need to do the add the slot
        attribute since it doesn't exist */
-    new_obj = geda_text_object_new (toplevel,
-                                    ATTRIBUTE_COLOR,
+    new_obj = geda_text_object_new (ATTRIBUTE_COLOR,
                                     object->component->x,
                                     object->component->y,
                                     LOWER_LEFT,
@@ -127,16 +126,16 @@ void o_slot_end(GschemToplevel *w_current, OBJECT *object, const char *string)
                                     10,
                                     INVISIBLE,
                                     SHOW_NAME_VALUE);
-    s_page_append (toplevel, toplevel->page_current, new_obj);
+    s_page_append (toplevel->page_current, new_obj);
 
     /* manually attach attribute */
-    o_attrib_attach (toplevel, new_obj, object, FALSE);
+    o_attrib_attach (new_obj, object, FALSE);
 
     /* Call add-objects-hook */
     g_run_hook_object (w_current, "%add-objects-hook", new_obj);
   }
 
-  s_slot_update_object (toplevel, object);
+  s_slot_update_object (object);
 
   gschem_toplevel_page_content_changed (w_current, toplevel->page_current);
   g_free (value);
diff --git a/schematic/src/o_text.c b/schematic/src/o_text.c
index 5aaddd2a9..95d7463d4 100644
--- a/schematic/src/o_text.c
+++ b/schematic/src/o_text.c
@@ -45,10 +45,6 @@ void o_text_prepare_place(GschemToplevel *w_current, char *text, int color, int
     return;
   }
 
-  TOPLEVEL *toplevel = page->toplevel;
-  g_return_if_fail (toplevel != NULL);
-
-
   /* Insert the new object into the buffer at world coordinates (0,0).
    * It will be translated to the mouse coordinates during placement. */
 
@@ -58,14 +54,13 @@ void o_text_prepare_place(GschemToplevel *w_current, char *text, int color, int
   w_current->last_drawb_mode = LAST_DRAWB_MODE_NONE;
 
   /* remove the old place list if it exists */
-  geda_object_list_delete (toplevel, page->place_list);
+  geda_object_list_delete (page->place_list);
   page->place_list = NULL;
 
   /* here you need to add OBJ_TEXT when it's done */
   page->place_list =
     g_list_append(page->place_list,
-                  geda_text_object_new (toplevel,
-                                        color,
+                  geda_text_object_new (color,
                                         0,
                                         0,
                                         align,
@@ -99,9 +94,7 @@ void o_text_change(GschemToplevel *w_current, OBJECT *object, char *string,
   g_return_if_fail (page_view != NULL);
 
   PAGE *page = gschem_page_view_get_page (page_view);
-  TOPLEVEL *toplevel = page->toplevel;
 
-  g_return_if_fail (toplevel != NULL);
   g_return_if_fail (page != NULL);
 
   if (object == NULL) {
@@ -112,11 +105,11 @@ void o_text_change(GschemToplevel *w_current, OBJECT *object, char *string,
     return;
   }
 
-  o_text_set_string (toplevel, object, string);
+  o_text_set_string (object, string);
 
-  o_set_visibility (toplevel, object, visibility);
+  o_set_visibility (object, visibility);
   object->show_name_value = show;
-  o_text_recreate(toplevel, object);
+  o_text_recreate (object);
 
   /* handle slot= attribute, it's a special case */
   if (object->attached_to != NULL &&
diff --git a/schematic/src/o_undo.c b/schematic/src/o_undo.c
index 1c9055766..b7d5d4e99 100644
--- a/schematic/src/o_undo.c
+++ b/schematic/src/o_undo.c
@@ -160,7 +160,7 @@ o_undo_savestate (GschemToplevel *w_current, PAGE *page, int flag)
     /* This is where the net consolidation call would have been
      * triggered before it was removed from o_save_buffer().
      */
-    geda_net_object_consolidate (toplevel, page);
+    geda_net_object_consolidate (page);
   }
 
   if (w_current->undo_type == UNDO_DISK && flag == UNDO_ALL) {
@@ -173,20 +173,19 @@ o_undo_savestate (GschemToplevel *w_current, PAGE *page, int flag)
     /* f_save manages the creaton of backup copies.
        This way, f_save is called only when saving a file, and not when
        saving an undo backup copy */
-    o_save (toplevel, s_page_objects (page), filename, NULL);
+    o_save (s_page_objects (page), filename, NULL);
 
   } else if (w_current->undo_type == UNDO_MEMORY && flag == UNDO_ALL) {
-    object_list = o_glist_copy_all (toplevel,
-                                    s_page_objects (page),
+    object_list = o_glist_copy_all (s_page_objects (page),
                                     object_list);
   }
 
   /* Clear Anything above current */
   if (page->undo_current) {
-    s_undo_remove_rest(toplevel, page->undo_current->next);
+    s_undo_remove_rest (page->undo_current->next);
     page->undo_current->next = NULL;
   } else { /* undo current is NULL */
-    s_undo_remove_rest(toplevel, page->undo_bottom);
+    s_undo_remove_rest (page->undo_bottom);
     page->undo_bottom = NULL;
   }
 
@@ -270,7 +269,7 @@ o_undo_savestate (GschemToplevel *w_current, PAGE *page, int flag)
       }
 
       if (u_current->object_list) {
-        geda_object_list_delete (toplevel, u_current->object_list);
+        geda_object_list_delete (u_current->object_list);
         u_current->object_list = NULL;
       }
 
@@ -443,19 +442,19 @@ o_undo_callback (GschemToplevel *w_current, PAGE *page, int type)
 
   if (w_current->undo_type == UNDO_DISK && u_current->filename) {
     /* delete objects of page */
-    s_page_delete_objects (toplevel, page);
+    s_page_delete_objects (page);
 
     /* Free the objects in the place list. */
-    geda_object_list_delete (toplevel, page->place_list);
+    geda_object_list_delete (page->place_list);
     page->place_list = NULL;
 
     gschem_toplevel_page_content_changed (w_current, page);
   } else if (w_current->undo_type == UNDO_MEMORY && u_current->object_list) {
     /* delete objects of page */
-    s_page_delete_objects (toplevel, page);
+    s_page_delete_objects (page);
 
     /* Free the objects in the place list. */
-    geda_object_list_delete (toplevel, page->place_list);
+    geda_object_list_delete (page->place_list);
     page->place_list = NULL;
 
     gschem_toplevel_page_content_changed (w_current, page);
@@ -476,8 +475,8 @@ o_undo_callback (GschemToplevel *w_current, PAGE *page, int type)
 
   } else if (w_current->undo_type == UNDO_MEMORY && u_current->object_list) {
 
-    s_page_append_list (toplevel, page,
-                        o_glist_copy_all (toplevel, u_current->object_list,
+    s_page_append_list (page,
+                        o_glist_copy_all (u_current->object_list,
                                           NULL));
   }
 
diff --git a/schematic/src/x_attribedit.c b/schematic/src/x_attribedit.c
index 1af179cf2..536c3cd95 100644
--- a/schematic/src/x_attribedit.c
+++ b/schematic/src/x_attribedit.c
@@ -238,7 +238,7 @@ void attrib_edit_dialog_ok(GtkWidget * w, GschemToplevel *w_current)
 	o_invalidate (w_current, new_object);
 	new_object->text->x = wx;
 	new_object->text->y = wy;
-	o_text_recreate(toplevel, new_object);
+	o_text_recreate (new_object);
     gschem_toplevel_page_content_changed (w_current, toplevel->page_current);
 	o_undo_savestate_old(w_current, UNDO_ALL);
       }
@@ -527,7 +527,7 @@ void attrib_edit_dialog (GschemToplevel *w_current, OBJECT *attr_obj, int flag)
   if (attr_obj) {
     o_attrib_get_name_value (attr_obj, &name, &val);
     attrib = attr_obj;
-    if (o_is_visible (toplevel, attrib)) {
+    if (o_is_visible (attrib)) {
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(visbutton), TRUE);
     } else {
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(visbutton), FALSE);
diff --git a/schematic/src/x_autonumber.c b/schematic/src/x_autonumber.c
index a51a469ca..45d032210 100644
--- a/schematic/src/x_autonumber.c
+++ b/schematic/src/x_autonumber.c
@@ -571,7 +571,7 @@ void autonumber_remove_number(AUTONUMBER_TEXT * autotext, OBJECT *o_current)
 
   /* replace old text */
   str = g_strdup_printf("%s?", autotext->current_searchtext);
-  o_text_set_string (autotext->w_current->toplevel, o_current, str);
+  o_text_set_string (o_current, str);
   g_free (str);
 
   /* remove the slot attribute if slotting is active */
@@ -613,7 +613,7 @@ void autonumber_apply_new_text(AUTONUMBER_TEXT * autotext, OBJECT *o_current,
 
   /* replace old text */
   str = g_strdup_printf("%s%d", autotext->current_searchtext, number);
-  o_text_set_string (autotext->w_current->toplevel, o_current, str);
+  o_text_set_string (o_current, str);
   g_free (str);
 
   gschem_toplevel_page_content_changed (autotext->w_current,
diff --git a/schematic/src/x_clipboard.c b/schematic/src/x_clipboard.c
index 1c4d352fb..59fed1caf 100644
--- a/schematic/src/x_clipboard.c
+++ b/schematic/src/x_clipboard.c
@@ -66,10 +66,9 @@ static void
 clip_clear (GtkClipboard *cb, gpointer user_data_or_owner)
 {
   GschemToplevel *w_current = GSCHEM_TOPLEVEL (user_data_or_owner);
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
 
   /* Free the objects in the clipboard buffer */
-  geda_object_list_delete (toplevel, w_current->clipboard_buffer);
+  geda_object_list_delete (w_current->clipboard_buffer);
   w_current->clipboard_buffer = NULL;
 }
 
@@ -180,7 +179,6 @@ x_clipboard_set (GschemToplevel *w_current, const GList *object_list)
   GtkClipboard *cb = gtk_clipboard_get (GDK_SELECTION_CLIPBOARD);
   GtkTargetEntry target = { (gchar*) MIME_TYPE_SCHEMATIC, 0,
                             CLIP_TYPE_SCHEMATIC };
-  TOPLEVEL *toplevel = gschem_toplevel_get_toplevel (w_current);
   gboolean result;
 
   /* Clear the clipboard buffer */
@@ -189,7 +187,7 @@ x_clipboard_set (GschemToplevel *w_current, const GList *object_list)
 
   /* Copy the objects to the clipboard buffer */
   w_current->clipboard_buffer =
-    o_glist_copy_all (toplevel, object_list, w_current->clipboard_buffer);
+    o_glist_copy_all (object_list, w_current->clipboard_buffer);
 
   /* Advertise that the data is available */
   result = gtk_clipboard_set_with_data (cb, &target, 1,
diff --git a/schematic/src/x_compselect.c b/schematic/src/x_compselect.c
index 6824e0328..85a73f4c3 100644
--- a/schematic/src/x_compselect.c
+++ b/schematic/src/x_compselect.c
@@ -134,8 +134,7 @@ x_compselect_callback_response (GtkDialog *dialog,
           if (w_current->rubber_visible)
             o_place_invalidate_rubber (w_current, FALSE);
           w_current->rubber_visible = 0;
-          geda_object_list_delete (toplevel,
-                                   toplevel->page_current->place_list);
+          geda_object_list_delete (toplevel->page_current->place_list);
           toplevel->page_current->place_list = NULL;
         } else {
           /* Cancel whatever other action is currently in progress */
diff --git a/schematic/src/x_multiattrib.c b/schematic/src/x_multiattrib.c
index 1499492dc..5339c8361 100644
--- a/schematic/src/x_multiattrib.c
+++ b/schematic/src/x_multiattrib.c
@@ -616,7 +616,7 @@ multiattrib_action_duplicate_attributes (Multiattrib *multiattrib,
     /* create a new attribute and link it */
     o_attrib_add_attrib (w_current,
                          geda_text_object_get_string (o_attrib),
-                         o_is_visible (w_current->toplevel, o_attrib),
+                         o_is_visible (o_attrib),
                          o_attrib->show_name_value,
                          o_attrib->attached_to);
   }
@@ -644,7 +644,7 @@ multiattrib_action_promote_attributes (Multiattrib *multiattrib,
        iter = g_list_next (iter)) {
     OBJECT *o_attrib = (OBJECT *)iter->data;
 
-    if (o_is_visible (toplevel, o_attrib)) {
+    if (o_is_visible (o_attrib)) {
       /* If the attribute we're promoting is visible, don't clone its location */
       o_attrib_add_attrib (w_current,
                            geda_text_object_get_string (o_attrib),
@@ -653,10 +653,10 @@ multiattrib_action_promote_attributes (Multiattrib *multiattrib,
                            o_attrib->parent);
     } else {
         /* make a copy of the attribute object */
-        o_new = o_object_copy (toplevel, o_attrib);
-        s_page_append (toplevel, toplevel->page_current, o_new);
+        o_new = o_object_copy (o_attrib);
+        s_page_append (toplevel->page_current, o_new);
         /* add the attribute its parent */
-        o_attrib_attach (toplevel, o_new, o_attrib->parent, TRUE);
+        o_attrib_attach (o_new, o_attrib->parent, TRUE);
         /* note: this object is unselected (not added to selection). */
 
         /* Call add-objects-hook */
@@ -723,7 +723,7 @@ multiattrib_action_copy_attribute_to_all (Multiattrib *multiattrib,
       /* Pick the first instance to copy from */
       OBJECT *attrib_to_copy = (OBJECT*) attr_list->data;
 
-      int visibility = o_is_visible (w_current->toplevel, attrib_to_copy)
+      int visibility = o_is_visible (attrib_to_copy)
           ? VISIBLE : INVISIBLE;
 
       /* create a new attribute and link it */
@@ -979,7 +979,7 @@ multiattrib_callback_edited_name (GtkCellRendererText *cellrenderertext,
        a_iter = g_list_next (a_iter)) {
     o_attrib = (OBJECT*) a_iter->data;
 
-    visibility = o_is_visible (w_current->toplevel, o_attrib)
+    visibility = o_is_visible (o_attrib)
         ? VISIBLE : INVISIBLE;
 
     /* actually modifies the attribute */
@@ -1066,7 +1066,7 @@ multiattrib_callback_edited_value (GtkCellRendererText *cell_renderer,
        a_iter = g_list_next (a_iter)) {
     o_attrib = (OBJECT *)a_iter->data;
 
-    visibility = o_is_visible (w_current->toplevel, o_attrib)
+    visibility = o_is_visible (o_attrib)
         ? VISIBLE : INVISIBLE;
 
     /* actually modifies the attribute */
@@ -1128,8 +1128,8 @@ multiattrib_callback_toggled_visible (GtkCellRendererToggle *cell_renderer,
 
     /* actually modifies the attribute */
     o_invalidate (w_current, o_attrib);
-    o_set_visibility (w_current->toplevel, o_attrib, new_visibility ? VISIBLE : INVISIBLE);
-    o_text_recreate (w_current->toplevel, o_attrib);
+    o_set_visibility (o_attrib, new_visibility ? VISIBLE : INVISIBLE);
+    o_text_recreate (o_attrib);
   }
 
   g_object_unref (attr_list);
@@ -1193,7 +1193,7 @@ multiattrib_callback_toggled_show_name (GtkCellRendererToggle *cell_renderer,
 
     /* actually modifies the attribute */
     o_attrib->show_name_value = new_snv;
-    o_text_recreate (w_current->toplevel, o_attrib);
+    o_text_recreate (o_attrib);
   }
 
   g_object_unref (attr_list);
@@ -1257,7 +1257,7 @@ multiattrib_callback_toggled_show_value (GtkCellRendererToggle *cell_renderer,
 
     /* actually modifies the attribute */
     o_attrib->show_name_value = new_snv;
-    o_text_recreate (w_current->toplevel, o_attrib);
+    o_text_recreate (o_attrib);
   }
 
   g_object_unref (attr_list);
@@ -2460,7 +2460,6 @@ typedef struct {
 static GList *
 object_attributes_to_model_rows (Multiattrib *multiattrib, OBJECT *object)
 {
-  GschemToplevel *w_current = GSCHEM_DIALOG (multiattrib)->w_current;
   GList *model_rows = NULL;
   GList *a_iter;
   GList *object_attribs = o_attrib_return_attribs (object);
@@ -2474,7 +2473,7 @@ object_attributes_to_model_rows (Multiattrib *multiattrib, OBJECT *object)
 
     m_row->inherited = o_attrib_is_inherited (a_current);
     o_attrib_get_name_value (a_current, &m_row->name, &m_row->value);
-    m_row->visibility = o_is_visible (w_current->toplevel, a_current);
+    m_row->visibility = o_is_visible (a_current);
     m_row->show_name_value = a_current->show_name_value;
     m_row->nth_with_name = 0; /* Provisional value until we check below */
 
@@ -2524,7 +2523,6 @@ object_attributes_to_model_rows (Multiattrib *multiattrib, OBJECT *object)
 static GList *
 lone_attributes_to_model_rows (Multiattrib *multiattrib)
 {
-  GschemToplevel *w_current = GSCHEM_DIALOG (multiattrib)->w_current;
   GList *o_iter;
   GList *model_rows = NULL;
 
@@ -2546,7 +2544,7 @@ lone_attributes_to_model_rows (Multiattrib *multiattrib)
     m_row = g_new0 (MODEL_ROW, 1);
     m_row->inherited = o_attrib_is_inherited (object);
     o_attrib_get_name_value (object, &m_row->name, &m_row->value);
-    m_row->visibility = o_is_visible (w_current->toplevel, object);
+    m_row->visibility = o_is_visible (object);
     m_row->show_name_value = object->show_name_value;
     m_row->nth_with_name = 0; /* All selected attributes are treated individually */
 
diff --git a/schematic/src/x_tabs.c b/schematic/src/x_tabs.c
index c601e5022..2cb57486c 100644
--- a/schematic/src/x_tabs.c
+++ b/schematic/src/x_tabs.c
@@ -1058,7 +1058,7 @@ x_tabs_cancel_all (GschemToplevel* w_current)
   TOPLEVEL* toplevel = gschem_toplevel_get_toplevel (w_current);
   if (toplevel->page_current != NULL)
   {
-    geda_object_list_delete (toplevel, toplevel->page_current->place_list);
+    geda_object_list_delete (toplevel->page_current->place_list);
     toplevel->page_current->place_list = NULL;
   }
 
diff --git a/schematic/src/x_window.c b/schematic/src/x_window.c
index 32f819888..cbd8cf61b 100644
--- a/schematic/src/x_window.c
+++ b/schematic/src/x_window.c
@@ -831,7 +831,7 @@ x_window_save_page (GschemToplevel *w_current, PAGE *page, const gchar *filename
   g_return_val_if_fail (filename != NULL, 0);
 
   /* try saving page to filename */
-  ret = (gint)f_save (toplevel, page, filename, &err);
+  ret = (gint)f_save (page, filename, &err);
 
   if (ret != 1) {
     log_msg   = _("Could NOT save page [%1$s]\n");
